#!/usr/bin/env python3
"""
Save Knowledge Script
Simpan learnings dari chat session ke memory system.

Usage:
    python scripts/save-knowledge.py "deskripsi solusi penting"
    python scripts/save-knowledge.py --category gotchas "Oracle harus explicit commit"
"""

import json
import sys
import re
from datetime import datetime
from pathlib import Path
from typing import Optional, List, Tuple

class KnowledgeSaver:
    def __init__(self):
        self.base_path = Path(__file__).parent.parent.parent / 'docs' / 'knowledge'  # .agent/scripts -> .agent/memory
        self.entries_path = self.base_path / 'entries'
        self.index_file = self.base_path / 'index.json'
        self.similarity_threshold = 0.6  # 60% similarity = duplicate

    def check_duplicate(self, message: str, category: str = None) -> Tuple[bool, Optional[dict]]:
        """
        Check if similar knowledge already exists.
        Returns: (is_duplicate, existing_entry)
        """
        if not self.index_file.exists():
            return False, None

        with open(self.index_file, 'r', encoding='utf-8') as f:
            index = json.load(f)

        message_words = set(re.findall(r'\w+', message.lower()))

        for cat_name, cat_data in index.get('categories', {}).items():
            if category and cat_name != category:
                continue

            for entry in cat_data.get('entries', []):
                # Check title similarity
                title_words = set(re.findall(r'\w+', entry.get('title', '').lower()))
                if title_words and message_words:
                    title_overlap = len(title_words & message_words) / max(len(title_words), 1)
                    if title_overlap > self.similarity_threshold:
                        return True, {'category': cat_name, **entry}

                # Check file content similarity
                file_path = self.base_path / entry.get('file', '')
                if file_path.exists():
                    content = file_path.read_text(encoding='utf-8').lower()
                    content_words = set(re.findall(r'\w+', content))
                    if content_words and message_words:
                        content_overlap = len(content_words & message_words) / len(message_words)
                        if content_overlap > 0.8:  # 80% of new message already in existing
                            return True, {'category': cat_name, **entry}

        return False, None

    def save(
        self,
        message: str,
        category: str = 'learnings',
        tags: Optional[List[str]] = None,
        force: bool = False
    ) -> str:
        """Save knowledge entry"""

        # Check for duplicates first (unless force=True)
        if not force:
            is_dup, existing = self.check_duplicate(message, category)
            if is_dup:
                raise ValueError(
                    f"⚠️ Similar entry already exists!\n"
                    f"   Category: {existing['category']}\n"
                    f"   Title: {existing.get('title', 'Unknown')}\n"
                    f"   File: {existing.get('file', 'Unknown')}\n"
                    f"\nUse --force to save anyway."
                )

        # Generate ID & filename
        timestamp = datetime.now()
        entry_id = timestamp.strftime("%Y%m%d-%H%M%S")
        title = self._generate_title(message)
        slug = self._slugify(title)
        filename = f"{slug}.md"

        # Ensure directory exists
        category_path = self.entries_path / category
        category_path.mkdir(parents=True, exist_ok=True)

        # Auto-detect tags if not provided
        if not tags:
            tags = self._extract_tags(message)

        # Create markdown content
        content = f"""# {title}

**Category:** {category}
**Tags:** {', '.join(tags)}
**Date Added:** {timestamp.strftime('%Y-%m-%d')}
**Source:** Chat session

---

## Content

{message}

---

*Auto-generated by AI Agent Knowledge System*
"""

        # Write file
        filepath = category_path / filename
        filepath.write_text(content, encoding='utf-8')

        # Update index
        self._update_index(entry_id, title, category, tags, str(filepath.relative_to(self.base_path)))

        return str(filepath)

    def _generate_title(self, message: str) -> str:
        """Generate title from message"""
        # Get first line or first 60 chars
        first_line = message.split('\n')[0]
        first_line = re.sub(r'^#+\s+', '', first_line)  # Remove markdown headers

        if len(first_line) > 60:
            first_line = first_line[:57] + '...'

        return first_line

    def _slugify(self, text: str) -> str:
        """Convert text to URL-friendly slug"""
        text = text.lower()
        text = re.sub(r'[^\w\s-]', '', text)
        text = re.sub(r'[\s_-]+', '-', text)
        text = text.strip('-')
        return text[:50]  # Limit length

    def _extract_tags(self, message: str) -> List[str]:
        """Auto-extract tags from message"""
        tags = []

        keywords = {
            'php': ['php', 'laravel', 'yii', 'symfony', 'composer', 'artisan'],
            'javascript': ['javascript', 'js', 'node', 'npm', 'vue', 'react', 'angular', 'express', 'nextjs'],
            'python': ['python', 'pip', 'django', 'flask', 'fastapi', 'pytest'],
            'go': ['golang', 'go mod', 'go build'],
            'rust': ['rust', 'cargo', 'rustc'],
            'java': ['java', 'maven', 'gradle', 'spring', 'kotlin'],
            'dotnet': ['c#', 'csharp', '.net', 'dotnet', 'nuget', 'asp.net'],
            'ruby': ['ruby', 'rails', 'gem', 'bundler'],
            'database': ['mysql', 'oracle', 'postgresql', 'redis', 'mongodb', 'sqlite', 'sql'],
            'git': ['git', 'commit', 'push', 'branch', 'merge', 'rebase'],
            'docker': ['docker', 'container', 'dockerfile', 'compose'],
            'kubernetes': ['kubernetes', 'k8s', 'kubectl', 'helm', 'pod'],
            'cloud': ['aws', 'azure', 'gcp', 'cloud', 's3', 'ec2', 'lambda'],
            'performance': ['slow', 'fast', 'optimize', 'cache', 'memory', 'benchmark'],
            'error': ['error', 'bug', 'fix', 'crash', 'exception', 'debug'],
            'security': ['security', 'auth', 'jwt', 'oauth', 'encryption', 'password'],
            'api': ['api', 'rest', 'graphql', 'endpoint', 'http', 'request']
        }

        message_lower = message.lower()
        for tag, patterns in keywords.items():
            if any(p in message_lower for p in patterns):
                tags.append(tag)

        return tags[:5]  # Limit to 5 tags

    def _update_index(self, entry_id: str, title: str, category: str, tags: List[str], filepath: str):
        """Update the index.json file"""
        # Load existing index
        if self.index_file.exists():
            with open(self.index_file, 'r', encoding='utf-8') as f:
                index = json.load(f)
        else:
            index = {
                'version': '1.0.0',
                'lastUpdated': None,
                'totalEntries': 0,
                'categories': {}
            }

        # Ensure category exists
        if category not in index['categories']:
            index['categories'][category] = {
                'description': f'{category.title()} entries',
                'count': 0,
                'entries': []
            }

        # Add entry
        index['categories'][category]['entries'].append({
            'id': entry_id,
            'title': title,
            'file': filepath,
            'tags': tags
        })
        index['categories'][category]['count'] += 1
        index['totalEntries'] += 1
        index['lastUpdated'] = datetime.now().isoformat()

        # Save index
        with open(self.index_file, 'w', encoding='utf-8') as f:
            json.dump(index, f, indent=2, ensure_ascii=False)


def main():
    """Main entry point"""
    if len(sys.argv) < 2:
        print("Usage: python save-knowledge.py [options] <message>")
        print("\nOptions:")
        print("  --category <cat>    Category (gotchas, patterns, decisions, learnings)")
        print("  --force             Save even if duplicate detected")
        print("\nExamples:")
        print('  python save-knowledge.py "Oracle harus explicit commit"')
        print('  python save-knowledge.py --category gotchas "MySQL gunakan 127.0.0.1"')
        print('  python save-knowledge.py --force "Duplicate message"')
        sys.exit(1)

    # Parse arguments
    args = sys.argv[1:]
    category = 'learnings'
    force = False

    if '--category' in args:
        idx = args.index('--category')
        if idx + 1 < len(args):
            category = args[idx + 1]
            args = args[:idx] + args[idx + 2:]

    if '--force' in args:
        force = True
        args.remove('--force')

    message = ' '.join(args)

    if not message:
        print("❌ Please provide a message!")
        sys.exit(1)

    # Save
    saver = KnowledgeSaver()

    try:
        filepath = saver.save(message, category, force=force)
        print(f"✅ Knowledge saved!")
        print(f"   Category: {category}")
        print(f"   File: {filepath}")
    except ValueError as e:
        print(str(e))
        sys.exit(1)


if __name__ == '__main__':
    main()
