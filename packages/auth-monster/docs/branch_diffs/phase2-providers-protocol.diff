diff --git a/package-lock.json b/package-lock.json
index 559a254..a2b1fd1 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -10,13 +10,8 @@
       "hasInstallScript": true,
       "license": "ISC",
       "dependencies": {
-        "@types/blessed": "^0.1.27",
-        "@types/express": "^5.0.6",
-        "blessed": "^0.1.81",
-        "blessed-contrib": "^4.11.0",
         "commander": "^14.0.2",
         "enquirer": "^2.4.1",
-        "express": "^5.2.1",
         "https-proxy-agent": "^7.0.6",
         "proper-lockfile": "^4.1.2",
         "socks-proxy-agent": "^8.0.5",
@@ -27,26 +22,12 @@
         "opencode-monster": "dist/cli.js"
       },
       "devDependencies": {
-        "@types/chai": "^4.3.20",
-        "@types/mocha": "^10.0.10",
         "@types/node": "^25.0.10",
         "@types/proper-lockfile": "^4.1.4",
-        "chai": "^4.5.0",
-        "mocha": "^11.7.5",
         "ts-node": "^10.9.2",
         "typescript": "^5.9.3"
       }
     },
-    "node_modules/@colors/colors": {
-      "version": "1.5.0",
-      "resolved": "https://registry.npmjs.org/@colors/colors/-/colors-1.5.0.tgz",
-      "integrity": "sha512-ooWCrlZP11i8GImSjTHYHLkvFDP48nS4+204nGb1RiX/WXYHmJA2III9/e2DWVabCESdW7hBAEzHRqUn9OUVvQ==",
-      "license": "MIT",
-      "optional": true,
-      "engines": {
-        "node": ">=0.1.90"
-      }
-    },
     "node_modules/@cspotcode/source-map-support": {
       "version": "0.8.1",
       "resolved": "https://registry.npmjs.org/@cspotcode/source-map-support/-/source-map-support-0.8.1.tgz",
@@ -60,53 +41,6 @@
         "node": ">=12"
       }
     },
-    "node_modules/@isaacs/cliui": {
-      "version": "8.0.2",
-      "resolved": "https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz",
-      "integrity": "sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==",
-      "dev": true,
-      "license": "ISC",
-      "dependencies": {
-        "string-width": "^5.1.2",
-        "string-width-cjs": "npm:string-width@^4.2.0",
-        "strip-ansi": "^7.0.1",
-        "strip-ansi-cjs": "npm:strip-ansi@^6.0.1",
-        "wrap-ansi": "^8.1.0",
-        "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0"
-      },
-      "engines": {
-        "node": ">=12"
-      }
-    },
-    "node_modules/@isaacs/cliui/node_modules/ansi-regex": {
-      "version": "6.2.2",
-      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
-      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
-      "dev": true,
-      "license": "MIT",
-      "engines": {
-        "node": ">=12"
-      },
-      "funding": {
-        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
-      }
-    },
-    "node_modules/@isaacs/cliui/node_modules/strip-ansi": {
-      "version": "7.1.2",
-      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
-      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "ansi-regex": "^6.0.1"
-      },
-      "engines": {
-        "node": ">=12"
-      },
-      "funding": {
-        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
-      }
-    },
     "node_modules/@jridgewell/resolve-uri": {
       "version": "3.1.2",
       "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
@@ -135,17 +69,6 @@
         "@jridgewell/sourcemap-codec": "^1.4.10"
       }
     },
-    "node_modules/@pkgjs/parseargs": {
-      "version": "0.11.0",
-      "resolved": "https://registry.npmjs.org/@pkgjs/parseargs/-/parseargs-0.11.0.tgz",
-      "integrity": "sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==",
-      "dev": true,
-      "license": "MIT",
-      "optional": true,
-      "engines": {
-        "node": ">=14"
-      }
-    },
     "node_modules/@tsconfig/node10": {
       "version": "1.0.12",
       "resolved": "https://registry.npmjs.org/@tsconfig/node10/-/node10-1.0.12.tgz",
@@ -174,81 +97,11 @@
       "dev": true,
       "license": "MIT"
     },
-    "node_modules/@types/blessed": {
-      "version": "0.1.27",
-      "resolved": "https://registry.npmjs.org/@types/blessed/-/blessed-0.1.27.tgz",
-      "integrity": "sha512-ZOQGjLvWDclAXp0rW5iuUBXeD6Gr1PkitN7tj7/G8FCoSzTsij6OhXusOzMKhwrZ9YlL2Pmu0d6xJ9zVvk+Hsg==",
-      "license": "MIT",
-      "dependencies": {
-        "@types/node": "*"
-      }
-    },
-    "node_modules/@types/body-parser": {
-      "version": "1.19.6",
-      "resolved": "https://registry.npmjs.org/@types/body-parser/-/body-parser-1.19.6.tgz",
-      "integrity": "sha512-HLFeCYgz89uk22N5Qg3dvGvsv46B8GLvKKo1zKG4NybA8U2DiEO3w9lqGg29t/tfLRJpJ6iQxnVw4OnB7MoM9g==",
-      "license": "MIT",
-      "dependencies": {
-        "@types/connect": "*",
-        "@types/node": "*"
-      }
-    },
-    "node_modules/@types/chai": {
-      "version": "4.3.20",
-      "resolved": "https://registry.npmjs.org/@types/chai/-/chai-4.3.20.tgz",
-      "integrity": "sha512-/pC9HAB5I/xMlc5FP77qjCnI16ChlJfW0tGa0IUcFn38VJrTV6DeZ60NU5KZBtaOZqjdpwTWohz5HU1RrhiYxQ==",
-      "dev": true,
-      "license": "MIT"
-    },
-    "node_modules/@types/connect": {
-      "version": "3.4.38",
-      "resolved": "https://registry.npmjs.org/@types/connect/-/connect-3.4.38.tgz",
-      "integrity": "sha512-K6uROf1LD88uDQqJCktA4yzL1YYAK6NgfsI0v/mTgyPKWsX1CnJ0XPSDhViejru1GcRkLWb8RlzFYJRqGUbaug==",
-      "license": "MIT",
-      "dependencies": {
-        "@types/node": "*"
-      }
-    },
-    "node_modules/@types/express": {
-      "version": "5.0.6",
-      "resolved": "https://registry.npmjs.org/@types/express/-/express-5.0.6.tgz",
-      "integrity": "sha512-sKYVuV7Sv9fbPIt/442koC7+IIwK5olP1KWeD88e/idgoJqDm3JV/YUiPwkoKK92ylff2MGxSz1CSjsXelx0YA==",
-      "license": "MIT",
-      "dependencies": {
-        "@types/body-parser": "*",
-        "@types/express-serve-static-core": "^5.0.0",
-        "@types/serve-static": "^2"
-      }
-    },
-    "node_modules/@types/express-serve-static-core": {
-      "version": "5.1.1",
-      "resolved": "https://registry.npmjs.org/@types/express-serve-static-core/-/express-serve-static-core-5.1.1.tgz",
-      "integrity": "sha512-v4zIMr/cX7/d2BpAEX3KNKL/JrT1s43s96lLvvdTmza1oEvDudCqK9aF/djc/SWgy8Yh0h30TZx5VpzqFCxk5A==",
-      "license": "MIT",
-      "dependencies": {
-        "@types/node": "*",
-        "@types/qs": "*",
-        "@types/range-parser": "*",
-        "@types/send": "*"
-      }
-    },
-    "node_modules/@types/http-errors": {
-      "version": "2.0.5",
-      "resolved": "https://registry.npmjs.org/@types/http-errors/-/http-errors-2.0.5.tgz",
-      "integrity": "sha512-r8Tayk8HJnX0FztbZN7oVqGccWgw98T/0neJphO91KkmOzug1KkofZURD4UaD5uH8AqcFLfdPErnBod0u71/qg==",
-      "license": "MIT"
-    },
-    "node_modules/@types/mocha": {
-      "version": "10.0.10",
-      "resolved": "https://registry.npmjs.org/@types/mocha/-/mocha-10.0.10.tgz",
-      "integrity": "sha512-xPyYSz1cMPnJQhl0CLMH68j3gprKZaTjG3s5Vi+fDgx+uhG9NOXwbVt52eFS8ECyXhyKcjDLCBEqBExKuiZb7Q==",
-      "dev": true,
-      "license": "MIT"
-    },
     "node_modules/@types/node": {
       "version": "25.0.10",
       "resolved": "https://registry.npmjs.org/@types/node/-/node-25.0.10.tgz",
       "integrity": "sha512-zWW5KPngR/yvakJgGOmZ5vTBemDoSqF3AcV/LrO5u5wTWyEAVVh+IT39G4gtyAkh3CtTZs8aX/yRM82OfzHJRg==",
+      "dev": true,
       "license": "MIT",
       "dependencies": {
         "undici-types": "~7.16.0"
@@ -264,18 +117,6 @@
         "@types/retry": "*"
       }
     },
-    "node_modules/@types/qs": {
-      "version": "6.14.0",
-      "resolved": "https://registry.npmjs.org/@types/qs/-/qs-6.14.0.tgz",
-      "integrity": "sha512-eOunJqu0K1923aExK6y8p6fsihYEn/BYuQ4g0CxAAgFc4b/ZLN4CrsRZ55srTdqoiLzU2B2evC+apEIxprEzkQ==",
-      "license": "MIT"
-    },
-    "node_modules/@types/range-parser": {
-      "version": "1.2.7",
-      "resolved": "https://registry.npmjs.org/@types/range-parser/-/range-parser-1.2.7.tgz",
-      "integrity": "sha512-hKormJbkJqzQGhziax5PItDUTMAM9uE2XXQmM37dyd4hVM+5aVl7oVxMVUiVQn2oCQFN/LKCZdvSM0pFRqbSmQ==",
-      "license": "MIT"
-    },
     "node_modules/@types/retry": {
       "version": "0.12.5",
       "resolved": "https://registry.npmjs.org/@types/retry/-/retry-0.12.5.tgz",
@@ -283,44 +124,6 @@
       "dev": true,
       "license": "MIT"
     },
-    "node_modules/@types/send": {
-      "version": "1.2.1",
-      "resolved": "https://registry.npmjs.org/@types/send/-/send-1.2.1.tgz",
-      "integrity": "sha512-arsCikDvlU99zl1g69TcAB3mzZPpxgw0UQnaHeC1Nwb015xp8bknZv5rIfri9xTOcMuaVgvabfIRA7PSZVuZIQ==",
-      "license": "MIT",
-      "dependencies": {
-        "@types/node": "*"
-      }
-    },
-    "node_modules/@types/serve-static": {
-      "version": "2.2.0",
-      "resolved": "https://registry.npmjs.org/@types/serve-static/-/serve-static-2.2.0.tgz",
-      "integrity": "sha512-8mam4H1NHLtu7nmtalF7eyBH14QyOASmcxHhSfEoRyr0nP/YdoesEtU+uSRvMe96TW/HPTtkoKqQLl53N7UXMQ==",
-      "license": "MIT",
-      "dependencies": {
-        "@types/http-errors": "*",
-        "@types/node": "*"
-      }
-    },
-    "node_modules/abbrev": {
-      "version": "1.1.1",
-      "resolved": "https://registry.npmjs.org/abbrev/-/abbrev-1.1.1.tgz",
-      "integrity": "sha512-nne9/IiQ/hzIhY6pdDnbBtz7DjPTKrY00P/zvPSm5pOFkl6xuGrGnXn/VtTNNfNtAfZ9/1RtehkszU9qcTii0Q==",
-      "license": "ISC"
-    },
-    "node_modules/accepts": {
-      "version": "2.0.0",
-      "resolved": "https://registry.npmjs.org/accepts/-/accepts-2.0.0.tgz",
-      "integrity": "sha512-5cvg6CtKwfgdmVqY1WIiXKc3Q1bkRqGLi+2W/6ao+6Y7gu/RCwRuAhGEzh5B4KlszSuTLgZYuqFqo5bImjNKng==",
-      "license": "MIT",
-      "dependencies": {
-        "mime-types": "^3.0.0",
-        "negotiator": "^1.0.0"
-      },
-      "engines": {
-        "node": ">= 0.6"
-      }
-    },
     "node_modules/acorn": {
       "version": "8.15.0",
       "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.15.0.tgz",
@@ -365,18 +168,6 @@
         "node": ">=6"
       }
     },
-    "node_modules/ansi-escapes": {
-      "version": "6.2.1",
-      "resolved": "https://registry.npmjs.org/ansi-escapes/-/ansi-escapes-6.2.1.tgz",
-      "integrity": "sha512-4nJ3yixlEthEJ9Rk4vPcdBRkZvQZlYyu8j4/Mqz5sgIkddmEnH2Yj2ZrnP9S3tQOvSNRUIgVNF/1yPpRAGNRig==",
-      "license": "MIT",
-      "engines": {
-        "node": ">=14.16"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/sindresorhus"
-      }
-    },
     "node_modules/ansi-regex": {
       "version": "5.0.1",
       "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
@@ -386,37 +177,6 @@
         "node": ">=8"
       }
     },
-    "node_modules/ansi-styles": {
-      "version": "4.3.0",
-      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
-      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "color-convert": "^2.0.1"
-      },
-      "engines": {
-        "node": ">=8"
-      },
-      "funding": {
-        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
-      }
-    },
-    "node_modules/ansi-term": {
-      "version": "0.0.2",
-      "resolved": "https://registry.npmjs.org/ansi-term/-/ansi-term-0.0.2.tgz",
-      "integrity": "sha512-jLnGE+n8uAjksTJxiWZf/kcUmXq+cRWSl550B9NmQ8YiqaTM+lILcSe5dHdp8QkJPhaOghDjnMKwyYSMjosgAA==",
-      "license": "ISC",
-      "dependencies": {
-        "x256": ">=0.0.1"
-      }
-    },
-    "node_modules/ansicolors": {
-      "version": "0.3.2",
-      "resolved": "https://registry.npmjs.org/ansicolors/-/ansicolors-0.3.2.tgz",
-      "integrity": "sha512-QXu7BPrP29VllRxH8GwB7x5iX5qWKAAMLqKQGWTeLWVlNHNOpVMJ91dsxQAIWXpjuW5wqvxu3Jd/nRjrJ+0pqg==",
-      "license": "MIT"
-    },
     "node_modules/arg": {
       "version": "4.1.3",
       "resolved": "https://registry.npmjs.org/arg/-/arg-4.1.3.tgz",
@@ -424,2296 +184,183 @@
       "dev": true,
       "license": "MIT"
     },
-    "node_modules/argparse": {
-      "version": "2.0.1",
-      "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
-      "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
-      "dev": true,
-      "license": "Python-2.0"
-    },
-    "node_modules/assertion-error": {
-      "version": "1.1.0",
-      "resolved": "https://registry.npmjs.org/assertion-error/-/assertion-error-1.1.0.tgz",
-      "integrity": "sha512-jgsaNduz+ndvGyFt3uSuWqvy4lCnIJiovtouQN5JZHOKCS2QuhEdbcQHFhVksz2N2U9hXJo8odG7ETyWlEeuDw==",
-      "dev": true,
+    "node_modules/commander": {
+      "version": "14.0.2",
+      "resolved": "https://registry.npmjs.org/commander/-/commander-14.0.2.tgz",
+      "integrity": "sha512-TywoWNNRbhoD0BXs1P3ZEScW8W5iKrnbithIl0YH+uCmBd0QpPOA8yc82DS3BIE5Ma6FnBVUsJ7wVUDz4dvOWQ==",
       "license": "MIT",
       "engines": {
-        "node": "*"
+        "node": ">=20"
       }
     },
-    "node_modules/balanced-match": {
-      "version": "1.0.2",
-      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
-      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
+    "node_modules/create-require": {
+      "version": "1.1.1",
+      "resolved": "https://registry.npmjs.org/create-require/-/create-require-1.1.1.tgz",
+      "integrity": "sha512-dcKFX3jn0MpIaXjisoRvexIJVEKzaq7z2rZKxf+MSr9TkdmHmsU4m2lcLojrj/FHl8mk5VxMmYA+ftRkP/3oKQ==",
       "dev": true,
       "license": "MIT"
     },
-    "node_modules/blessed": {
-      "version": "0.1.81",
-      "resolved": "https://registry.npmjs.org/blessed/-/blessed-0.1.81.tgz",
-      "integrity": "sha512-LoF5gae+hlmfORcG1M5+5XZi4LBmvlXTzwJWzUlPryN/SJdSflZvROM2TwkT0GMpq7oqT48NRd4GS7BiVBc5OQ==",
-      "license": "MIT",
-      "bin": {
-        "blessed": "bin/tput.js"
-      },
-      "engines": {
-        "node": ">= 0.8.0"
-      }
-    },
-    "node_modules/blessed-contrib": {
-      "version": "4.11.0",
-      "resolved": "https://registry.npmjs.org/blessed-contrib/-/blessed-contrib-4.11.0.tgz",
-      "integrity": "sha512-P00Xji3xPp53+FdU9f74WpvnOAn/SS0CKLy4vLAf5Ps7FGDOTY711ruJPZb3/7dpFuP+4i7f4a/ZTZdLlKG9WA==",
+    "node_modules/debug": {
+      "version": "4.4.3",
+      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
+      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
       "license": "MIT",
       "dependencies": {
-        "ansi-term": ">=0.0.2",
-        "chalk": "^1.1.0",
-        "drawille-canvas-blessed-contrib": ">=0.1.3",
-        "lodash": "~>=4.17.21",
-        "map-canvas": ">=0.1.5",
-        "marked": "^4.0.12",
-        "marked-terminal": "^5.1.1",
-        "memory-streams": "^0.1.0",
-        "memorystream": "^0.3.1",
-        "picture-tuber": "^1.0.1",
-        "sparkline": "^0.1.1",
-        "strip-ansi": "^3.0.0",
-        "term-canvas": "0.0.5",
-        "x256": ">=0.0.1"
-      }
-    },
-    "node_modules/blessed-contrib/node_modules/ansi-regex": {
-      "version": "2.1.1",
-      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-2.1.1.tgz",
-      "integrity": "sha512-TIGnTpdo+E3+pCyAluZvtED5p5wCqLdezCyhPZzKPcxvFplEt4i+W7OONCKgeZFT3+y5NZZfOOS/Bdcanm1MYA==",
-      "license": "MIT",
+        "ms": "^2.1.3"
+      },
       "engines": {
-        "node": ">=0.10.0"
+        "node": ">=6.0"
+      },
+      "peerDependenciesMeta": {
+        "supports-color": {
+          "optional": true
+        }
       }
     },
-    "node_modules/blessed-contrib/node_modules/ansi-styles": {
-      "version": "2.2.1",
-      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-2.2.1.tgz",
-      "integrity": "sha512-kmCevFghRiWM7HB5zTPULl4r9bVFSWjz62MhqizDGUrq2NWuNMQyuv4tHHoKJHs69M/MF64lEcHdYIocrdWQYA==",
-      "license": "MIT",
+    "node_modules/diff": {
+      "version": "4.0.4",
+      "resolved": "https://registry.npmjs.org/diff/-/diff-4.0.4.tgz",
+      "integrity": "sha512-X07nttJQkwkfKfvTPG/KSnE2OMdcUCao6+eXF3wmnIQRn2aPAHH3VxDbDOdegkd6JbPsXqShpvEOHfAT+nCNwQ==",
+      "dev": true,
+      "license": "BSD-3-Clause",
       "engines": {
-        "node": ">=0.10.0"
+        "node": ">=0.3.1"
       }
     },
-    "node_modules/blessed-contrib/node_modules/chalk": {
-      "version": "1.1.3",
-      "resolved": "https://registry.npmjs.org/chalk/-/chalk-1.1.3.tgz",
-      "integrity": "sha512-U3lRVLMSlsCfjqYPbLyVv11M9CPW4I728d6TCKMAOJueEeB9/8o+eSsMnxPJD+Q+K909sdESg7C+tIkoH6on1A==",
+    "node_modules/enquirer": {
+      "version": "2.4.1",
+      "resolved": "https://registry.npmjs.org/enquirer/-/enquirer-2.4.1.tgz",
+      "integrity": "sha512-rRqJg/6gd538VHvR3PSrdRBb/1Vy2YfzHqzvbhGIQpDRKIa4FgV/54b5Q1xYSxOOwKvjXweS26E0Q+nAMwp2pQ==",
       "license": "MIT",
       "dependencies": {
-        "ansi-styles": "^2.2.1",
-        "escape-string-regexp": "^1.0.2",
-        "has-ansi": "^2.0.0",
-        "strip-ansi": "^3.0.0",
-        "supports-color": "^2.0.0"
+        "ansi-colors": "^4.1.1",
+        "strip-ansi": "^6.0.1"
       },
       "engines": {
-        "node": ">=0.10.0"
+        "node": ">=8.6"
       }
     },
-    "node_modules/blessed-contrib/node_modules/escape-string-regexp": {
-      "version": "1.0.5",
-      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz",
-      "integrity": "sha512-vbRorB5FUQWvla16U8R/qgaFIya2qGzwDrNmCZuYKrbdSUMG6I1ZCGQRefkRVhuOkIGVne7BQ35DSfo1qvJqFg==",
-      "license": "MIT",
-      "engines": {
-        "node": ">=0.8.0"
-      }
+    "node_modules/graceful-fs": {
+      "version": "4.2.11",
+      "resolved": "https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.2.11.tgz",
+      "integrity": "sha512-RbJ5/jmFcNNCcDV5o9eTnBLJ/HszWV0P73bc+Ff4nS/rJj+YaS6IGyiOL0VoBYX+l1Wrl3k63h/KrH+nhJ0XvQ==",
+      "license": "ISC"
     },
-    "node_modules/blessed-contrib/node_modules/strip-ansi": {
-      "version": "3.0.1",
-      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-3.0.1.tgz",
-      "integrity": "sha512-VhumSSbBqDTP8p2ZLKj40UjBCV4+v8bUSEpUb4KjRgWk9pbqGF4REFj6KEagidb2f/M6AzC0EmFyDNGaw9OCzg==",
+    "node_modules/https-proxy-agent": {
+      "version": "7.0.6",
+      "resolved": "https://registry.npmjs.org/https-proxy-agent/-/https-proxy-agent-7.0.6.tgz",
+      "integrity": "sha512-vK9P5/iUfdl95AI+JVyUuIcVtd4ofvtrOr3HNtM2yxC9bnMbEdp3x01OhQNnjb8IJYi38VlTE3mBXwcfvywuSw==",
       "license": "MIT",
       "dependencies": {
-        "ansi-regex": "^2.0.0"
+        "agent-base": "^7.1.2",
+        "debug": "4"
       },
       "engines": {
-        "node": ">=0.10.0"
+        "node": ">= 14"
       }
     },
-    "node_modules/blessed-contrib/node_modules/supports-color": {
-      "version": "2.0.0",
-      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-2.0.0.tgz",
-      "integrity": "sha512-KKNVtd6pCYgPIKU4cp2733HWYCpplQhddZLBUryaAHou723x+FRzQ5Df824Fj+IyyuiQTRoub4SnIFfIcrp70g==",
+    "node_modules/ip-address": {
+      "version": "10.1.0",
+      "resolved": "https://registry.npmjs.org/ip-address/-/ip-address-10.1.0.tgz",
+      "integrity": "sha512-XXADHxXmvT9+CRxhXg56LJovE+bmWnEWB78LB83VZTprKTmaC5QfruXocxzTZ2Kl0DNwKuBdlIhjL8LeY8Sf8Q==",
       "license": "MIT",
       "engines": {
-        "node": ">=0.8.0"
+        "node": ">= 12"
       }
     },
-    "node_modules/body-parser": {
-      "version": "2.2.2",
-      "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-2.2.2.tgz",
-      "integrity": "sha512-oP5VkATKlNwcgvxi0vM0p/D3n2C3EReYVX+DNYs5TjZFn/oQt2j+4sVJtSMr18pdRr8wjTcBl6LoV+FUwzPmNA==",
+    "node_modules/make-error": {
+      "version": "1.3.6",
+      "resolved": "https://registry.npmjs.org/make-error/-/make-error-1.3.6.tgz",
+      "integrity": "sha512-s8UhlNe7vPKomQhC1qFelMokr/Sc3AgNbso3n74mVPA5LTZwkB9NlXf4XPamLxJE8h0gh73rM94xvwRT2CVInw==",
+      "dev": true,
+      "license": "ISC"
+    },
+    "node_modules/ms": {
+      "version": "2.1.3",
+      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
+      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
+      "license": "MIT"
+    },
+    "node_modules/proper-lockfile": {
+      "version": "4.1.2",
+      "resolved": "https://registry.npmjs.org/proper-lockfile/-/proper-lockfile-4.1.2.tgz",
+      "integrity": "sha512-TjNPblN4BwAWMXU8s9AEz4JmQxnD1NNL7bNOY/AKUzyamc379FWASUhc/K1pL2noVb+XmZKLL68cjzLsiOAMaA==",
       "license": "MIT",
       "dependencies": {
-        "bytes": "^3.1.2",
-        "content-type": "^1.0.5",
-        "debug": "^4.4.3",
-        "http-errors": "^2.0.0",
-        "iconv-lite": "^0.7.0",
-        "on-finished": "^2.4.1",
-        "qs": "^6.14.1",
-        "raw-body": "^3.0.1",
-        "type-is": "^2.0.1"
-      },
-      "engines": {
-        "node": ">=18"
-      },
-      "funding": {
-        "type": "opencollective",
-        "url": "https://opencollective.com/express"
+        "graceful-fs": "^4.2.4",
+        "retry": "^0.12.0",
+        "signal-exit": "^3.0.2"
       }
     },
-    "node_modules/brace-expansion": {
-      "version": "2.0.2",
-      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.2.tgz",
-      "integrity": "sha512-Jt0vHyM+jmUBqojB7E1NIYadt0vI0Qxjxd2TErW94wDz+E2LAm5vKMXXwg6ZZBTHPuUlDgQHKXvjGBdfcF1ZDQ==",
-      "dev": true,
+    "node_modules/retry": {
+      "version": "0.12.0",
+      "resolved": "https://registry.npmjs.org/retry/-/retry-0.12.0.tgz",
+      "integrity": "sha512-9LkiTwjUh6rT555DtE9rTX+BKByPfrMzEAtnlEtdEwr3Nkffwiihqe2bWADg+OQRjt9gl6ICdmB/ZFDCGAtSow==",
       "license": "MIT",
-      "dependencies": {
-        "balanced-match": "^1.0.0"
+      "engines": {
+        "node": ">= 4"
       }
     },
-    "node_modules/bresenham": {
-      "version": "0.0.3",
-      "resolved": "https://registry.npmjs.org/bresenham/-/bresenham-0.0.3.tgz",
-      "integrity": "sha512-wbMxoJJM1p3+6G7xEFXYNCJ30h2qkwmVxebkbwIl4OcnWtno5R3UT9VuYLfStlVNAQCmRjkGwjPFdfaPd4iNXw==",
-      "license": "MIT"
-    },
-    "node_modules/browser-stdout": {
-      "version": "1.3.1",
-      "resolved": "https://registry.npmjs.org/browser-stdout/-/browser-stdout-1.3.1.tgz",
-      "integrity": "sha512-qhAVI1+Av2X7qelOfAIYwXONood6XlZE/fXaBSmW/T5SzLAmCgzi+eiWE7fUvbHaeNBQH13UftjpXxsfLkMpgw==",
-      "dev": true,
+    "node_modules/signal-exit": {
+      "version": "3.0.7",
+      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-3.0.7.tgz",
+      "integrity": "sha512-wnD2ZE+l+SPC/uoS0vXeE9L1+0wuaMqKlfz9AMUo38JsyLSBWSFcHR1Rri62LZc12vLr1gb3jl7iwQhgwpAbGQ==",
       "license": "ISC"
     },
-    "node_modules/buffers": {
-      "version": "0.1.1",
-      "resolved": "https://registry.npmjs.org/buffers/-/buffers-0.1.1.tgz",
-      "integrity": "sha512-9q/rDEGSb/Qsvv2qvzIzdluL5k7AaJOTrw23z9reQthrbF7is4CtlT0DXyO1oei2DCp4uojjzQ7igaSHp1kAEQ==",
+    "node_modules/smart-buffer": {
+      "version": "4.2.0",
+      "resolved": "https://registry.npmjs.org/smart-buffer/-/smart-buffer-4.2.0.tgz",
+      "integrity": "sha512-94hK0Hh8rPqQl2xXc3HsaBoOXKV20MToPkcXvwbISWLEs+64sBq5kFgn2kJDHb1Pry9yrP0dxrCI9RRci7RXKg==",
+      "license": "MIT",
       "engines": {
-        "node": ">=0.2.0"
+        "node": ">= 6.0.0",
+        "npm": ">= 3.0.0"
       }
     },
-    "node_modules/bytes": {
-      "version": "3.1.2",
-      "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz",
-      "integrity": "sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==",
+    "node_modules/socks": {
+      "version": "2.8.7",
+      "resolved": "https://registry.npmjs.org/socks/-/socks-2.8.7.tgz",
+      "integrity": "sha512-HLpt+uLy/pxB+bum/9DzAgiKS8CX1EvbWxI4zlmgGCExImLdiad2iCwXT5Z4c9c3Eq8rP2318mPW2c+QbtjK8A==",
       "license": "MIT",
+      "dependencies": {
+        "ip-address": "^10.0.1",
+        "smart-buffer": "^4.2.0"
+      },
       "engines": {
-        "node": ">= 0.8"
+        "node": ">= 10.0.0",
+        "npm": ">= 3.0.0"
       }
     },
-    "node_modules/call-bind-apply-helpers": {
-      "version": "1.0.2",
-      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
-      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
+    "node_modules/socks-proxy-agent": {
+      "version": "8.0.5",
+      "resolved": "https://registry.npmjs.org/socks-proxy-agent/-/socks-proxy-agent-8.0.5.tgz",
+      "integrity": "sha512-HehCEsotFqbPW9sJ8WVYB6UbmIMv7kUUORIF2Nncq4VQvBfNBLibW9YZR5dlYCSUhwcD628pRllm7n+E+YTzJw==",
       "license": "MIT",
       "dependencies": {
-        "es-errors": "^1.3.0",
-        "function-bind": "^1.1.2"
+        "agent-base": "^7.1.2",
+        "debug": "^4.3.4",
+        "socks": "^2.8.3"
       },
       "engines": {
-        "node": ">= 0.4"
+        "node": ">= 14"
       }
     },
-    "node_modules/call-bound": {
-      "version": "1.0.4",
-      "resolved": "https://registry.npmjs.org/call-bound/-/call-bound-1.0.4.tgz",
-      "integrity": "sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==",
+    "node_modules/strip-ansi": {
+      "version": "6.0.1",
+      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
+      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
       "license": "MIT",
       "dependencies": {
-        "call-bind-apply-helpers": "^1.0.2",
-        "get-intrinsic": "^1.3.0"
+        "ansi-regex": "^5.0.1"
       },
       "engines": {
-        "node": ">= 0.4"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/ljharb"
+        "node": ">=8"
       }
     },
-    "node_modules/camelcase": {
-      "version": "6.3.0",
-      "resolved": "https://registry.npmjs.org/camelcase/-/camelcase-6.3.0.tgz",
-      "integrity": "sha512-Gmy6FhYlCY7uOElZUSbxo2UCDH8owEk996gkbrpsgGtrJLM3J7jGxl9Ic7Qwwj4ivOE5AWZWRMecDdF7hqGjFA==",
-      "dev": true,
-      "license": "MIT",
-      "engines": {
-        "node": ">=10"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/sindresorhus"
-      }
-    },
-    "node_modules/cardinal": {
-      "version": "2.1.1",
-      "resolved": "https://registry.npmjs.org/cardinal/-/cardinal-2.1.1.tgz",
-      "integrity": "sha512-JSr5eOgoEymtYHBjNWyjrMqet9Am2miJhlfKNdqLp6zoeAh0KN5dRAcxlecj5mAJrmQomgiOBj35xHLrFjqBpw==",
-      "license": "MIT",
-      "dependencies": {
-        "ansicolors": "~0.3.2",
-        "redeyed": "~2.1.0"
-      },
-      "bin": {
-        "cdl": "bin/cdl.js"
-      }
-    },
-    "node_modules/chai": {
-      "version": "4.5.0",
-      "resolved": "https://registry.npmjs.org/chai/-/chai-4.5.0.tgz",
-      "integrity": "sha512-RITGBfijLkBddZvnn8jdqoTypxvqbOLYQkGGxXzeFjVHvudaPw0HNFD9x928/eUwYWd2dPCugVqspGALTZZQKw==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "assertion-error": "^1.1.0",
-        "check-error": "^1.0.3",
-        "deep-eql": "^4.1.3",
-        "get-func-name": "^2.0.2",
-        "loupe": "^2.3.6",
-        "pathval": "^1.1.1",
-        "type-detect": "^4.1.0"
-      },
-      "engines": {
-        "node": ">=4"
-      }
-    },
-    "node_modules/chalk": {
-      "version": "4.1.2",
-      "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz",
-      "integrity": "sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "ansi-styles": "^4.1.0",
-        "supports-color": "^7.1.0"
-      },
-      "engines": {
-        "node": ">=10"
-      },
-      "funding": {
-        "url": "https://github.com/chalk/chalk?sponsor=1"
-      }
-    },
-    "node_modules/chalk/node_modules/supports-color": {
-      "version": "7.2.0",
-      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
-      "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "has-flag": "^4.0.0"
-      },
-      "engines": {
-        "node": ">=8"
-      }
-    },
-    "node_modules/charm": {
-      "version": "0.1.2",
-      "resolved": "https://registry.npmjs.org/charm/-/charm-0.1.2.tgz",
-      "integrity": "sha512-syedaZ9cPe7r3hoQA9twWYKu5AIyCswN5+szkmPBe9ccdLrj4bYaCnLVPTLd2kgVRc7+zoX4tyPgRnFKCj5YjQ==",
-      "license": "MIT/X11"
-    },
-    "node_modules/check-error": {
-      "version": "1.0.3",
-      "resolved": "https://registry.npmjs.org/check-error/-/check-error-1.0.3.tgz",
-      "integrity": "sha512-iKEoDYaRmd1mxM90a2OEfWhjsjPpYPuQ+lMYsoxB126+t8fw7ySEO48nmDg5COTjxDI65/Y2OWpeEHk3ZOe8zg==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "get-func-name": "^2.0.2"
-      },
-      "engines": {
-        "node": "*"
-      }
-    },
-    "node_modules/chokidar": {
-      "version": "4.0.3",
-      "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-4.0.3.tgz",
-      "integrity": "sha512-Qgzu8kfBvo+cA4962jnP1KkS6Dop5NS6g7R5LFYJr4b8Ub94PPQXUksCw9PvXoeXPRRddRNC5C1JQUR2SMGtnA==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "readdirp": "^4.0.1"
-      },
-      "engines": {
-        "node": ">= 14.16.0"
-      },
-      "funding": {
-        "url": "https://paulmillr.com/funding/"
-      }
-    },
-    "node_modules/cli-table3": {
-      "version": "0.6.5",
-      "resolved": "https://registry.npmjs.org/cli-table3/-/cli-table3-0.6.5.tgz",
-      "integrity": "sha512-+W/5efTR7y5HRD7gACw9yQjqMVvEMLBHmboM/kPWam+H+Hmyrgjh6YncVKK122YZkXrLudzTuAukUw9FnMf7IQ==",
-      "license": "MIT",
-      "dependencies": {
-        "string-width": "^4.2.0"
-      },
-      "engines": {
-        "node": "10.* || >= 12.*"
-      },
-      "optionalDependencies": {
-        "@colors/colors": "1.5.0"
-      }
-    },
-    "node_modules/cli-table3/node_modules/emoji-regex": {
-      "version": "8.0.0",
-      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
-      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
-      "license": "MIT"
-    },
-    "node_modules/cli-table3/node_modules/string-width": {
-      "version": "4.2.3",
-      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
-      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
-      "license": "MIT",
-      "dependencies": {
-        "emoji-regex": "^8.0.0",
-        "is-fullwidth-code-point": "^3.0.0",
-        "strip-ansi": "^6.0.1"
-      },
-      "engines": {
-        "node": ">=8"
-      }
-    },
-    "node_modules/cliui": {
-      "version": "8.0.1",
-      "resolved": "https://registry.npmjs.org/cliui/-/cliui-8.0.1.tgz",
-      "integrity": "sha512-BSeNnyus75C4//NQ9gQt1/csTXyo/8Sb+afLAkzAptFuMsod9HFokGNudZpi/oQV73hnVK+sR+5PVRMd+Dr7YQ==",
-      "dev": true,
-      "license": "ISC",
-      "dependencies": {
-        "string-width": "^4.2.0",
-        "strip-ansi": "^6.0.1",
-        "wrap-ansi": "^7.0.0"
-      },
-      "engines": {
-        "node": ">=12"
-      }
-    },
-    "node_modules/cliui/node_modules/emoji-regex": {
-      "version": "8.0.0",
-      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
-      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
-      "dev": true,
-      "license": "MIT"
-    },
-    "node_modules/cliui/node_modules/string-width": {
-      "version": "4.2.3",
-      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
-      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "emoji-regex": "^8.0.0",
-        "is-fullwidth-code-point": "^3.0.0",
-        "strip-ansi": "^6.0.1"
-      },
-      "engines": {
-        "node": ">=8"
-      }
-    },
-    "node_modules/cliui/node_modules/wrap-ansi": {
-      "version": "7.0.0",
-      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
-      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "ansi-styles": "^4.0.0",
-        "string-width": "^4.1.0",
-        "strip-ansi": "^6.0.0"
-      },
-      "engines": {
-        "node": ">=10"
-      },
-      "funding": {
-        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
-      }
-    },
-    "node_modules/color-convert": {
-      "version": "2.0.1",
-      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
-      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "color-name": "~1.1.4"
-      },
-      "engines": {
-        "node": ">=7.0.0"
-      }
-    },
-    "node_modules/color-name": {
-      "version": "1.1.4",
-      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
-      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
-      "dev": true,
-      "license": "MIT"
-    },
-    "node_modules/commander": {
-      "version": "14.0.2",
-      "resolved": "https://registry.npmjs.org/commander/-/commander-14.0.2.tgz",
-      "integrity": "sha512-TywoWNNRbhoD0BXs1P3ZEScW8W5iKrnbithIl0YH+uCmBd0QpPOA8yc82DS3BIE5Ma6FnBVUsJ7wVUDz4dvOWQ==",
-      "license": "MIT",
-      "engines": {
-        "node": ">=20"
-      }
-    },
-    "node_modules/content-disposition": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/content-disposition/-/content-disposition-1.0.1.tgz",
-      "integrity": "sha512-oIXISMynqSqm241k6kcQ5UwttDILMK4BiurCfGEREw6+X9jkkpEe5T9FZaApyLGGOnFuyMWZpdolTXMtvEJ08Q==",
-      "license": "MIT",
-      "engines": {
-        "node": ">=18"
-      },
-      "funding": {
-        "type": "opencollective",
-        "url": "https://opencollective.com/express"
-      }
-    },
-    "node_modules/content-type": {
-      "version": "1.0.5",
-      "resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.5.tgz",
-      "integrity": "sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 0.6"
-      }
-    },
-    "node_modules/cookie": {
-      "version": "0.7.2",
-      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.7.2.tgz",
-      "integrity": "sha512-yki5XnKuf750l50uGTllt6kKILY4nQ1eNIQatoXEByZ5dWgnKqbnqmTrBE5B4N7lrMJKQ2ytWMiTO2o0v6Ew/w==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 0.6"
-      }
-    },
-    "node_modules/cookie-signature": {
-      "version": "1.2.2",
-      "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.2.2.tgz",
-      "integrity": "sha512-D76uU73ulSXrD1UXF4KE2TMxVVwhsnCgfAyTg9k8P6KGZjlXKrOLe4dJQKI3Bxi5wjesZoFXJWElNWBjPZMbhg==",
-      "license": "MIT",
-      "engines": {
-        "node": ">=6.6.0"
-      }
-    },
-    "node_modules/core-util-is": {
-      "version": "1.0.3",
-      "resolved": "https://registry.npmjs.org/core-util-is/-/core-util-is-1.0.3.tgz",
-      "integrity": "sha512-ZQBvi1DcpJ4GDqanjucZ2Hj3wEO5pZDS89BWbkcrvdxksJorwUDDZamX9ldFkp9aw2lmBDLgkObEA4DWNJ9FYQ==",
-      "license": "MIT"
-    },
-    "node_modules/create-require": {
-      "version": "1.1.1",
-      "resolved": "https://registry.npmjs.org/create-require/-/create-require-1.1.1.tgz",
-      "integrity": "sha512-dcKFX3jn0MpIaXjisoRvexIJVEKzaq7z2rZKxf+MSr9TkdmHmsU4m2lcLojrj/FHl8mk5VxMmYA+ftRkP/3oKQ==",
-      "dev": true,
-      "license": "MIT"
-    },
-    "node_modules/cross-spawn": {
-      "version": "7.0.6",
-      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.6.tgz",
-      "integrity": "sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "path-key": "^3.1.0",
-        "shebang-command": "^2.0.0",
-        "which": "^2.0.1"
-      },
-      "engines": {
-        "node": ">= 8"
-      }
-    },
-    "node_modules/debug": {
-      "version": "4.4.3",
-      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
-      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
-      "license": "MIT",
-      "dependencies": {
-        "ms": "^2.1.3"
-      },
-      "engines": {
-        "node": ">=6.0"
-      },
-      "peerDependenciesMeta": {
-        "supports-color": {
-          "optional": true
-        }
-      }
-    },
-    "node_modules/decamelize": {
-      "version": "4.0.0",
-      "resolved": "https://registry.npmjs.org/decamelize/-/decamelize-4.0.0.tgz",
-      "integrity": "sha512-9iE1PgSik9HeIIw2JO94IidnE3eBoQrFJ3w7sFuzSX4DpmZ3v5sZpUiV5Swcf6mQEF+Y0ru8Neo+p+nyh2J+hQ==",
-      "dev": true,
-      "license": "MIT",
-      "engines": {
-        "node": ">=10"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/sindresorhus"
-      }
-    },
-    "node_modules/deep-eql": {
-      "version": "4.1.4",
-      "resolved": "https://registry.npmjs.org/deep-eql/-/deep-eql-4.1.4.tgz",
-      "integrity": "sha512-SUwdGfqdKOwxCPeVYjwSyRpJ7Z+fhpwIAtmCUdZIWZ/YP5R9WAsyuSgpLVDi9bjWoN2LXHNss/dk3urXtdQxGg==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "type-detect": "^4.0.0"
-      },
-      "engines": {
-        "node": ">=6"
-      }
-    },
-    "node_modules/depd": {
-      "version": "2.0.0",
-      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
-      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 0.8"
-      }
-    },
-    "node_modules/diff": {
-      "version": "4.0.4",
-      "resolved": "https://registry.npmjs.org/diff/-/diff-4.0.4.tgz",
-      "integrity": "sha512-X07nttJQkwkfKfvTPG/KSnE2OMdcUCao6+eXF3wmnIQRn2aPAHH3VxDbDOdegkd6JbPsXqShpvEOHfAT+nCNwQ==",
-      "dev": true,
-      "license": "BSD-3-Clause",
-      "engines": {
-        "node": ">=0.3.1"
-      }
-    },
-    "node_modules/drawille-blessed-contrib": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/drawille-blessed-contrib/-/drawille-blessed-contrib-1.0.0.tgz",
-      "integrity": "sha512-WnHMgf5en/hVOsFhxLI8ZX0qTJmerOsVjIMQmn4cR1eI8nLGu+L7w5ENbul+lZ6w827A3JakCuernES5xbHLzQ==",
-      "license": "MIT"
-    },
-    "node_modules/drawille-canvas-blessed-contrib": {
-      "version": "0.1.3",
-      "resolved": "https://registry.npmjs.org/drawille-canvas-blessed-contrib/-/drawille-canvas-blessed-contrib-0.1.3.tgz",
-      "integrity": "sha512-bdDvVJOxlrEoPLifGDPaxIzFh3cD7QH05ePoQ4fwnqfi08ZSxzEhOUpI5Z0/SQMlWgcCQOEtuw0zrwezacXglw==",
-      "license": "MIT",
-      "dependencies": {
-        "ansi-term": ">=0.0.2",
-        "bresenham": "0.0.3",
-        "drawille-blessed-contrib": ">=0.0.1",
-        "gl-matrix": "^2.1.0",
-        "x256": ">=0.0.1"
-      }
-    },
-    "node_modules/dunder-proto": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
-      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
-      "license": "MIT",
-      "dependencies": {
-        "call-bind-apply-helpers": "^1.0.1",
-        "es-errors": "^1.3.0",
-        "gopd": "^1.2.0"
-      },
-      "engines": {
-        "node": ">= 0.4"
-      }
-    },
-    "node_modules/eastasianwidth": {
-      "version": "0.2.0",
-      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
-      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
-      "dev": true,
-      "license": "MIT"
-    },
-    "node_modules/ee-first": {
-      "version": "1.1.1",
-      "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
-      "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==",
-      "license": "MIT"
-    },
-    "node_modules/emoji-regex": {
-      "version": "9.2.2",
-      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
-      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
-      "dev": true,
-      "license": "MIT"
-    },
-    "node_modules/encodeurl": {
-      "version": "2.0.0",
-      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
-      "integrity": "sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 0.8"
-      }
-    },
-    "node_modules/enquirer": {
-      "version": "2.4.1",
-      "resolved": "https://registry.npmjs.org/enquirer/-/enquirer-2.4.1.tgz",
-      "integrity": "sha512-rRqJg/6gd538VHvR3PSrdRBb/1Vy2YfzHqzvbhGIQpDRKIa4FgV/54b5Q1xYSxOOwKvjXweS26E0Q+nAMwp2pQ==",
-      "license": "MIT",
-      "dependencies": {
-        "ansi-colors": "^4.1.1",
-        "strip-ansi": "^6.0.1"
-      },
-      "engines": {
-        "node": ">=8.6"
-      }
-    },
-    "node_modules/es-define-property": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
-      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 0.4"
-      }
-    },
-    "node_modules/es-errors": {
-      "version": "1.3.0",
-      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
-      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 0.4"
-      }
-    },
-    "node_modules/es-object-atoms": {
-      "version": "1.1.1",
-      "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
-      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
-      "license": "MIT",
-      "dependencies": {
-        "es-errors": "^1.3.0"
-      },
-      "engines": {
-        "node": ">= 0.4"
-      }
-    },
-    "node_modules/escalade": {
-      "version": "3.2.0",
-      "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.2.0.tgz",
-      "integrity": "sha512-WUj2qlxaQtO4g6Pq5c29GTcWGDyd8itL8zTlipgECz3JesAiiOKotd8JU6otB3PACgG6xkJUyVhboMS+bje/jA==",
-      "dev": true,
-      "license": "MIT",
-      "engines": {
-        "node": ">=6"
-      }
-    },
-    "node_modules/escape-html": {
-      "version": "1.0.3",
-      "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
-      "integrity": "sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==",
-      "license": "MIT"
-    },
-    "node_modules/escape-string-regexp": {
-      "version": "4.0.0",
-      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
-      "integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==",
-      "dev": true,
-      "license": "MIT",
-      "engines": {
-        "node": ">=10"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/sindresorhus"
-      }
-    },
-    "node_modules/esprima": {
-      "version": "4.0.1",
-      "resolved": "https://registry.npmjs.org/esprima/-/esprima-4.0.1.tgz",
-      "integrity": "sha512-eGuFFw7Upda+g4p+QHvnW0RyTX/SVeJBDM/gCtMARO0cLuT2HcEKnTPvhjV6aGeqrCB/sbNop0Kszm0jsaWU4A==",
-      "license": "BSD-2-Clause",
-      "bin": {
-        "esparse": "bin/esparse.js",
-        "esvalidate": "bin/esvalidate.js"
-      },
-      "engines": {
-        "node": ">=4"
-      }
-    },
-    "node_modules/etag": {
-      "version": "1.8.1",
-      "resolved": "https://registry.npmjs.org/etag/-/etag-1.8.1.tgz",
-      "integrity": "sha512-aIL5Fx7mawVa300al2BnEE4iNvo1qETxLrPI/o05L7z6go7fCw1J6EQmbK4FmJ2AS7kgVF/KEZWufBfdClMcPg==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 0.6"
-      }
-    },
-    "node_modules/event-stream": {
-      "version": "0.9.8",
-      "resolved": "https://registry.npmjs.org/event-stream/-/event-stream-0.9.8.tgz",
-      "integrity": "sha512-o5h0Mp1bkoR6B0i7pTCAzRy+VzdsRWH997KQD4Psb0EOPoKEIiaRx/EsOdUl7p1Ktjw7aIWvweI/OY1R9XrlUg==",
-      "dependencies": {
-        "optimist": "0.2"
-      },
-      "engines": {
-        "node": "*"
-      }
-    },
-    "node_modules/event-stream/node_modules/optimist": {
-      "version": "0.2.8",
-      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.2.8.tgz",
-      "integrity": "sha512-Wy7E3cQDpqsTIFyW7m22hSevyTLxw850ahYv7FWsw4G6MIKVTZ8NSA95KBrQ95a4SMsMr1UGUUnwEFKhVaSzIg==",
-      "license": "MIT/X11",
-      "dependencies": {
-        "wordwrap": ">=0.0.1 <0.1.0"
-      },
-      "engines": {
-        "node": "*"
-      }
-    },
-    "node_modules/express": {
-      "version": "5.2.1",
-      "resolved": "https://registry.npmjs.org/express/-/express-5.2.1.tgz",
-      "integrity": "sha512-hIS4idWWai69NezIdRt2xFVofaF4j+6INOpJlVOLDO8zXGpUVEVzIYk12UUi2JzjEzWL3IOAxcTubgz9Po0yXw==",
-      "license": "MIT",
-      "dependencies": {
-        "accepts": "^2.0.0",
-        "body-parser": "^2.2.1",
-        "content-disposition": "^1.0.0",
-        "content-type": "^1.0.5",
-        "cookie": "^0.7.1",
-        "cookie-signature": "^1.2.1",
-        "debug": "^4.4.0",
-        "depd": "^2.0.0",
-        "encodeurl": "^2.0.0",
-        "escape-html": "^1.0.3",
-        "etag": "^1.8.1",
-        "finalhandler": "^2.1.0",
-        "fresh": "^2.0.0",
-        "http-errors": "^2.0.0",
-        "merge-descriptors": "^2.0.0",
-        "mime-types": "^3.0.0",
-        "on-finished": "^2.4.1",
-        "once": "^1.4.0",
-        "parseurl": "^1.3.3",
-        "proxy-addr": "^2.0.7",
-        "qs": "^6.14.0",
-        "range-parser": "^1.2.1",
-        "router": "^2.2.0",
-        "send": "^1.1.0",
-        "serve-static": "^2.2.0",
-        "statuses": "^2.0.1",
-        "type-is": "^2.0.1",
-        "vary": "^1.1.2"
-      },
-      "engines": {
-        "node": ">= 18"
-      },
-      "funding": {
-        "type": "opencollective",
-        "url": "https://opencollective.com/express"
-      }
-    },
-    "node_modules/finalhandler": {
-      "version": "2.1.1",
-      "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-2.1.1.tgz",
-      "integrity": "sha512-S8KoZgRZN+a5rNwqTxlZZePjT/4cnm0ROV70LedRHZ0p8u9fRID0hJUZQpkKLzro8LfmC8sx23bY6tVNxv8pQA==",
-      "license": "MIT",
-      "dependencies": {
-        "debug": "^4.4.0",
-        "encodeurl": "^2.0.0",
-        "escape-html": "^1.0.3",
-        "on-finished": "^2.4.1",
-        "parseurl": "^1.3.3",
-        "statuses": "^2.0.1"
-      },
-      "engines": {
-        "node": ">= 18.0.0"
-      },
-      "funding": {
-        "type": "opencollective",
-        "url": "https://opencollective.com/express"
-      }
-    },
-    "node_modules/find-up": {
-      "version": "5.0.0",
-      "resolved": "https://registry.npmjs.org/find-up/-/find-up-5.0.0.tgz",
-      "integrity": "sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "locate-path": "^6.0.0",
-        "path-exists": "^4.0.0"
-      },
-      "engines": {
-        "node": ">=10"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/sindresorhus"
-      }
-    },
-    "node_modules/flat": {
-      "version": "5.0.2",
-      "resolved": "https://registry.npmjs.org/flat/-/flat-5.0.2.tgz",
-      "integrity": "sha512-b6suED+5/3rTpUBdG1gupIl8MPFCAMA0QXwmljLhvCUKcUvdE4gWky9zpuGCcXHOsz4J9wPGNWq6OKpmIzz3hQ==",
-      "dev": true,
-      "license": "BSD-3-Clause",
-      "bin": {
-        "flat": "cli.js"
-      }
-    },
-    "node_modules/foreground-child": {
-      "version": "3.3.1",
-      "resolved": "https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.1.tgz",
-      "integrity": "sha512-gIXjKqtFuWEgzFRJA9WCQeSJLZDjgJUOMCMzxtvFq/37KojM1BFGufqsCy0r4qSQmYLsZYMeyRqzIWOMup03sw==",
-      "dev": true,
-      "license": "ISC",
-      "dependencies": {
-        "cross-spawn": "^7.0.6",
-        "signal-exit": "^4.0.1"
-      },
-      "engines": {
-        "node": ">=14"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/isaacs"
-      }
-    },
-    "node_modules/foreground-child/node_modules/signal-exit": {
-      "version": "4.1.0",
-      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
-      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
-      "dev": true,
-      "license": "ISC",
-      "engines": {
-        "node": ">=14"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/isaacs"
-      }
-    },
-    "node_modules/forwarded": {
-      "version": "0.2.0",
-      "resolved": "https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz",
-      "integrity": "sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 0.6"
-      }
-    },
-    "node_modules/fresh": {
-      "version": "2.0.0",
-      "resolved": "https://registry.npmjs.org/fresh/-/fresh-2.0.0.tgz",
-      "integrity": "sha512-Rx/WycZ60HOaqLKAi6cHRKKI7zxWbJ31MhntmtwMoaTeF7XFH9hhBp8vITaMidfljRQ6eYWCKkaTK+ykVJHP2A==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 0.8"
-      }
-    },
-    "node_modules/function-bind": {
-      "version": "1.1.2",
-      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
-      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
-      "license": "MIT",
-      "funding": {
-        "url": "https://github.com/sponsors/ljharb"
-      }
-    },
-    "node_modules/get-caller-file": {
-      "version": "2.0.5",
-      "resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-2.0.5.tgz",
-      "integrity": "sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==",
-      "dev": true,
-      "license": "ISC",
-      "engines": {
-        "node": "6.* || 8.* || >= 10.*"
-      }
-    },
-    "node_modules/get-func-name": {
-      "version": "2.0.2",
-      "resolved": "https://registry.npmjs.org/get-func-name/-/get-func-name-2.0.2.tgz",
-      "integrity": "sha512-8vXOvuE167CtIc3OyItco7N/dpRtBbYOsPsXCz7X/PMnlGjYjSGuZJgM1Y7mmew7BKf9BqvLX2tnOVy1BBUsxQ==",
-      "dev": true,
-      "license": "MIT",
-      "engines": {
-        "node": "*"
-      }
-    },
-    "node_modules/get-intrinsic": {
-      "version": "1.3.0",
-      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
-      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
-      "license": "MIT",
-      "dependencies": {
-        "call-bind-apply-helpers": "^1.0.2",
-        "es-define-property": "^1.0.1",
-        "es-errors": "^1.3.0",
-        "es-object-atoms": "^1.1.1",
-        "function-bind": "^1.1.2",
-        "get-proto": "^1.0.1",
-        "gopd": "^1.2.0",
-        "has-symbols": "^1.1.0",
-        "hasown": "^2.0.2",
-        "math-intrinsics": "^1.1.0"
-      },
-      "engines": {
-        "node": ">= 0.4"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/ljharb"
-      }
-    },
-    "node_modules/get-proto": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
-      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
-      "license": "MIT",
-      "dependencies": {
-        "dunder-proto": "^1.0.1",
-        "es-object-atoms": "^1.0.0"
-      },
-      "engines": {
-        "node": ">= 0.4"
-      }
-    },
-    "node_modules/gl-matrix": {
-      "version": "2.8.1",
-      "resolved": "https://registry.npmjs.org/gl-matrix/-/gl-matrix-2.8.1.tgz",
-      "integrity": "sha512-0YCjVpE3pS5XWlN3J4X7AiAx65+nqAI54LndtVFnQZB6G/FVLkZH8y8V6R3cIoOQR4pUdfwQGd1iwyoXHJ4Qfw==",
-      "license": "MIT"
-    },
-    "node_modules/glob": {
-      "version": "10.5.0",
-      "resolved": "https://registry.npmjs.org/glob/-/glob-10.5.0.tgz",
-      "integrity": "sha512-DfXN8DfhJ7NH3Oe7cFmu3NCu1wKbkReJ8TorzSAFbSKrlNaQSKfIzqYqVY8zlbs2NLBbWpRiU52GX2PbaBVNkg==",
-      "dev": true,
-      "license": "ISC",
-      "dependencies": {
-        "foreground-child": "^3.1.0",
-        "jackspeak": "^3.1.2",
-        "minimatch": "^9.0.4",
-        "minipass": "^7.1.2",
-        "package-json-from-dist": "^1.0.0",
-        "path-scurry": "^1.11.1"
-      },
-      "bin": {
-        "glob": "dist/esm/bin.mjs"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/isaacs"
-      }
-    },
-    "node_modules/gopd": {
-      "version": "1.2.0",
-      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
-      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 0.4"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/ljharb"
-      }
-    },
-    "node_modules/graceful-fs": {
-      "version": "4.2.11",
-      "resolved": "https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.2.11.tgz",
-      "integrity": "sha512-RbJ5/jmFcNNCcDV5o9eTnBLJ/HszWV0P73bc+Ff4nS/rJj+YaS6IGyiOL0VoBYX+l1Wrl3k63h/KrH+nhJ0XvQ==",
-      "license": "ISC"
-    },
-    "node_modules/has-ansi": {
-      "version": "2.0.0",
-      "resolved": "https://registry.npmjs.org/has-ansi/-/has-ansi-2.0.0.tgz",
-      "integrity": "sha512-C8vBJ8DwUCx19vhm7urhTuUsr4/IyP6l4VzNQDv+ryHQObW3TTTp9yB68WpYgRe2bbaGuZ/se74IqFeVnMnLZg==",
-      "license": "MIT",
-      "dependencies": {
-        "ansi-regex": "^2.0.0"
-      },
-      "engines": {
-        "node": ">=0.10.0"
-      }
-    },
-    "node_modules/has-ansi/node_modules/ansi-regex": {
-      "version": "2.1.1",
-      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-2.1.1.tgz",
-      "integrity": "sha512-TIGnTpdo+E3+pCyAluZvtED5p5wCqLdezCyhPZzKPcxvFplEt4i+W7OONCKgeZFT3+y5NZZfOOS/Bdcanm1MYA==",
-      "license": "MIT",
-      "engines": {
-        "node": ">=0.10.0"
-      }
-    },
-    "node_modules/has-flag": {
-      "version": "4.0.0",
-      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
-      "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
-      "license": "MIT",
-      "engines": {
-        "node": ">=8"
-      }
-    },
-    "node_modules/has-symbols": {
-      "version": "1.1.0",
-      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
-      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 0.4"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/ljharb"
-      }
-    },
-    "node_modules/hasown": {
-      "version": "2.0.2",
-      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
-      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
-      "license": "MIT",
-      "dependencies": {
-        "function-bind": "^1.1.2"
-      },
-      "engines": {
-        "node": ">= 0.4"
-      }
-    },
-    "node_modules/he": {
-      "version": "1.2.0",
-      "resolved": "https://registry.npmjs.org/he/-/he-1.2.0.tgz",
-      "integrity": "sha512-F/1DnUGPopORZi0ni+CvrCgHQ5FyEAHRLSApuYWMmrbSwoN2Mn/7k+Gl38gJnR7yyDZk6WLXwiGod1JOWNDKGw==",
-      "dev": true,
-      "license": "MIT",
-      "bin": {
-        "he": "bin/he"
-      }
-    },
-    "node_modules/here": {
-      "version": "0.0.2",
-      "resolved": "https://registry.npmjs.org/here/-/here-0.0.2.tgz",
-      "integrity": "sha512-U7VYImCTcPoY27TSmzoiFsmWLEqQFaYNdpsPb9K0dXJhE6kufUqycaz51oR09CW85dDU9iWyy7At8M+p7hb3NQ==",
-      "license": "MIT"
-    },
-    "node_modules/http-errors": {
-      "version": "2.0.1",
-      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.1.tgz",
-      "integrity": "sha512-4FbRdAX+bSdmo4AUFuS0WNiPz8NgFt+r8ThgNWmlrjQjt1Q7ZR9+zTlce2859x4KSXrwIsaeTqDoKQmtP8pLmQ==",
-      "license": "MIT",
-      "dependencies": {
-        "depd": "~2.0.0",
-        "inherits": "~2.0.4",
-        "setprototypeof": "~1.2.0",
-        "statuses": "~2.0.2",
-        "toidentifier": "~1.0.1"
-      },
-      "engines": {
-        "node": ">= 0.8"
-      },
-      "funding": {
-        "type": "opencollective",
-        "url": "https://opencollective.com/express"
-      }
-    },
-    "node_modules/https-proxy-agent": {
-      "version": "7.0.6",
-      "resolved": "https://registry.npmjs.org/https-proxy-agent/-/https-proxy-agent-7.0.6.tgz",
-      "integrity": "sha512-vK9P5/iUfdl95AI+JVyUuIcVtd4ofvtrOr3HNtM2yxC9bnMbEdp3x01OhQNnjb8IJYi38VlTE3mBXwcfvywuSw==",
-      "license": "MIT",
-      "dependencies": {
-        "agent-base": "^7.1.2",
-        "debug": "4"
-      },
-      "engines": {
-        "node": ">= 14"
-      }
-    },
-    "node_modules/iconv-lite": {
-      "version": "0.7.2",
-      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.7.2.tgz",
-      "integrity": "sha512-im9DjEDQ55s9fL4EYzOAv0yMqmMBSZp6G0VvFyTMPKWxiSBHUj9NW/qqLmXUwXrrM7AvqSlTCfvqRb0cM8yYqw==",
-      "license": "MIT",
-      "dependencies": {
-        "safer-buffer": ">= 2.1.2 < 3.0.0"
-      },
-      "engines": {
-        "node": ">=0.10.0"
-      },
-      "funding": {
-        "type": "opencollective",
-        "url": "https://opencollective.com/express"
-      }
-    },
-    "node_modules/inherits": {
-      "version": "2.0.4",
-      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
-      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
-      "license": "ISC"
-    },
-    "node_modules/ip-address": {
-      "version": "10.1.0",
-      "resolved": "https://registry.npmjs.org/ip-address/-/ip-address-10.1.0.tgz",
-      "integrity": "sha512-XXADHxXmvT9+CRxhXg56LJovE+bmWnEWB78LB83VZTprKTmaC5QfruXocxzTZ2Kl0DNwKuBdlIhjL8LeY8Sf8Q==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 12"
-      }
-    },
-    "node_modules/ipaddr.js": {
-      "version": "1.9.1",
-      "resolved": "https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz",
-      "integrity": "sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 0.10"
-      }
-    },
-    "node_modules/is-fullwidth-code-point": {
-      "version": "3.0.0",
-      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
-      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
-      "license": "MIT",
-      "engines": {
-        "node": ">=8"
-      }
-    },
-    "node_modules/is-path-inside": {
-      "version": "3.0.3",
-      "resolved": "https://registry.npmjs.org/is-path-inside/-/is-path-inside-3.0.3.tgz",
-      "integrity": "sha512-Fd4gABb+ycGAmKou8eMftCupSir5lRxqf4aD/vd0cD2qc4HL07OjCeuHMr8Ro4CoMaeCKDB0/ECBOVWjTwUvPQ==",
-      "dev": true,
-      "license": "MIT",
-      "engines": {
-        "node": ">=8"
-      }
-    },
-    "node_modules/is-plain-obj": {
-      "version": "2.1.0",
-      "resolved": "https://registry.npmjs.org/is-plain-obj/-/is-plain-obj-2.1.0.tgz",
-      "integrity": "sha512-YWnfyRwxL/+SsrWYfOpUtz5b3YD+nyfkHvjbcanzk8zgyO4ASD67uVMRt8k5bM4lLMDnXfriRhOpemw+NfT1eA==",
-      "dev": true,
-      "license": "MIT",
-      "engines": {
-        "node": ">=8"
-      }
-    },
-    "node_modules/is-promise": {
-      "version": "4.0.0",
-      "resolved": "https://registry.npmjs.org/is-promise/-/is-promise-4.0.0.tgz",
-      "integrity": "sha512-hvpoI6korhJMnej285dSg6nu1+e6uxs7zG3BYAm5byqDsgJNWwxzM6z6iZiAgQR4TJ30JmBTOwqZUw3WlyH3AQ==",
-      "license": "MIT"
-    },
-    "node_modules/is-unicode-supported": {
-      "version": "0.1.0",
-      "resolved": "https://registry.npmjs.org/is-unicode-supported/-/is-unicode-supported-0.1.0.tgz",
-      "integrity": "sha512-knxG2q4UC3u8stRGyAVJCOdxFmv5DZiRcdlIaAQXAbSfJya+OhopNotLQrstBhququ4ZpuKbDc/8S6mgXgPFPw==",
-      "dev": true,
-      "license": "MIT",
-      "engines": {
-        "node": ">=10"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/sindresorhus"
-      }
-    },
-    "node_modules/isarray": {
-      "version": "0.0.1",
-      "resolved": "https://registry.npmjs.org/isarray/-/isarray-0.0.1.tgz",
-      "integrity": "sha512-D2S+3GLxWH+uhrNEcoh/fnmYeP8E8/zHl644d/jdA0g2uyXvy3sb0qxotE+ne0LtccHknQzWwZEzhak7oJ0COQ==",
-      "license": "MIT"
-    },
-    "node_modules/isexe": {
-      "version": "2.0.0",
-      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
-      "integrity": "sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==",
-      "dev": true,
-      "license": "ISC"
-    },
-    "node_modules/jackspeak": {
-      "version": "3.4.3",
-      "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-3.4.3.tgz",
-      "integrity": "sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==",
-      "dev": true,
-      "license": "BlueOak-1.0.0",
-      "dependencies": {
-        "@isaacs/cliui": "^8.0.2"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/isaacs"
-      },
-      "optionalDependencies": {
-        "@pkgjs/parseargs": "^0.11.0"
-      }
-    },
-    "node_modules/js-yaml": {
-      "version": "4.1.1",
-      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.1.tgz",
-      "integrity": "sha512-qQKT4zQxXl8lLwBtHMWwaTcGfFOZviOJet3Oy/xmGk2gZH677CJM9EvtfdSkgWcATZhj/55JZ0rmy3myCT5lsA==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "argparse": "^2.0.1"
-      },
-      "bin": {
-        "js-yaml": "bin/js-yaml.js"
-      }
-    },
-    "node_modules/locate-path": {
-      "version": "6.0.0",
-      "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-6.0.0.tgz",
-      "integrity": "sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "p-locate": "^5.0.0"
-      },
-      "engines": {
-        "node": ">=10"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/sindresorhus"
-      }
-    },
-    "node_modules/lodash": {
-      "version": "4.17.23",
-      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.23.tgz",
-      "integrity": "sha512-LgVTMpQtIopCi79SJeDiP0TfWi5CNEc/L/aRdTh3yIvmZXTnheWpKjSZhnvMl8iXbC1tFg9gdHHDMLoV7CnG+w==",
-      "license": "MIT"
-    },
-    "node_modules/log-symbols": {
-      "version": "4.1.0",
-      "resolved": "https://registry.npmjs.org/log-symbols/-/log-symbols-4.1.0.tgz",
-      "integrity": "sha512-8XPvpAA8uyhfteu8pIvQxpJZ7SYYdpUivZpGy6sFsBuKRY/7rQGavedeB8aK+Zkyq6upMFVL/9AW6vOYzfRyLg==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "chalk": "^4.1.0",
-        "is-unicode-supported": "^0.1.0"
-      },
-      "engines": {
-        "node": ">=10"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/sindresorhus"
-      }
-    },
-    "node_modules/loupe": {
-      "version": "2.3.7",
-      "resolved": "https://registry.npmjs.org/loupe/-/loupe-2.3.7.tgz",
-      "integrity": "sha512-zSMINGVYkdpYSOBmLi0D1Uo7JU9nVdQKrHxC8eYlV+9YKK9WePqAlL7lSlorG/U2Fw1w0hTBmaa/jrQ3UbPHtA==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "get-func-name": "^2.0.1"
-      }
-    },
-    "node_modules/lru-cache": {
-      "version": "10.4.3",
-      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-10.4.3.tgz",
-      "integrity": "sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==",
-      "dev": true,
-      "license": "ISC"
-    },
-    "node_modules/make-error": {
-      "version": "1.3.6",
-      "resolved": "https://registry.npmjs.org/make-error/-/make-error-1.3.6.tgz",
-      "integrity": "sha512-s8UhlNe7vPKomQhC1qFelMokr/Sc3AgNbso3n74mVPA5LTZwkB9NlXf4XPamLxJE8h0gh73rM94xvwRT2CVInw==",
-      "dev": true,
-      "license": "ISC"
-    },
-    "node_modules/map-canvas": {
-      "version": "0.1.5",
-      "resolved": "https://registry.npmjs.org/map-canvas/-/map-canvas-0.1.5.tgz",
-      "integrity": "sha512-f7M3sOuL9+up0NCOZbb1rQpWDLZwR/ftCiNbyscjl9LUUEwrRaoumH4sz6swgs58lF21DQ0hsYOCw5C6Zz7hbg==",
-      "license": "ISC",
-      "dependencies": {
-        "drawille-canvas-blessed-contrib": ">=0.0.1",
-        "xml2js": "^0.4.5"
-      }
-    },
-    "node_modules/marked": {
-      "version": "4.3.0",
-      "resolved": "https://registry.npmjs.org/marked/-/marked-4.3.0.tgz",
-      "integrity": "sha512-PRsaiG84bK+AMvxziE/lCFss8juXjNaWzVbN5tXAm4XjeaS9NAHhop+PjQxz2A9h8Q4M/xGmzP8vqNwy6JeK0A==",
-      "license": "MIT",
-      "bin": {
-        "marked": "bin/marked.js"
-      },
-      "engines": {
-        "node": ">= 12"
-      }
-    },
-    "node_modules/marked-terminal": {
-      "version": "5.2.0",
-      "resolved": "https://registry.npmjs.org/marked-terminal/-/marked-terminal-5.2.0.tgz",
-      "integrity": "sha512-Piv6yNwAQXGFjZSaiNljyNFw7jKDdGrw70FSbtxEyldLsyeuV5ZHm/1wW++kWbrOF1VPnUgYOhB2oLL0ZpnekA==",
-      "license": "MIT",
-      "dependencies": {
-        "ansi-escapes": "^6.2.0",
-        "cardinal": "^2.1.1",
-        "chalk": "^5.2.0",
-        "cli-table3": "^0.6.3",
-        "node-emoji": "^1.11.0",
-        "supports-hyperlinks": "^2.3.0"
-      },
-      "engines": {
-        "node": ">=14.13.1 || >=16.0.0"
-      },
-      "peerDependencies": {
-        "marked": "^1.0.0 || ^2.0.0 || ^3.0.0 || ^4.0.0 || ^5.0.0"
-      }
-    },
-    "node_modules/marked-terminal/node_modules/chalk": {
-      "version": "5.6.2",
-      "resolved": "https://registry.npmjs.org/chalk/-/chalk-5.6.2.tgz",
-      "integrity": "sha512-7NzBL0rN6fMUW+f7A6Io4h40qQlG+xGmtMxfbnH/K7TAtt8JQWVQK+6g0UXKMeVJoyV5EkkNsErQ8pVD3bLHbA==",
-      "license": "MIT",
-      "engines": {
-        "node": "^12.17.0 || ^14.13 || >=16.0.0"
-      },
-      "funding": {
-        "url": "https://github.com/chalk/chalk?sponsor=1"
-      }
-    },
-    "node_modules/math-intrinsics": {
-      "version": "1.1.0",
-      "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
-      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 0.4"
-      }
-    },
-    "node_modules/media-typer": {
-      "version": "1.1.0",
-      "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-1.1.0.tgz",
-      "integrity": "sha512-aisnrDP4GNe06UcKFnV5bfMNPBUw4jsLGaWwWfnH3v02GnBuXX2MCVn5RbrWo0j3pczUilYblq7fQ7Nw2t5XKw==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 0.8"
-      }
-    },
-    "node_modules/memory-streams": {
-      "version": "0.1.3",
-      "resolved": "https://registry.npmjs.org/memory-streams/-/memory-streams-0.1.3.tgz",
-      "integrity": "sha512-qVQ/CjkMyMInPaaRMrwWNDvf6boRZXaT/DbQeMYcCWuXPEBf1v8qChOc9OlEVQp2uOvRXa1Qu30fLmKhY6NipA==",
-      "license": "MIT",
-      "dependencies": {
-        "readable-stream": "~1.0.2"
-      }
-    },
-    "node_modules/memorystream": {
-      "version": "0.3.1",
-      "resolved": "https://registry.npmjs.org/memorystream/-/memorystream-0.3.1.tgz",
-      "integrity": "sha512-S3UwM3yj5mtUSEfP41UZmt/0SCoVYUcU1rkXv+BQ5Ig8ndL4sPoJNBUJERafdPb5jjHJGuMgytgKvKIf58XNBw==",
-      "engines": {
-        "node": ">= 0.10.0"
-      }
-    },
-    "node_modules/merge-descriptors": {
-      "version": "2.0.0",
-      "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-2.0.0.tgz",
-      "integrity": "sha512-Snk314V5ayFLhp3fkUREub6WtjBfPdCPY1Ln8/8munuLuiYhsABgBVWsozAG+MWMbVEvcdcpbi9R7ww22l9Q3g==",
-      "license": "MIT",
-      "engines": {
-        "node": ">=18"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/sindresorhus"
-      }
-    },
-    "node_modules/mime-db": {
-      "version": "1.54.0",
-      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.54.0.tgz",
-      "integrity": "sha512-aU5EJuIN2WDemCcAp2vFBfp/m4EAhWJnUNSSw0ixs7/kXbd6Pg64EmwJkNdFhB8aWt1sH2CTXrLxo/iAGV3oPQ==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 0.6"
-      }
-    },
-    "node_modules/mime-types": {
-      "version": "3.0.2",
-      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-3.0.2.tgz",
-      "integrity": "sha512-Lbgzdk0h4juoQ9fCKXW4by0UJqj+nOOrI9MJ1sSj4nI8aI2eo1qmvQEie4VD1glsS250n15LsWsYtCugiStS5A==",
-      "license": "MIT",
-      "dependencies": {
-        "mime-db": "^1.54.0"
-      },
-      "engines": {
-        "node": ">=18"
-      },
-      "funding": {
-        "type": "opencollective",
-        "url": "https://opencollective.com/express"
-      }
-    },
-    "node_modules/minimatch": {
-      "version": "9.0.5",
-      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-9.0.5.tgz",
-      "integrity": "sha512-G6T0ZX48xgozx7587koeX9Ys2NYy6Gmv//P89sEte9V9whIapMNF4idKxnW2QtCcLiTWlb/wfCabAtAFWhhBow==",
-      "dev": true,
-      "license": "ISC",
-      "dependencies": {
-        "brace-expansion": "^2.0.1"
-      },
-      "engines": {
-        "node": ">=16 || 14 >=14.17"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/isaacs"
-      }
-    },
-    "node_modules/minipass": {
-      "version": "7.1.2",
-      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
-      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
-      "dev": true,
-      "license": "ISC",
-      "engines": {
-        "node": ">=16 || 14 >=14.17"
-      }
-    },
-    "node_modules/mocha": {
-      "version": "11.7.5",
-      "resolved": "https://registry.npmjs.org/mocha/-/mocha-11.7.5.tgz",
-      "integrity": "sha512-mTT6RgopEYABzXWFx+GcJ+ZQ32kp4fMf0xvpZIIfSq9Z8lC/++MtcCnQ9t5FP2veYEP95FIYSvW+U9fV4xrlig==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "browser-stdout": "^1.3.1",
-        "chokidar": "^4.0.1",
-        "debug": "^4.3.5",
-        "diff": "^7.0.0",
-        "escape-string-regexp": "^4.0.0",
-        "find-up": "^5.0.0",
-        "glob": "^10.4.5",
-        "he": "^1.2.0",
-        "is-path-inside": "^3.0.3",
-        "js-yaml": "^4.1.0",
-        "log-symbols": "^4.1.0",
-        "minimatch": "^9.0.5",
-        "ms": "^2.1.3",
-        "picocolors": "^1.1.1",
-        "serialize-javascript": "^6.0.2",
-        "strip-json-comments": "^3.1.1",
-        "supports-color": "^8.1.1",
-        "workerpool": "^9.2.0",
-        "yargs": "^17.7.2",
-        "yargs-parser": "^21.1.1",
-        "yargs-unparser": "^2.0.0"
-      },
-      "bin": {
-        "_mocha": "bin/_mocha",
-        "mocha": "bin/mocha.js"
-      },
-      "engines": {
-        "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
-      }
-    },
-    "node_modules/mocha/node_modules/diff": {
-      "version": "7.0.0",
-      "resolved": "https://registry.npmjs.org/diff/-/diff-7.0.0.tgz",
-      "integrity": "sha512-PJWHUb1RFevKCwaFA9RlG5tCd+FO5iRh9A8HEtkmBH2Li03iJriB6m6JIN4rGz3K3JLawI7/veA1xzRKP6ISBw==",
-      "dev": true,
-      "license": "BSD-3-Clause",
-      "engines": {
-        "node": ">=0.3.1"
-      }
-    },
-    "node_modules/ms": {
-      "version": "2.1.3",
-      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
-      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
-      "license": "MIT"
-    },
-    "node_modules/negotiator": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-1.0.0.tgz",
-      "integrity": "sha512-8Ofs/AUQh8MaEcrlq5xOX0CQ9ypTF5dl78mjlMNfOK08fzpgTHQRQPBxcPlEtIw0yRpws+Zo/3r+5WRby7u3Gg==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 0.6"
-      }
-    },
-    "node_modules/node-emoji": {
-      "version": "1.11.0",
-      "resolved": "https://registry.npmjs.org/node-emoji/-/node-emoji-1.11.0.tgz",
-      "integrity": "sha512-wo2DpQkQp7Sjm2A0cq+sN7EHKO6Sl0ctXeBdFZrL9T9+UywORbufTcTZxom8YqpLQt/FqNMUkOpkZrJVYSKD3A==",
-      "license": "MIT",
-      "dependencies": {
-        "lodash": "^4.17.21"
-      }
-    },
-    "node_modules/nopt": {
-      "version": "2.1.2",
-      "resolved": "https://registry.npmjs.org/nopt/-/nopt-2.1.2.tgz",
-      "integrity": "sha512-x8vXm7BZ2jE1Txrxh/hO74HTuYZQEbo8edoRcANgdZ4+PCV+pbjd/xdummkmjjC7LU5EjPzlu8zEq/oxWylnKA==",
-      "license": "MIT",
-      "dependencies": {
-        "abbrev": "1"
-      },
-      "bin": {
-        "nopt": "bin/nopt.js"
-      }
-    },
-    "node_modules/object-inspect": {
-      "version": "1.13.4",
-      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.4.tgz",
-      "integrity": "sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 0.4"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/ljharb"
-      }
-    },
-    "node_modules/on-finished": {
-      "version": "2.4.1",
-      "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.4.1.tgz",
-      "integrity": "sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==",
-      "license": "MIT",
-      "dependencies": {
-        "ee-first": "1.1.1"
-      },
-      "engines": {
-        "node": ">= 0.8"
-      }
-    },
-    "node_modules/once": {
-      "version": "1.4.0",
-      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
-      "integrity": "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==",
-      "license": "ISC",
-      "dependencies": {
-        "wrappy": "1"
-      }
-    },
-    "node_modules/optimist": {
-      "version": "0.3.7",
-      "resolved": "https://registry.npmjs.org/optimist/-/optimist-0.3.7.tgz",
-      "integrity": "sha512-TCx0dXQzVtSCg2OgY/bO9hjM9cV4XYx09TVK+s3+FhkjT6LovsLe+pPMzpWf+6yXK/hUizs2gUoTw3jHM0VaTQ==",
-      "license": "MIT/X11",
-      "dependencies": {
-        "wordwrap": "~0.0.2"
-      }
-    },
-    "node_modules/p-limit": {
-      "version": "3.1.0",
-      "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-3.1.0.tgz",
-      "integrity": "sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "yocto-queue": "^0.1.0"
-      },
-      "engines": {
-        "node": ">=10"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/sindresorhus"
-      }
-    },
-    "node_modules/p-locate": {
-      "version": "5.0.0",
-      "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-5.0.0.tgz",
-      "integrity": "sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "p-limit": "^3.0.2"
-      },
-      "engines": {
-        "node": ">=10"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/sindresorhus"
-      }
-    },
-    "node_modules/package-json-from-dist": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz",
-      "integrity": "sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==",
-      "dev": true,
-      "license": "BlueOak-1.0.0"
-    },
-    "node_modules/parseurl": {
-      "version": "1.3.3",
-      "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
-      "integrity": "sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 0.8"
-      }
-    },
-    "node_modules/path-exists": {
-      "version": "4.0.0",
-      "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz",
-      "integrity": "sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==",
-      "dev": true,
-      "license": "MIT",
-      "engines": {
-        "node": ">=8"
-      }
-    },
-    "node_modules/path-key": {
-      "version": "3.1.1",
-      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
-      "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
-      "dev": true,
-      "license": "MIT",
-      "engines": {
-        "node": ">=8"
-      }
-    },
-    "node_modules/path-scurry": {
-      "version": "1.11.1",
-      "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-1.11.1.tgz",
-      "integrity": "sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==",
-      "dev": true,
-      "license": "BlueOak-1.0.0",
-      "dependencies": {
-        "lru-cache": "^10.2.0",
-        "minipass": "^5.0.0 || ^6.0.2 || ^7.0.0"
-      },
-      "engines": {
-        "node": ">=16 || 14 >=14.18"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/isaacs"
-      }
-    },
-    "node_modules/path-to-regexp": {
-      "version": "8.3.0",
-      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-8.3.0.tgz",
-      "integrity": "sha512-7jdwVIRtsP8MYpdXSwOS0YdD0Du+qOoF/AEPIt88PcCFrZCzx41oxku1jD88hZBwbNUIEfpqvuhjFaMAqMTWnA==",
-      "license": "MIT",
-      "funding": {
-        "type": "opencollective",
-        "url": "https://opencollective.com/express"
-      }
-    },
-    "node_modules/pathval": {
-      "version": "1.1.1",
-      "resolved": "https://registry.npmjs.org/pathval/-/pathval-1.1.1.tgz",
-      "integrity": "sha512-Dp6zGqpTdETdR63lehJYPeIOqpiNBNtc7BpWSLrOje7UaIsE5aY92r/AunQA7rsXvet3lrJ3JnZX29UPTKXyKQ==",
-      "dev": true,
-      "license": "MIT",
-      "engines": {
-        "node": "*"
-      }
-    },
-    "node_modules/picocolors": {
-      "version": "1.1.1",
-      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
-      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
-      "dev": true,
-      "license": "ISC"
-    },
-    "node_modules/picture-tuber": {
-      "version": "1.0.2",
-      "resolved": "https://registry.npmjs.org/picture-tuber/-/picture-tuber-1.0.2.tgz",
-      "integrity": "sha512-49/xq+wzbwDeI32aPvwQJldM8pr7dKDRuR76IjztrkmiCkAQDaWFJzkmfVqCHmt/iFoPFhHmI9L0oKhthrTOQw==",
-      "license": "MIT",
-      "dependencies": {
-        "buffers": "~0.1.1",
-        "charm": "~0.1.0",
-        "event-stream": "~0.9.8",
-        "optimist": "~0.3.4",
-        "png-js": "~0.1.0",
-        "x256": "~0.0.1"
-      },
-      "bin": {
-        "picture-tube": "bin/tube.js"
-      },
-      "engines": {
-        "node": ">=0.4.0"
-      }
-    },
-    "node_modules/png-js": {
-      "version": "0.1.1",
-      "resolved": "https://registry.npmjs.org/png-js/-/png-js-0.1.1.tgz",
-      "integrity": "sha512-NTtk2SyfjBm+xYl2/VZJBhFnTQ4kU5qWC7VC4/iGbrgiU4FuB4xC+74erxADYJIqZICOR1HCvRA7EBHkpjTg9g=="
-    },
-    "node_modules/proper-lockfile": {
-      "version": "4.1.2",
-      "resolved": "https://registry.npmjs.org/proper-lockfile/-/proper-lockfile-4.1.2.tgz",
-      "integrity": "sha512-TjNPblN4BwAWMXU8s9AEz4JmQxnD1NNL7bNOY/AKUzyamc379FWASUhc/K1pL2noVb+XmZKLL68cjzLsiOAMaA==",
-      "license": "MIT",
-      "dependencies": {
-        "graceful-fs": "^4.2.4",
-        "retry": "^0.12.0",
-        "signal-exit": "^3.0.2"
-      }
-    },
-    "node_modules/proxy-addr": {
-      "version": "2.0.7",
-      "resolved": "https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.7.tgz",
-      "integrity": "sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==",
-      "license": "MIT",
-      "dependencies": {
-        "forwarded": "0.2.0",
-        "ipaddr.js": "1.9.1"
-      },
-      "engines": {
-        "node": ">= 0.10"
-      }
-    },
-    "node_modules/qs": {
-      "version": "6.14.1",
-      "resolved": "https://registry.npmjs.org/qs/-/qs-6.14.1.tgz",
-      "integrity": "sha512-4EK3+xJl8Ts67nLYNwqw/dsFVnCf+qR7RgXSK9jEEm9unao3njwMDdmsdvoKBKHzxd7tCYz5e5M+SnMjdtXGQQ==",
-      "license": "BSD-3-Clause",
-      "dependencies": {
-        "side-channel": "^1.1.0"
-      },
-      "engines": {
-        "node": ">=0.6"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/ljharb"
-      }
-    },
-    "node_modules/randombytes": {
-      "version": "2.1.0",
-      "resolved": "https://registry.npmjs.org/randombytes/-/randombytes-2.1.0.tgz",
-      "integrity": "sha512-vYl3iOX+4CKUWuxGi9Ukhie6fsqXqS9FE2Zaic4tNFD2N2QQaXOMFbuKK4QmDHC0JO6B1Zp41J0LpT0oR68amQ==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "safe-buffer": "^5.1.0"
-      }
-    },
-    "node_modules/range-parser": {
-      "version": "1.2.1",
-      "resolved": "https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz",
-      "integrity": "sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 0.6"
-      }
-    },
-    "node_modules/raw-body": {
-      "version": "3.0.2",
-      "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-3.0.2.tgz",
-      "integrity": "sha512-K5zQjDllxWkf7Z5xJdV0/B0WTNqx6vxG70zJE4N0kBs4LovmEYWJzQGxC9bS9RAKu3bgM40lrd5zoLJ12MQ5BA==",
-      "license": "MIT",
-      "dependencies": {
-        "bytes": "~3.1.2",
-        "http-errors": "~2.0.1",
-        "iconv-lite": "~0.7.0",
-        "unpipe": "~1.0.0"
-      },
-      "engines": {
-        "node": ">= 0.10"
-      }
-    },
-    "node_modules/readable-stream": {
-      "version": "1.0.34",
-      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-1.0.34.tgz",
-      "integrity": "sha512-ok1qVCJuRkNmvebYikljxJA/UEsKwLl2nI1OmaqAu4/UE+h0wKCHok4XkL/gvi39OacXvw59RJUOFUkDib2rHg==",
-      "license": "MIT",
-      "dependencies": {
-        "core-util-is": "~1.0.0",
-        "inherits": "~2.0.1",
-        "isarray": "0.0.1",
-        "string_decoder": "~0.10.x"
-      }
-    },
-    "node_modules/readdirp": {
-      "version": "4.1.2",
-      "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-4.1.2.tgz",
-      "integrity": "sha512-GDhwkLfywWL2s6vEjyhri+eXmfH6j1L7JE27WhqLeYzoh/A3DBaYGEj2H/HFZCn/kMfim73FXxEJTw06WtxQwg==",
-      "dev": true,
-      "license": "MIT",
-      "engines": {
-        "node": ">= 14.18.0"
-      },
-      "funding": {
-        "type": "individual",
-        "url": "https://paulmillr.com/funding/"
-      }
-    },
-    "node_modules/redeyed": {
-      "version": "2.1.1",
-      "resolved": "https://registry.npmjs.org/redeyed/-/redeyed-2.1.1.tgz",
-      "integrity": "sha512-FNpGGo1DycYAdnrKFxCMmKYgo/mILAqtRYbkdQD8Ep/Hk2PQ5+aEAEx+IU713RTDmuBaH0c8P5ZozurNu5ObRQ==",
-      "license": "MIT",
-      "dependencies": {
-        "esprima": "~4.0.0"
-      }
-    },
-    "node_modules/require-directory": {
-      "version": "2.1.1",
-      "resolved": "https://registry.npmjs.org/require-directory/-/require-directory-2.1.1.tgz",
-      "integrity": "sha512-fGxEI7+wsG9xrvdjsrlmL22OMTTiHRwAMroiEeMgq8gzoLC/PQr7RsRDSTLUg/bZAZtF+TVIkHc6/4RIKrui+Q==",
-      "dev": true,
-      "license": "MIT",
-      "engines": {
-        "node": ">=0.10.0"
-      }
-    },
-    "node_modules/retry": {
-      "version": "0.12.0",
-      "resolved": "https://registry.npmjs.org/retry/-/retry-0.12.0.tgz",
-      "integrity": "sha512-9LkiTwjUh6rT555DtE9rTX+BKByPfrMzEAtnlEtdEwr3Nkffwiihqe2bWADg+OQRjt9gl6ICdmB/ZFDCGAtSow==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 4"
-      }
-    },
-    "node_modules/router": {
-      "version": "2.2.0",
-      "resolved": "https://registry.npmjs.org/router/-/router-2.2.0.tgz",
-      "integrity": "sha512-nLTrUKm2UyiL7rlhapu/Zl45FwNgkZGaCpZbIHajDYgwlJCOzLSk+cIPAnsEqV955GjILJnKbdQC1nVPz+gAYQ==",
-      "license": "MIT",
-      "dependencies": {
-        "debug": "^4.4.0",
-        "depd": "^2.0.0",
-        "is-promise": "^4.0.0",
-        "parseurl": "^1.3.3",
-        "path-to-regexp": "^8.0.0"
-      },
-      "engines": {
-        "node": ">= 18"
-      }
-    },
-    "node_modules/safe-buffer": {
-      "version": "5.2.1",
-      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
-      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
-      "dev": true,
-      "funding": [
-        {
-          "type": "github",
-          "url": "https://github.com/sponsors/feross"
-        },
-        {
-          "type": "patreon",
-          "url": "https://www.patreon.com/feross"
-        },
-        {
-          "type": "consulting",
-          "url": "https://feross.org/support"
-        }
-      ],
-      "license": "MIT"
-    },
-    "node_modules/safer-buffer": {
-      "version": "2.1.2",
-      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
-      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==",
-      "license": "MIT"
-    },
-    "node_modules/sax": {
-      "version": "1.4.4",
-      "resolved": "https://registry.npmjs.org/sax/-/sax-1.4.4.tgz",
-      "integrity": "sha512-1n3r/tGXO6b6VXMdFT54SHzT9ytu9yr7TaELowdYpMqY/Ao7EnlQGmAQ1+RatX7Tkkdm6hONI2owqNx2aZj5Sw==",
-      "license": "BlueOak-1.0.0",
-      "engines": {
-        "node": ">=11.0.0"
-      }
-    },
-    "node_modules/send": {
-      "version": "1.2.1",
-      "resolved": "https://registry.npmjs.org/send/-/send-1.2.1.tgz",
-      "integrity": "sha512-1gnZf7DFcoIcajTjTwjwuDjzuz4PPcY2StKPlsGAQ1+YH20IRVrBaXSWmdjowTJ6u8Rc01PoYOGHXfP1mYcZNQ==",
-      "license": "MIT",
-      "dependencies": {
-        "debug": "^4.4.3",
-        "encodeurl": "^2.0.0",
-        "escape-html": "^1.0.3",
-        "etag": "^1.8.1",
-        "fresh": "^2.0.0",
-        "http-errors": "^2.0.1",
-        "mime-types": "^3.0.2",
-        "ms": "^2.1.3",
-        "on-finished": "^2.4.1",
-        "range-parser": "^1.2.1",
-        "statuses": "^2.0.2"
-      },
-      "engines": {
-        "node": ">= 18"
-      },
-      "funding": {
-        "type": "opencollective",
-        "url": "https://opencollective.com/express"
-      }
-    },
-    "node_modules/serialize-javascript": {
-      "version": "6.0.2",
-      "resolved": "https://registry.npmjs.org/serialize-javascript/-/serialize-javascript-6.0.2.tgz",
-      "integrity": "sha512-Saa1xPByTTq2gdeFZYLLo+RFE35NHZkAbqZeWNd3BpzppeVisAqpDjcp8dyf6uIvEqJRd46jemmyA4iFIeVk8g==",
-      "dev": true,
-      "license": "BSD-3-Clause",
-      "dependencies": {
-        "randombytes": "^2.1.0"
-      }
-    },
-    "node_modules/serve-static": {
-      "version": "2.2.1",
-      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-2.2.1.tgz",
-      "integrity": "sha512-xRXBn0pPqQTVQiC8wyQrKs2MOlX24zQ0POGaj0kultvoOCstBQM5yvOhAVSUwOMjQtTvsPWoNCHfPGwaaQJhTw==",
-      "license": "MIT",
-      "dependencies": {
-        "encodeurl": "^2.0.0",
-        "escape-html": "^1.0.3",
-        "parseurl": "^1.3.3",
-        "send": "^1.2.0"
-      },
-      "engines": {
-        "node": ">= 18"
-      },
-      "funding": {
-        "type": "opencollective",
-        "url": "https://opencollective.com/express"
-      }
-    },
-    "node_modules/setprototypeof": {
-      "version": "1.2.0",
-      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
-      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw==",
-      "license": "ISC"
-    },
-    "node_modules/shebang-command": {
-      "version": "2.0.0",
-      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
-      "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "shebang-regex": "^3.0.0"
-      },
-      "engines": {
-        "node": ">=8"
-      }
-    },
-    "node_modules/shebang-regex": {
-      "version": "3.0.0",
-      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
-      "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
-      "dev": true,
-      "license": "MIT",
-      "engines": {
-        "node": ">=8"
-      }
-    },
-    "node_modules/side-channel": {
-      "version": "1.1.0",
-      "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.1.0.tgz",
-      "integrity": "sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==",
-      "license": "MIT",
-      "dependencies": {
-        "es-errors": "^1.3.0",
-        "object-inspect": "^1.13.3",
-        "side-channel-list": "^1.0.0",
-        "side-channel-map": "^1.0.1",
-        "side-channel-weakmap": "^1.0.2"
-      },
-      "engines": {
-        "node": ">= 0.4"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/ljharb"
-      }
-    },
-    "node_modules/side-channel-list": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/side-channel-list/-/side-channel-list-1.0.0.tgz",
-      "integrity": "sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==",
-      "license": "MIT",
-      "dependencies": {
-        "es-errors": "^1.3.0",
-        "object-inspect": "^1.13.3"
-      },
-      "engines": {
-        "node": ">= 0.4"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/ljharb"
-      }
-    },
-    "node_modules/side-channel-map": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/side-channel-map/-/side-channel-map-1.0.1.tgz",
-      "integrity": "sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==",
-      "license": "MIT",
-      "dependencies": {
-        "call-bound": "^1.0.2",
-        "es-errors": "^1.3.0",
-        "get-intrinsic": "^1.2.5",
-        "object-inspect": "^1.13.3"
-      },
-      "engines": {
-        "node": ">= 0.4"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/ljharb"
-      }
-    },
-    "node_modules/side-channel-weakmap": {
-      "version": "1.0.2",
-      "resolved": "https://registry.npmjs.org/side-channel-weakmap/-/side-channel-weakmap-1.0.2.tgz",
-      "integrity": "sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==",
-      "license": "MIT",
-      "dependencies": {
-        "call-bound": "^1.0.2",
-        "es-errors": "^1.3.0",
-        "get-intrinsic": "^1.2.5",
-        "object-inspect": "^1.13.3",
-        "side-channel-map": "^1.0.1"
-      },
-      "engines": {
-        "node": ">= 0.4"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/ljharb"
-      }
-    },
-    "node_modules/signal-exit": {
-      "version": "3.0.7",
-      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-3.0.7.tgz",
-      "integrity": "sha512-wnD2ZE+l+SPC/uoS0vXeE9L1+0wuaMqKlfz9AMUo38JsyLSBWSFcHR1Rri62LZc12vLr1gb3jl7iwQhgwpAbGQ==",
-      "license": "ISC"
-    },
-    "node_modules/smart-buffer": {
-      "version": "4.2.0",
-      "resolved": "https://registry.npmjs.org/smart-buffer/-/smart-buffer-4.2.0.tgz",
-      "integrity": "sha512-94hK0Hh8rPqQl2xXc3HsaBoOXKV20MToPkcXvwbISWLEs+64sBq5kFgn2kJDHb1Pry9yrP0dxrCI9RRci7RXKg==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 6.0.0",
-        "npm": ">= 3.0.0"
-      }
-    },
-    "node_modules/socks": {
-      "version": "2.8.7",
-      "resolved": "https://registry.npmjs.org/socks/-/socks-2.8.7.tgz",
-      "integrity": "sha512-HLpt+uLy/pxB+bum/9DzAgiKS8CX1EvbWxI4zlmgGCExImLdiad2iCwXT5Z4c9c3Eq8rP2318mPW2c+QbtjK8A==",
-      "license": "MIT",
-      "dependencies": {
-        "ip-address": "^10.0.1",
-        "smart-buffer": "^4.2.0"
-      },
-      "engines": {
-        "node": ">= 10.0.0",
-        "npm": ">= 3.0.0"
-      }
-    },
-    "node_modules/socks-proxy-agent": {
-      "version": "8.0.5",
-      "resolved": "https://registry.npmjs.org/socks-proxy-agent/-/socks-proxy-agent-8.0.5.tgz",
-      "integrity": "sha512-HehCEsotFqbPW9sJ8WVYB6UbmIMv7kUUORIF2Nncq4VQvBfNBLibW9YZR5dlYCSUhwcD628pRllm7n+E+YTzJw==",
-      "license": "MIT",
-      "dependencies": {
-        "agent-base": "^7.1.2",
-        "debug": "^4.3.4",
-        "socks": "^2.8.3"
-      },
-      "engines": {
-        "node": ">= 14"
-      }
-    },
-    "node_modules/sparkline": {
-      "version": "0.1.2",
-      "resolved": "https://registry.npmjs.org/sparkline/-/sparkline-0.1.2.tgz",
-      "integrity": "sha512-t//aVOiWt9fi/e22ea1vXVWBDX+gp18y+Ch9sKqmHl828bRfvP2VtfTJVEcgWFBQHd0yDPNQRiHdqzCvbcYSDA==",
-      "dependencies": {
-        "here": "0.0.2",
-        "nopt": "~2.1.2"
-      },
-      "bin": {
-        "sparkline": "bin/sparkline"
-      },
-      "engines": {
-        "node": ">= 0.8.0"
-      }
-    },
-    "node_modules/statuses": {
-      "version": "2.0.2",
-      "resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.2.tgz",
-      "integrity": "sha512-DvEy55V3DB7uknRo+4iOGT5fP1slR8wQohVdknigZPMpMstaKJQWhwiYBACJE3Ul2pTnATihhBYnRhZQHGBiRw==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 0.8"
-      }
-    },
-    "node_modules/string_decoder": {
-      "version": "0.10.31",
-      "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-0.10.31.tgz",
-      "integrity": "sha512-ev2QzSzWPYmy9GuqfIVildA4OdcGLeFZQrq5ys6RtiuF+RQQiZWr8TZNyAcuVXyQRYfEO+MsoB/1BuQVhOJuoQ==",
-      "license": "MIT"
-    },
-    "node_modules/string-width": {
-      "version": "5.1.2",
-      "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
-      "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "eastasianwidth": "^0.2.0",
-        "emoji-regex": "^9.2.2",
-        "strip-ansi": "^7.0.1"
-      },
-      "engines": {
-        "node": ">=12"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/sindresorhus"
-      }
-    },
-    "node_modules/string-width-cjs": {
-      "name": "string-width",
-      "version": "4.2.3",
-      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
-      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "emoji-regex": "^8.0.0",
-        "is-fullwidth-code-point": "^3.0.0",
-        "strip-ansi": "^6.0.1"
-      },
-      "engines": {
-        "node": ">=8"
-      }
-    },
-    "node_modules/string-width-cjs/node_modules/emoji-regex": {
-      "version": "8.0.0",
-      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
-      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
-      "dev": true,
-      "license": "MIT"
-    },
-    "node_modules/string-width/node_modules/ansi-regex": {
-      "version": "6.2.2",
-      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
-      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
-      "dev": true,
-      "license": "MIT",
-      "engines": {
-        "node": ">=12"
-      },
-      "funding": {
-        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
-      }
-    },
-    "node_modules/string-width/node_modules/strip-ansi": {
-      "version": "7.1.2",
-      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
-      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "ansi-regex": "^6.0.1"
-      },
-      "engines": {
-        "node": ">=12"
-      },
-      "funding": {
-        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
-      }
-    },
-    "node_modules/strip-ansi": {
-      "version": "6.0.1",
-      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
-      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
-      "license": "MIT",
-      "dependencies": {
-        "ansi-regex": "^5.0.1"
-      },
-      "engines": {
-        "node": ">=8"
-      }
-    },
-    "node_modules/strip-ansi-cjs": {
-      "name": "strip-ansi",
-      "version": "6.0.1",
-      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
-      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "ansi-regex": "^5.0.1"
-      },
-      "engines": {
-        "node": ">=8"
-      }
-    },
-    "node_modules/strip-json-comments": {
-      "version": "3.1.1",
-      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
-      "integrity": "sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==",
-      "dev": true,
-      "license": "MIT",
-      "engines": {
-        "node": ">=8"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/sindresorhus"
-      }
-    },
-    "node_modules/supports-color": {
-      "version": "8.1.1",
-      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-8.1.1.tgz",
-      "integrity": "sha512-MpUEN2OodtUzxvKQl72cUF7RQ5EiHsGvSsVG0ia9c5RbWGL2CI4C7EpPS8UTBIplnlzZiNuV56w+FuNxy3ty2Q==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "has-flag": "^4.0.0"
-      },
-      "engines": {
-        "node": ">=10"
-      },
-      "funding": {
-        "url": "https://github.com/chalk/supports-color?sponsor=1"
-      }
-    },
-    "node_modules/supports-hyperlinks": {
-      "version": "2.3.0",
-      "resolved": "https://registry.npmjs.org/supports-hyperlinks/-/supports-hyperlinks-2.3.0.tgz",
-      "integrity": "sha512-RpsAZlpWcDwOPQA22aCH4J0t7L8JmAvsCxfOSEwm7cQs3LshN36QaTkwd70DnBOXDWGssw2eUoc8CaRWT0XunA==",
-      "license": "MIT",
-      "dependencies": {
-        "has-flag": "^4.0.0",
-        "supports-color": "^7.0.0"
-      },
-      "engines": {
-        "node": ">=8"
-      }
-    },
-    "node_modules/supports-hyperlinks/node_modules/supports-color": {
-      "version": "7.2.0",
-      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
-      "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
-      "license": "MIT",
-      "dependencies": {
-        "has-flag": "^4.0.0"
-      },
-      "engines": {
-        "node": ">=8"
-      }
-    },
-    "node_modules/term-canvas": {
-      "version": "0.0.5",
-      "resolved": "https://registry.npmjs.org/term-canvas/-/term-canvas-0.0.5.tgz",
-      "integrity": "sha512-eZ3rIWi5yLnKiUcsW8P79fKyooaLmyLWAGqBhFspqMxRNUiB4GmHHk5AzQ4LxvFbJILaXqQZLwbbATLOhCFwkw=="
-    },
-    "node_modules/toidentifier": {
-      "version": "1.0.1",
-      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
-      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
-      "license": "MIT",
-      "engines": {
-        "node": ">=0.6"
-      }
-    },
-    "node_modules/ts-node": {
-      "version": "10.9.2",
-      "resolved": "https://registry.npmjs.org/ts-node/-/ts-node-10.9.2.tgz",
-      "integrity": "sha512-f0FFpIdcHgn8zcPSbf1dRevwt047YMnaiJM3u2w2RewrB+fob/zePZcrOyQoLMMO7aBIddLcQIEK5dYjkLnGrQ==",
+    "node_modules/ts-node": {
+      "version": "10.9.2",
+      "resolved": "https://registry.npmjs.org/ts-node/-/ts-node-10.9.2.tgz",
+      "integrity": "sha512-f0FFpIdcHgn8zcPSbf1dRevwt047YMnaiJM3u2w2RewrB+fob/zePZcrOyQoLMMO7aBIddLcQIEK5dYjkLnGrQ==",
       "dev": true,
       "license": "MIT",
       "dependencies": {
@@ -2754,30 +401,6 @@
         }
       }
     },
-    "node_modules/type-detect": {
-      "version": "4.1.0",
-      "resolved": "https://registry.npmjs.org/type-detect/-/type-detect-4.1.0.tgz",
-      "integrity": "sha512-Acylog8/luQ8L7il+geoSxhEkazvkslg7PSNKOX59mbB9cOveP5aq9h74Y7YU8yDpJwetzQQrfIwtf4Wp4LKcw==",
-      "dev": true,
-      "license": "MIT",
-      "engines": {
-        "node": ">=4"
-      }
-    },
-    "node_modules/type-is": {
-      "version": "2.0.1",
-      "resolved": "https://registry.npmjs.org/type-is/-/type-is-2.0.1.tgz",
-      "integrity": "sha512-OZs6gsjF4vMp32qrCbiVSkrFmXtG/AZhY3t0iAMrMBiAZyV9oALtXO8hsrHbMXF9x6L3grlFuwW2oAz7cav+Gw==",
-      "license": "MIT",
-      "dependencies": {
-        "content-type": "^1.0.5",
-        "media-typer": "^1.1.0",
-        "mime-types": "^3.0.0"
-      },
-      "engines": {
-        "node": ">= 0.6"
-      }
-    },
     "node_modules/typescript": {
       "version": "5.9.3",
       "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.9.3.tgz",
@@ -2796,17 +419,9 @@
       "version": "7.16.0",
       "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-7.16.0.tgz",
       "integrity": "sha512-Zz+aZWSj8LE6zoxD+xrjh4VfkIG8Ya6LvYkZqtUQGJPZjYl53ypCaUwWqo7eI0x66KBGeRo+mlBEkMSeSZ38Nw==",
+      "dev": true,
       "license": "MIT"
     },
-    "node_modules/unpipe": {
-      "version": "1.0.0",
-      "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
-      "integrity": "sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 0.8"
-      }
-    },
     "node_modules/v8-compile-cache-lib": {
       "version": "3.0.1",
       "resolved": "https://registry.npmjs.org/v8-compile-cache-lib/-/v8-compile-cache-lib-3.0.1.tgz",
@@ -2814,163 +429,6 @@
       "dev": true,
       "license": "MIT"
     },
-    "node_modules/vary": {
-      "version": "1.1.2",
-      "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
-      "integrity": "sha512-BNGbWLfd0eUPabhkXUVm0j8uuvREyTh5ovRa/dyow/BqAbZJyC+5fU+IzQOzmAKzYqYRAISoRhdQr3eIZ/PXqg==",
-      "license": "MIT",
-      "engines": {
-        "node": ">= 0.8"
-      }
-    },
-    "node_modules/which": {
-      "version": "2.0.2",
-      "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
-      "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
-      "dev": true,
-      "license": "ISC",
-      "dependencies": {
-        "isexe": "^2.0.0"
-      },
-      "bin": {
-        "node-which": "bin/node-which"
-      },
-      "engines": {
-        "node": ">= 8"
-      }
-    },
-    "node_modules/wordwrap": {
-      "version": "0.0.3",
-      "resolved": "https://registry.npmjs.org/wordwrap/-/wordwrap-0.0.3.tgz",
-      "integrity": "sha512-1tMA907+V4QmxV7dbRvb4/8MaRALK6q9Abid3ndMYnbyo8piisCmeONVqVSXqQA3KaP4SLt5b7ud6E2sqP8TFw==",
-      "license": "MIT",
-      "engines": {
-        "node": ">=0.4.0"
-      }
-    },
-    "node_modules/workerpool": {
-      "version": "9.3.4",
-      "resolved": "https://registry.npmjs.org/workerpool/-/workerpool-9.3.4.tgz",
-      "integrity": "sha512-TmPRQYYSAnnDiEB0P/Ytip7bFGvqnSU6I2BcuSw7Hx+JSg/DsUi5ebYfc8GYaSdpuvOcEs6dXxPurOYpe9QFwg==",
-      "dev": true,
-      "license": "Apache-2.0"
-    },
-    "node_modules/wrap-ansi": {
-      "version": "8.1.0",
-      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz",
-      "integrity": "sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "ansi-styles": "^6.1.0",
-        "string-width": "^5.0.1",
-        "strip-ansi": "^7.0.1"
-      },
-      "engines": {
-        "node": ">=12"
-      },
-      "funding": {
-        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
-      }
-    },
-    "node_modules/wrap-ansi-cjs": {
-      "name": "wrap-ansi",
-      "version": "7.0.0",
-      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
-      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "ansi-styles": "^4.0.0",
-        "string-width": "^4.1.0",
-        "strip-ansi": "^6.0.0"
-      },
-      "engines": {
-        "node": ">=10"
-      },
-      "funding": {
-        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
-      }
-    },
-    "node_modules/wrap-ansi-cjs/node_modules/emoji-regex": {
-      "version": "8.0.0",
-      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
-      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
-      "dev": true,
-      "license": "MIT"
-    },
-    "node_modules/wrap-ansi-cjs/node_modules/string-width": {
-      "version": "4.2.3",
-      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
-      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "emoji-regex": "^8.0.0",
-        "is-fullwidth-code-point": "^3.0.0",
-        "strip-ansi": "^6.0.1"
-      },
-      "engines": {
-        "node": ">=8"
-      }
-    },
-    "node_modules/wrap-ansi/node_modules/ansi-regex": {
-      "version": "6.2.2",
-      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.2.2.tgz",
-      "integrity": "sha512-Bq3SmSpyFHaWjPk8If9yc6svM8c56dB5BAtW4Qbw5jHTwwXXcTLoRMkpDJp6VL0XzlWaCHTXrkFURMYmD0sLqg==",
-      "dev": true,
-      "license": "MIT",
-      "engines": {
-        "node": ">=12"
-      },
-      "funding": {
-        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
-      }
-    },
-    "node_modules/wrap-ansi/node_modules/ansi-styles": {
-      "version": "6.2.3",
-      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.3.tgz",
-      "integrity": "sha512-4Dj6M28JB+oAH8kFkTLUo+a2jwOFkuqb3yucU0CANcRRUbxS0cP0nZYCGjcc3BNXwRIsUVmDGgzawme7zvJHvg==",
-      "dev": true,
-      "license": "MIT",
-      "engines": {
-        "node": ">=12"
-      },
-      "funding": {
-        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
-      }
-    },
-    "node_modules/wrap-ansi/node_modules/strip-ansi": {
-      "version": "7.1.2",
-      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.2.tgz",
-      "integrity": "sha512-gmBGslpoQJtgnMAvOVqGZpEz9dyoKTCzy2nfz/n8aIFhN/jCE/rCmcxabB6jOOHV+0WNnylOxaxBQPSvcWklhA==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "ansi-regex": "^6.0.1"
-      },
-      "engines": {
-        "node": ">=12"
-      },
-      "funding": {
-        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
-      }
-    },
-    "node_modules/wrappy": {
-      "version": "1.0.2",
-      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
-      "integrity": "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==",
-      "license": "ISC"
-    },
-    "node_modules/x256": {
-      "version": "0.0.2",
-      "resolved": "https://registry.npmjs.org/x256/-/x256-0.0.2.tgz",
-      "integrity": "sha512-ZsIH+sheoF8YG9YG+QKEEIdtqpHRA9FYuD7MqhfyB1kayXU43RUNBFSxBEnF8ywSUxdg+8no4+bPr5qLbyxKgA==",
-      "license": "MIT",
-      "engines": {
-        "node": ">=0.4.0"
-      }
-    },
     "node_modules/xdg-basedir": {
       "version": "5.1.0",
       "resolved": "https://registry.npmjs.org/xdg-basedir/-/xdg-basedir-5.1.0.tgz",
@@ -2983,105 +441,6 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
-    "node_modules/xml2js": {
-      "version": "0.4.23",
-      "resolved": "https://registry.npmjs.org/xml2js/-/xml2js-0.4.23.tgz",
-      "integrity": "sha512-ySPiMjM0+pLDftHgXY4By0uswI3SPKLDw/i3UXbnO8M/p28zqexCUoPmQFrYD+/1BzhGJSs2i1ERWKJAtiLrug==",
-      "license": "MIT",
-      "dependencies": {
-        "sax": ">=0.6.0",
-        "xmlbuilder": "~11.0.0"
-      },
-      "engines": {
-        "node": ">=4.0.0"
-      }
-    },
-    "node_modules/xmlbuilder": {
-      "version": "11.0.1",
-      "resolved": "https://registry.npmjs.org/xmlbuilder/-/xmlbuilder-11.0.1.tgz",
-      "integrity": "sha512-fDlsI/kFEx7gLvbecc0/ohLG50fugQp8ryHzMTuW9vSa1GJ0XYWKnhsUx7oie3G98+r56aTQIUB4kht42R3JvA==",
-      "license": "MIT",
-      "engines": {
-        "node": ">=4.0"
-      }
-    },
-    "node_modules/y18n": {
-      "version": "5.0.8",
-      "resolved": "https://registry.npmjs.org/y18n/-/y18n-5.0.8.tgz",
-      "integrity": "sha512-0pfFzegeDWJHJIAmTLRP2DwHjdF5s7jo9tuztdQxAhINCdvS+3nGINqPd00AphqJR/0LhANUS6/+7SCb98YOfA==",
-      "dev": true,
-      "license": "ISC",
-      "engines": {
-        "node": ">=10"
-      }
-    },
-    "node_modules/yargs": {
-      "version": "17.7.2",
-      "resolved": "https://registry.npmjs.org/yargs/-/yargs-17.7.2.tgz",
-      "integrity": "sha512-7dSzzRQ++CKnNI/krKnYRV7JKKPUXMEh61soaHKg9mrWEhzFWhFnxPxGl+69cD1Ou63C13NUPCnmIcrvqCuM6w==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "cliui": "^8.0.1",
-        "escalade": "^3.1.1",
-        "get-caller-file": "^2.0.5",
-        "require-directory": "^2.1.1",
-        "string-width": "^4.2.3",
-        "y18n": "^5.0.5",
-        "yargs-parser": "^21.1.1"
-      },
-      "engines": {
-        "node": ">=12"
-      }
-    },
-    "node_modules/yargs-parser": {
-      "version": "21.1.1",
-      "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-21.1.1.tgz",
-      "integrity": "sha512-tVpsJW7DdjecAiFpbIB1e3qxIQsE6NoPc5/eTdrbbIC4h0LVsWhnoa3g+m2HclBIujHzsxZ4VJVA+GUuc2/LBw==",
-      "dev": true,
-      "license": "ISC",
-      "engines": {
-        "node": ">=12"
-      }
-    },
-    "node_modules/yargs-unparser": {
-      "version": "2.0.0",
-      "resolved": "https://registry.npmjs.org/yargs-unparser/-/yargs-unparser-2.0.0.tgz",
-      "integrity": "sha512-7pRTIA9Qc1caZ0bZ6RYRGbHJthJWuakf+WmHK0rVeLkNrrGhfoabBNdue6kdINI6r4if7ocq9aD/n7xwKOdzOA==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "camelcase": "^6.0.0",
-        "decamelize": "^4.0.0",
-        "flat": "^5.0.2",
-        "is-plain-obj": "^2.1.0"
-      },
-      "engines": {
-        "node": ">=10"
-      }
-    },
-    "node_modules/yargs/node_modules/emoji-regex": {
-      "version": "8.0.0",
-      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
-      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
-      "dev": true,
-      "license": "MIT"
-    },
-    "node_modules/yargs/node_modules/string-width": {
-      "version": "4.2.3",
-      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
-      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
-      "dev": true,
-      "license": "MIT",
-      "dependencies": {
-        "emoji-regex": "^8.0.0",
-        "is-fullwidth-code-point": "^3.0.0",
-        "strip-ansi": "^6.0.1"
-      },
-      "engines": {
-        "node": ">=8"
-      }
-    },
     "node_modules/yn": {
       "version": "3.1.1",
       "resolved": "https://registry.npmjs.org/yn/-/yn-3.1.1.tgz",
@@ -3092,19 +451,6 @@
         "node": ">=6"
       }
     },
-    "node_modules/yocto-queue": {
-      "version": "0.1.0",
-      "resolved": "https://registry.npmjs.org/yocto-queue/-/yocto-queue-0.1.0.tgz",
-      "integrity": "sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==",
-      "dev": true,
-      "license": "MIT",
-      "engines": {
-        "node": ">=10"
-      },
-      "funding": {
-        "url": "https://github.com/sponsors/sindresorhus"
-      }
-    },
     "node_modules/zod": {
       "version": "3.25.76",
       "resolved": "https://registry.npmjs.org/zod/-/zod-3.25.76.tgz",
diff --git a/package.json b/package.json
index e888dac..ab59bbb 100644
--- a/package.json
+++ b/package.json
@@ -15,7 +15,7 @@
   ],
   "scripts": {
     "build": "tsc",
-    "test": "mocha -r ts-node/register 'test/**/*.test.ts'",
+    "test": "echo \"Error: no test specified\" && exit 1",
     "cli": "ts-node src/cli.ts",
     "start": "node dist/cli.js",
     "prepublishOnly": "npm run build",
@@ -26,13 +26,8 @@
   "license": "ISC",
   "type": "commonjs",
   "dependencies": {
-    "@types/blessed": "^0.1.27",
-    "@types/express": "^5.0.6",
-    "blessed": "^0.1.81",
-    "blessed-contrib": "^4.11.0",
     "commander": "^14.0.2",
     "enquirer": "^2.4.1",
-    "express": "^5.2.1",
     "https-proxy-agent": "^7.0.6",
     "proper-lockfile": "^4.1.2",
     "socks-proxy-agent": "^8.0.5",
@@ -40,12 +35,8 @@
     "zod": "^3.25.76"
   },
   "devDependencies": {
-    "@types/chai": "^4.3.20",
-    "@types/mocha": "^10.0.10",
     "@types/node": "^25.0.10",
     "@types/proper-lockfile": "^4.1.4",
-    "chai": "^4.5.0",
-    "mocha": "^11.7.5",
     "ts-node": "^10.9.2",
     "typescript": "^5.9.3"
   }
diff --git a/src/cli.js b/src/cli.js
new file mode 100644
index 0000000..6f765a4
--- /dev/null
+++ b/src/cli.js
@@ -0,0 +1,269 @@
+#!/usr/bin/env node
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+const commander_1 = require("commander");
+const index_1 = require("./index");
+const config_1 = require("./core/config");
+const storage_1 = require("./core/storage");
+const types_1 = require("./core/types");
+const quota_manager_1 = require("./core/quota-manager");
+const anthropic_1 = require("./providers/anthropic");
+const gemini_1 = require("./providers/gemini");
+const github_sync_1 = require("./utils/github-sync");
+const wizard_1 = require("./utils/wizard");
+async function main() {
+    const configManager = new config_1.ConfigManager();
+    const config = configManager.loadConfig();
+    const storageManager = new storage_1.StorageManager(configManager.getConfigDir());
+    const monster = (0, index_1.createAuthMonster)({
+        config,
+        storagePath: configManager.getConfigDir()
+    });
+    const program = new commander_1.Command();
+    program
+        .name('opencode-monster')
+        .description('CLI for OpenCode Auth Monster')
+        .version('1.0.0');
+    program.command('list')
+        .description('List all accounts, their providers, emails, and health scores')
+        .action(async () => {
+        await monster.init();
+        const accounts = monster.getAllAccountsStatus();
+        if (accounts.length === 0) {
+            console.log('No accounts found.');
+            return;
+        }
+        console.table(accounts.map(a => ({
+            id: a.id,
+            provider: a.provider,
+            email: a.email,
+            isHealthy: a.isHealthy,
+            healthScore: a.healthScore
+        })));
+    });
+    program.command('add')
+        .description('Add a new account')
+        .argument('<provider>', 'Provider (e.g., gemini, anthropic, cursor, etc.)')
+        .argument('[email]', 'Account email')
+        .argument('[token]', 'API Key or Access Token')
+        .option('-i, --interactive', 'Use interactive OAuth login')
+        .action(async (provider, email, token, options) => {
+        const authProvider = provider;
+        if (!Object.values(types_1.AuthProvider).includes(authProvider)) {
+            console.error(`Invalid provider: ${provider}. Valid providers are: ${Object.values(types_1.AuthProvider).join(', ')}`);
+            process.exit(1);
+        }
+        let accountEmail = email;
+        let accountTokens = { accessToken: token || '' };
+        let apiKey = authProvider === types_1.AuthProvider.Gemini ? token : undefined;
+        let metadata = {};
+        if (options.interactive) {
+            if (authProvider === types_1.AuthProvider.Anthropic) {
+                const result = await anthropic_1.AnthropicProvider.login();
+                accountTokens = result;
+                // For Anthropic we don't always get email from OAuth response in console mode easily without extra calls
+                // but let's assume we want user to provide it or we use 'interactive@anthropic'
+                if (!accountEmail) {
+                    accountEmail = 'interactive@anthropic.com';
+                }
+            }
+            else if (authProvider === types_1.AuthProvider.Gemini) {
+                const result = await gemini_1.GeminiProvider.login();
+                accountTokens = {
+                    accessToken: result.accessToken,
+                    refreshToken: result.refreshToken,
+                    expiryDate: result.expiryDate,
+                    tokenType: result.tokenType
+                };
+                accountEmail = result.email;
+                metadata = result.metadata || {};
+                apiKey = undefined; // Using OAuth
+            }
+            else {
+                console.error(`Interactive login not supported for provider: ${provider}`);
+                process.exit(1);
+            }
+        }
+        else if (!email || !token) {
+            console.error('Email and Token are required for non-interactive add.');
+            process.exit(1);
+        }
+        const account = {
+            id: Math.random().toString(36).substring(2, 11),
+            email: accountEmail,
+            provider: authProvider,
+            tokens: accountTokens,
+            apiKey,
+            metadata,
+            isHealthy: true,
+            healthScore: 100
+        };
+        await monster.addAccount(account);
+        console.log(`Account added successfully: ${accountEmail} (${provider})`);
+    });
+    program.command('delete')
+        .description('Remove an account')
+        .argument('<id>', 'Account ID')
+        .action(async (id) => {
+        await monster.deleteAccount(id);
+        console.log(`Account ${id} deleted.`);
+    });
+    program.command('status')
+        .description('Show general system health and current active provider')
+        .action(async () => {
+        console.log(`\n=== System Status ===`);
+        console.log(`Active Provider: ${config.active}`);
+        console.log(`Fallback Providers: ${config.fallback.join(', ') || 'None'}`);
+        console.log(`Rotation Method: ${config.method}`);
+        const accounts = await storageManager.loadAccounts();
+        const healthyCount = accounts.filter(a => a.isHealthy).length;
+        console.log(`Total Accounts: ${accounts.length}`);
+        console.log(`Healthy Accounts: ${healthyCount}`);
+    });
+    program.command('quota')
+        .description('Show detailed quota usage for all accounts')
+        .action(async () => {
+        const accounts = await storageManager.loadAccounts();
+        if (accounts.length === 0) {
+            console.log('No accounts found.');
+            return;
+        }
+        console.log('\n=== Quota Usage ===\n');
+        const tableData = accounts.map(a => {
+            let quotaInfo = 'Unlimited';
+            let cooldown = 'Active';
+            const quota = (0, quota_manager_1.extractQuota)(a);
+            if (quota.remaining < 1000) {
+                quotaInfo = `${quota.remaining.toFixed(1)}%`;
+            }
+            const cooldownStatus = (0, quota_manager_1.getCooldownStatus)(a.provider, a.id);
+            if (cooldownStatus.active && cooldownStatus.until) {
+                const minLeft = Math.ceil((cooldownStatus.until - Date.now()) / 60000);
+                cooldown = `Cooldown (${minLeft}m)`;
+            }
+            else if (a.cooldownUntil && a.cooldownUntil > Date.now()) {
+                const minLeft = Math.ceil((a.cooldownUntil - Date.now()) / 60000);
+                cooldown = `Cooldown (${minLeft}m)`;
+            }
+            else if (!a.isHealthy) {
+                cooldown = 'Unhealthy';
+            }
+            return {
+                ID: a.id.substring(0, 8),
+                Provider: a.provider,
+                Email: a.email,
+                Quota: quotaInfo,
+                Status: cooldown
+            };
+        });
+        console.table(tableData);
+    });
+    program.command('switch')
+        .description('Change the active provider in the config')
+        .argument('<provider>', 'Provider to switch to')
+        .action(async (provider) => {
+        const authProvider = provider;
+        if (!Object.values(types_1.AuthProvider).includes(authProvider)) {
+            console.error(`Invalid provider: ${provider}`);
+            process.exit(1);
+        }
+        configManager.setActiveProvider(authProvider);
+        console.log(`Switched active provider to: ${provider}`);
+    });
+    program.command('test')
+        .description('Attempt to get auth details for a provider and report if it works')
+        .argument('<provider>', 'Provider to test')
+        .action(async (provider) => {
+        const authProvider = provider;
+        if (!Object.values(types_1.AuthProvider).includes(authProvider)) {
+            console.error(`Invalid provider: ${provider}`);
+            process.exit(1);
+        }
+        await monster.init();
+        const details = await monster.getAuthDetails(authProvider);
+        if (details) {
+            console.log(`Success! Found working account for ${provider}:`);
+            console.log(`Email: ${details.account.email}`);
+            console.log(`ID: ${details.account.id}`);
+            console.log(`Headers:`, details.headers);
+        }
+        else {
+            console.log(`Failed to find a working account for ${provider}.`);
+        }
+    });
+    program.command('sync')
+        .description('Sync all accounts to a GitHub repository secrets')
+        .argument('<repo>', 'Target repository (owner/repo)')
+        .action(async (repo) => {
+        await monster.init();
+        const accounts = monster.getAccounts();
+        if (accounts.length === 0) {
+            console.log('No accounts to sync.');
+            return;
+        }
+        try {
+            await (0, github_sync_1.syncToGitHub)(repo, accounts);
+        }
+        catch (err) {
+            // Error already logged in syncToGitHub
+            process.exit(1);
+        }
+    });
+    program.command('onboard')
+        .alias('setup')
+        .description('Run interactive onboarding wizard to add accounts')
+        .action(async () => {
+        await monster.init();
+        await (0, wizard_1.runOnboardingWizard)(monster);
+    });
+    program.command('proxy')
+        .description('Set or view persistent proxy URL')
+        .argument('[url]', 'Proxy URL (e.g., http://user:pass@host:port or socks5://host:port). Pass "none" to disable.')
+        .action(async (url) => {
+        const currentConfig = configManager.loadConfig();
+        if (!url) {
+            console.log(`Current proxy: ${currentConfig.proxy || 'None'}`);
+            return;
+        }
+        if (url.toLowerCase() === 'none') {
+            currentConfig.proxy = undefined;
+            configManager.saveConfig(currentConfig);
+            console.log('Proxy disabled.');
+        }
+        else {
+            currentConfig.proxy = url;
+            configManager.saveConfig(currentConfig);
+            console.log(`Proxy set to: ${url}`);
+        }
+    });
+    program.command('fallback')
+        .description('Configure dynamic model fallbacks')
+        .argument('<model>', 'The primary model name')
+        .argument('[fallbacks...]', 'Ordered list of fallback models')
+        .option('--direction <up|down>', 'Fallback direction: up (smarter first) or down (cheaper first)', 'down')
+        .action(async (model, fallbacks, options) => {
+        const currentConfig = configManager.loadConfig();
+        if (!currentConfig.modelPriorities) {
+            currentConfig.modelPriorities = {};
+        }
+        if (fallbacks && fallbacks.length > 0) {
+            currentConfig.modelPriorities[model.toLowerCase()] = fallbacks.map((m) => m.toLowerCase());
+            console.log(`Fallback chain for ${model}: ${fallbacks.join(' -> ')}`);
+        }
+        else {
+            delete currentConfig.modelPriorities[model.toLowerCase()];
+            console.log(`Cleared fallbacks for ${model}`);
+        }
+        if (options.direction) {
+            currentConfig.fallbackDirection = options.direction;
+            console.log(`Fallback direction set to: ${options.direction}`);
+        }
+        configManager.saveConfig(currentConfig);
+        console.log('Configuration updated.');
+    });
+    await program.parseAsync(process.argv);
+}
+main().catch(err => {
+    console.error(err);
+    process.exit(1);
+});
diff --git a/src/cli.ts b/src/cli.ts
index 4dfe65f..a1a6ab6 100644
--- a/src/cli.ts
+++ b/src/cli.ts
@@ -5,20 +5,13 @@ import { ConfigManager } from './core/config';
 import { StorageManager } from './core/storage';
 import { AuthProvider, ManagedAccount, OAuthTokens } from './core/types';
 import { extractQuota, getCooldownStatus } from './core/quota-manager';
-import * as fs from 'fs';
-import * as path from 'path';
-import { execSync } from 'child_process';

-import { AnthropicProvider } from './providers/anthropic';
-import { GeminiProvider } from './providers/gemini';
-import { syncToGitHub } from './utils/github-sync';
-import { runOnboardingWizard } from './utils/wizard';
-import { startDashboard } from './ui/dashboard';
-import { startServer } from './server/index';
-import { DialecticsEngine } from './core/dialectics';
-import { getProviderEndpoint } from './core/endpoints';
+ import { AnthropicProvider } from './providers/anthropic';
+ import { GeminiProvider } from './providers/gemini';
+ import { syncToGitHub } from './utils/github-sync';
+ import { runOnboardingWizard } from './utils/wizard';

-async function main() {
+ async function main() {

   const configManager = new ConfigManager();
   const config = configManager.loadConfig();
@@ -218,8 +211,7 @@ async function main() {
     program.command('sync')
       .description('Sync all accounts to a GitHub repository secrets')
       .argument('<repo>', 'Target repository (owner/repo)')
-      .argument('[token]', 'GitHub Personal Access Token (optional, reads from GITHUB_TOKEN env)')
-      .action(async (repo, token) => {
+      .action(async (repo) => {
         await monster.init();
         const accounts = monster.getAccounts();
         if (accounts.length === 0) {
@@ -227,8 +219,9 @@ async function main() {
           return;
         }
         try {
-          await syncToGitHub(repo, accounts, token);
+          await syncToGitHub(repo, accounts);
         } catch (err: any) {
+          // Error already logged in syncToGitHub
           process.exit(1);
         }
       });
@@ -291,157 +284,6 @@ async function main() {
         console.log('Configuration updated.');
       });

-    program.command('dashboard')
-      .description('Launch the TUI Dashboard')
-      .action(async () => {
-        await monster.init();
-        startDashboard(monster);
-      });
-
-    program.command('server')
-      .description('Start the Web Admin Server')
-      .option('-p, --port <number>', 'Port to listen on', '3000')
-      .action(async (options) => {
-        await monster.init();
-        startServer(monster, parseInt(options.port));
-      });
-
-    program.command('dialectics')
-      .description('Run a dialectics session: split prompt between two models and synthesize.')
-      .argument('<prompt>', 'The prompt to process')
-      .option('-a, --model-a <model>', 'First model', 'gemini-3-flash-preview')
-      .option('-b, --model-b <model>', 'Second model', 'claude-3-7-sonnet-20250219')
-      .option('-s, --synthesizer <model>', 'Synthesizer model', 'gemini-3-pro-preview')
-      .action(async (prompt, options) => {
-          await monster.init();
-          const engine = new DialecticsEngine(monster);
-          try {
-              const result = await engine.synthesize(prompt, options.modelA, options.modelB, options.synthesizer);
-              console.log('\n=== Synthesis Result ===\n');
-              console.log(result);
-          } catch (error) {
-              console.error('Dialectics failed:', error);
-              process.exit(1);
-          }
-      });
-
-    program.command('install-hook')
-      .description('Install the prepare-commit-msg git hook')
-      .action(() => {
-          const gitDir = path.resolve(process.cwd(), '.git');
-          if (!fs.existsSync(gitDir)) {
-              console.error('Error: .git directory not found. Are you in a git repository?');
-              process.exit(1);
-          }
-
-          const hooksDir = path.join(gitDir, 'hooks');
-          if (!fs.existsSync(hooksDir)) {
-              fs.mkdirSync(hooksDir, { recursive: true });
-          }
-
-          const hookPath = path.join(hooksDir, 'prepare-commit-msg');
-
-          // Determine path to the script
-          const isTs = __filename.endsWith('.ts');
-          let scriptPath;
-          let runner;
-
-          if (isTs) {
-             scriptPath = path.resolve(__dirname, 'scripts/git-hook.ts');
-             runner = 'npx ts-node';
-          } else {
-             scriptPath = path.resolve(__dirname, 'scripts/git-hook.js');
-             runner = 'node';
-          }
-
-          const hookContent = `#!/bin/sh
-# OpenCode Auth Monster Hook
-${runner} "${scriptPath}" "$@"
-`;
-
-          fs.writeFileSync(hookPath, hookContent, { mode: 0o755 });
-          console.log(`Hook installed at ${hookPath}`);
-      });
-
-    program.command('review')
-      .description('Perform a code review on a file or git diff')
-      .argument('[file]', 'File to review (if omitted, reviews staged git diff)')
-      .option('-m, --model <model>', 'Model to use', 'claude-4.5-opus-thinking')
-      .action(async (file, options) => {
-          await monster.init();
-
-          let content = '';
-          if (file) {
-              try {
-                  content = fs.readFileSync(file, 'utf-8');
-              } catch (e) {
-                  console.error(`Could not read file: ${file}`);
-                  process.exit(1);
-              }
-          } else {
-              try {
-                  content = execSync('git diff --cached').toString();
-                  if (!content.trim()) {
-                      console.log('No staged changes to review.');
-                      return;
-                  }
-              } catch (e) {
-                  console.error('Error getting git diff. Are you in a git repo?');
-                  process.exit(1);
-              }
-          }
-
-          const prompt = `Please review the following code changes.
-          Focus on:
-          1. Bugs and potential runtime errors.
-          2. Security vulnerabilities.
-          3. Code style and best practices.
-          4. Performance improvements.
-
-          Code/Diff:
-          ${content.substring(0, 10000)}
-          `;
-
-          const details = await monster.getAuthDetails(options.model);
-          if (!details) {
-              console.error(`Could not resolve model: ${options.model}`);
-              process.exit(1);
-          }
-
-          // Use getProviderEndpoint utility
-          const url = getProviderEndpoint(details.provider, details.account, details.modelInProvider);
-
-          console.log(`Reviewing with ${options.model}...`);
-          try {
-             const response = await monster.request(options.model, url, {
-                  method: 'POST',
-                  headers: { 'Content-Type': 'application/json' },
-                  body: {
-                      messages: [{ role: 'user', content: prompt }],
-                      model: details.modelInProvider,
-                      temperature: 0.2
-                  }
-             });
-
-             const json = await response.json() as any;
-             let review = '';
-
-             if (details.provider === AuthProvider.Gemini) {
-                 review = json.candidates?.[0]?.content?.parts?.[0]?.text;
-             } else if (details.provider === AuthProvider.Anthropic) {
-                 review = json.content?.[0]?.text;
-             } else {
-                 review = json.choices?.[0]?.message?.content;
-             }
-
-             console.log('\n=== Code Review ===\n');
-             console.log(review || 'No review generated or error parsing response.');
-
-          } catch (error) {
-              console.error('Review failed:', error);
-          }
-      });
-
     await program.parseAsync(process.argv);

 }
diff --git a/src/core/config.js b/src/core/config.js
new file mode 100644
index 0000000..64ddd92
--- /dev/null
+++ b/src/core/config.js
@@ -0,0 +1,49 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.ConfigManager = void 0;
+const fs_1 = __importDefault(require("fs"));
+const path_1 = __importDefault(require("path"));
+const xdg_basedir_1 = require("xdg-basedir");
+const types_1 = require("./types");
+class ConfigManager {
+    constructor(customPath) {
+        this.configDir = customPath || path_1.default.join(xdg_basedir_1.xdgConfig || '', 'opencode');
+        if (!fs_1.default.existsSync(this.configDir)) {
+            fs_1.default.mkdirSync(this.configDir, { recursive: true });
+        }
+        this.configPath = path_1.default.join(this.configDir, 'auth-monster-config.json');
+    }
+    getConfigDir() {
+        return this.configDir;
+    }
+    loadConfig() {
+        if (!fs_1.default.existsSync(this.configPath)) {
+            return types_1.AuthMonsterConfigSchema.parse({});
+        }
+        try {
+            const data = fs_1.default.readFileSync(this.configPath, 'utf8');
+            const parsed = JSON.parse(data);
+            return types_1.AuthMonsterConfigSchema.parse(parsed);
+        }
+        catch (error) {
+            console.error('Failed to load config, using defaults:', error);
+            return types_1.AuthMonsterConfigSchema.parse({});
+        }
+    }
+    saveConfig(config) {
+        const dir = path_1.default.dirname(this.configPath);
+        if (!fs_1.default.existsSync(dir)) {
+            fs_1.default.mkdirSync(dir, { recursive: true });
+        }
+        fs_1.default.writeFileSync(this.configPath, JSON.stringify(config, null, 2), 'utf8');
+    }
+    setActiveProvider(provider) {
+        const config = this.loadConfig();
+        config.active = provider;
+        this.saveConfig(config);
+    }
+}
+exports.ConfigManager = ConfigManager;
diff --git a/src/core/cost-estimator.ts b/src/core/cost-estimator.ts
deleted file mode 100644
index b262aab..0000000
--- a/src/core/cost-estimator.ts
+++ /dev/null
@@ -1,62 +0,0 @@
-export interface ModelPricing {
-  inputCostPer1M: number;
-  outputCostPer1M: number;
-}
-
-const DEFAULT_PRICING: ModelPricing = { inputCostPer1M: 0, outputCostPer1M: 0 };
-
-const PRICING_TABLE: Record<string, ModelPricing> = {
-  // Gemini
-  'gemini-1.5-flash': { inputCostPer1M: 0.075, outputCostPer1M: 0.30 },
-  'gemini-1.5-pro': { inputCostPer1M: 3.50, outputCostPer1M: 10.50 },
-  'gemini-2.0-flash': { inputCostPer1M: 0.10, outputCostPer1M: 0.40 }, // Estimated
-
-  // Anthropic
-  'claude-3-5-sonnet': { inputCostPer1M: 3.00, outputCostPer1M: 15.00 },
-  'claude-3-haiku': { inputCostPer1M: 0.25, outputCostPer1M: 1.25 },
-  'claude-3-opus': { inputCostPer1M: 15.00, outputCostPer1M: 75.00 },
-  'claude-4.5-opus-thinking': { inputCostPer1M: 20.00, outputCostPer1M: 100.00 }, // Estimated
-
-  // OpenAI
-  'gpt-4o': { inputCostPer1M: 5.00, outputCostPer1M: 15.00 },
-  'gpt-4o-mini': { inputCostPer1M: 0.15, outputCostPer1M: 0.60 },
-  'o1-preview': { inputCostPer1M: 15.00, outputCostPer1M: 60.00 },
-  'o1-mini': { inputCostPer1M: 3.00, outputCostPer1M: 12.00 },
-
-  // Generic Fallbacks
-  'gpt-4': { inputCostPer1M: 30.00, outputCostPer1M: 60.00 },
-  'gpt-3.5-turbo': { inputCostPer1M: 0.50, outputCostPer1M: 1.50 },
-  'gpt-5.2-pro': { inputCostPer1M: 10.00, outputCostPer1M: 30.00 },
-};
-
-export class CostEstimator {
-  /**
-   * Calculates the cost in USD for a given model and token usage.
-   */
-  static calculateCost(model: string, inputTokens: number, outputTokens: number): number {
-    const pricing = this.getPricing(model);
-    const inputCost = (inputTokens / 1_000_000) * pricing.inputCostPer1M;
-    const outputCost = (outputTokens / 1_000_000) * pricing.outputCostPer1M;
-    return inputCost + outputCost;
-  }
-
-  /**
-   * Estimates token count based on character count (heuristic: ~4 chars per token).
-   */
-  static estimateTokens(text: string): number {
-    if (!text) return 0;
-    return Math.ceil(text.length / 4);
-  }
-
-  private static getPricing(model: string): ModelPricing {
-    // Exact match
-    if (PRICING_TABLE[model]) return PRICING_TABLE[model];
-
-    // Fuzzy match / Substring match
-    // e.g. "claude-3-5-sonnet-20241022" should match "claude-3-5-sonnet"
-    const key = Object.keys(PRICING_TABLE).find(k => model.includes(k));
-    if (key) return PRICING_TABLE[key];
-
-    return DEFAULT_PRICING;
-  }
-}
diff --git a/src/core/dialectics.ts b/src/core/dialectics.ts
deleted file mode 100644
index 357986c..0000000
--- a/src/core/dialectics.ts
+++ /dev/null
@@ -1,103 +0,0 @@
-import { AuthProvider } from './types';
-import { getProviderEndpoint } from './endpoints';
-
-export interface IAuthMonster {
-  request(model: string, url: string, options: any): Promise<Response>;
-  getAuthDetails(modelOrProvider?: string | AuthProvider): Promise<any>;
-}
-
-export class DialecticsEngine {
-  constructor(private monster: IAuthMonster) {}
-
-  async synthesize(prompt: string, modelA: string, modelB: string, synthesizerModel: string): Promise<string> {
-    // 1. Get Details and URLs
-    const detailsA = await this.monster.getAuthDetails(modelA);
-    const detailsB = await this.monster.getAuthDetails(modelB);
-
-    if (!detailsA) throw new Error(`Could not resolve model: ${modelA}`);
-    if (!detailsB) throw new Error(`Could not resolve model: ${modelB}`);
-
-    const urlA = getProviderEndpoint(detailsA.provider, detailsA.account, detailsA.modelInProvider);
-    const urlB = getProviderEndpoint(detailsB.provider, detailsB.account, detailsB.modelInProvider);
-
-    // 2. Prepare Requests
-    const body = {
-        messages: [{ role: 'user', content: prompt }],
-        model: detailsA.modelInProvider, // Some providers need model in body
-        temperature: 0.7
-    };
-    const bodyB = {
-        messages: [{ role: 'user', content: prompt }],
-        model: detailsB.modelInProvider,
-        temperature: 0.7
-    };
-
-    // 3. Send Requests
-    console.log(`[Dialectics] Sending to ${modelA} (${detailsA.provider}) and ${modelB} (${detailsB.provider})...`);
-
-    const [resA, resB] = await Promise.all([
-        this.monster.request(modelA, urlA, {
-            method: 'POST',
-            headers: { 'Content-Type': 'application/json' },
-            body: body
-        }).then(r => r.json().catch(e => ({ error: 'JSON Parse Error', details: e }))),
-
-        this.monster.request(modelB, urlB, {
-            method: 'POST',
-            headers: { 'Content-Type': 'application/json' },
-            body: bodyB
-        }).then(r => r.json().catch(e => ({ error: 'JSON Parse Error', details: e })))
-    ]);
-
-    // 4. Extract Content
-    const contentA = this.extractContent(detailsA.provider, resA);
-    const contentB = this.extractContent(detailsB.provider, resB);
-
-    // 5. Synthesize
-    const synthesisPrompt = `
-I have two responses to the following prompt: "${prompt}"
-
-=== Response A (${modelA}) ===
-${contentA}
-
-=== Response B (${modelB}) ===
-${contentB}
-
-Please synthesize these two responses into a single, comprehensive answer.
-`;
-
-    const detailsC = await this.monster.getAuthDetails(synthesizerModel);
-    if (!detailsC) throw new Error(`Could not resolve synthesizer model: ${synthesizerModel}`);
-
-    const urlC = getProviderEndpoint(detailsC.provider, detailsC.account, detailsC.modelInProvider);
-
-    console.log(`[Dialectics] Synthesizing with ${synthesizerModel} (${detailsC.provider})...`);
-
-    const resC = await this.monster.request(synthesizerModel, urlC, {
-        method: 'POST',
-        headers: { 'Content-Type': 'application/json' },
-        body: {
-            messages: [{ role: 'user', content: synthesisPrompt }],
-            model: detailsC.modelInProvider
-        }
-    });
-
-    const jsonC = await resC.json();
-    return this.extractContent(detailsC.provider, jsonC);
-  }
-
-  private extractContent(provider: AuthProvider, response: any): string {
-      if (!response) return "No response";
-      if (response.error) return `Error: ${JSON.stringify(response.error)}`;
-
-      if (provider === AuthProvider.Gemini) {
-          return response.candidates?.[0]?.content?.parts?.[0]?.text || JSON.stringify(response);
-      }
-      if (provider === AuthProvider.Anthropic) {
-          return response.content?.[0]?.text || JSON.stringify(response);
-      }
-
-      // Default OpenAI structure (used by OpenAI, Grok, DeepSeek, etc.)
-      return response.choices?.[0]?.message?.content || JSON.stringify(response);
-  }
-}
diff --git a/src/core/endpoints.ts b/src/core/endpoints.ts
deleted file mode 100644
index 58c656e..0000000
--- a/src/core/endpoints.ts
+++ /dev/null
@@ -1,45 +0,0 @@
-import { AuthProvider, ManagedAccount } from './types';
-
-export function getProviderEndpoint(provider: AuthProvider, account?: ManagedAccount, model?: string): string {
-  switch (provider) {
-    case AuthProvider.Anthropic:
-      return account?.apiKey
-        ? "https://api.anthropic.com/v1/messages"
-        : "https://console.anthropic.com/api/v1/messages";
-    case AuthProvider.Gemini:
-       // Gemini requires model in URL often
-       const modelName = model || account?.metadata?.model || 'gemini-2.0-flash';
-       return `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent`;
-    case AuthProvider.OpenAI:
-    case AuthProvider.Copilot: // Copilot is often OpenAI compatible or routed via GitHub
-      return "https://api.openai.com/v1/chat/completions";
-    case AuthProvider.Qwen:
-        return "https://dashscope.aliyuncs.com/compatible-mode/v1/chat/completions";
-    case AuthProvider.Zhipu:
-        return "https://open.bigmodel.cn/api/paas/v4/chat/completions";
-    case AuthProvider.Minimax:
-        return "https://api.minimax.chat/v1/text/chatcompletion_v2";
-
-    // New Providers
-    case AuthProvider.DeepSeek:
-        return "https://api.deepseek.com/chat/completions";
-    case AuthProvider.Grok:
-        return "https://api.x.ai/v1/chat/completions";
-    case AuthProvider.Azure:
-        if (account?.metadata?.resourceName && account?.metadata?.deploymentId) {
-            return `https://${account.metadata.resourceName}.openai.azure.com/openai/deployments/${account.metadata.deploymentId}/chat/completions?api-version=2023-05-15`;
-        }
-        return "https://api.openai.azure.com/";
-
-    // For Cursor and Windsurf, since they use gRPC/Proto and AuthMonster doesn't fully abstract the protocol conversion
-    // from JSON to Proto for 'request()', we might return a dummy URL or handle it if we knew the JSON proxy.
-    // For now, we return a URL that might work if there's a JSON bridge, otherwise it might fail.
-    case AuthProvider.Cursor:
-       return "https://api2.cursor.sh/llm/chat";
-    case AuthProvider.Windsurf:
-        return "https://codeium.com/api/v1/chat";
-
-    default:
-      return "https://api.openai.com/v1/chat/completions";
-  }
-}
diff --git a/src/core/history.ts b/src/core/history.ts
deleted file mode 100644
index d132122..0000000
--- a/src/core/history.ts
+++ /dev/null
@@ -1,73 +0,0 @@
-import fs from 'fs';
-import path from 'path';
-import { Redactor } from './redactor';
-
-export interface HistoryEntry {
-  timestamp: number;
-  model: string;
-  provider: string;
-  accountId: string;
-  tokens?: {
-    input: number;
-    output: number;
-  };
-  cost?: number;
-  request: any;
-  response: any;
-  durationMs: number;
-  success: boolean;
-  error?: string;
-}
-
-export class HistoryManager {
-  private filePath: string;
-
-  constructor(storagePath: string) {
-    this.filePath = path.join(storagePath, 'history.jsonl');
-  }
-
-  async addEntry(entry: Omit<HistoryEntry, 'timestamp'>): Promise<void> {
-    const fullEntry: HistoryEntry = {
-      timestamp: Date.now(),
-      ...entry
-    };
-
-    const redactedEntry = Redactor.redact(fullEntry);
-    const line = JSON.stringify(redactedEntry) + '\n';
-
-    try {
-      // Ensure directory exists
-      const dir = path.dirname(this.filePath);
-      if (!fs.existsSync(dir)) {
-        await fs.promises.mkdir(dir, { recursive: true });
-      }
-
-      await fs.promises.appendFile(this.filePath, line, 'utf8');
-    } catch (error) {
-      console.error('[HistoryManager] Failed to write history:', error);
-    }
-  }
-
-  // Basic query support (e.g. for replay)
-  async getRecentEntries(limit: number = 50): Promise<HistoryEntry[]> {
-    try {
-        if (!fs.existsSync(this.filePath)) return [];
-        const content = await fs.promises.readFile(this.filePath, 'utf8');
-        const lines = content.trim().split('\n');
-        return lines
-            .slice(-limit)
-            .map(line => {
-                try {
-                    return JSON.parse(line);
-                } catch {
-                    return null;
-                }
-            })
-            .filter((e): e is HistoryEntry => e !== null)
-            .reverse(); // Newest first
-    } catch (error) {
-        console.error('[HistoryManager] Failed to read history:', error);
-        return [];
-    }
-  }
-}
diff --git a/src/core/hub.js b/src/core/hub.js
new file mode 100644
index 0000000..a2b192c
--- /dev/null
+++ b/src/core/hub.js
@@ -0,0 +1,293 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.UnifiedModelHub = void 0;
+const types_1 = require("./types");
+const thinking_validator_1 = require("./thinking-validator");
+const quota_manager_1 = require("./quota-manager");
+/**
+ * UnifiedModelHub manages the mapping between generic model names
+ * and the pool of providers/accounts that can serve them.
+ *
+ * It implements global load balancing across different providers
+ * based on health, quota, and PID-based offsets.
+ */
+class UnifiedModelHub {
+    constructor() {
+        this.modelMap = new Map();
+        this.initializeDefaultMappings();
+    }
+    /**
+     * Set up default mappings for common models.
+     * In a real-world scenario, this could be loaded from a config file.
+     */
+    initializeDefaultMappings() {
+        // Gemini 3 Flash & Pro
+        this.addMapping('gemini-3-flash-preview', [
+            { provider: types_1.AuthProvider.Gemini, modelInProvider: 'gemini-3-flash' },
+            { provider: types_1.AuthProvider.Windsurf, modelInProvider: 'gemini-3-flash' },
+            { provider: types_1.AuthProvider.Kiro, modelInProvider: 'gemini-3-flash' }
+        ]);
+        this.addMapping('gemini-3-pro-preview', [
+            { provider: types_1.AuthProvider.Gemini, modelInProvider: 'gemini-3-pro' },
+            { provider: types_1.AuthProvider.Windsurf, modelInProvider: 'gemini-3-pro' }
+        ]);
+        // Claude 4.5 Opus (Thinking)
+        this.addMapping('claude-4.5-opus-thinking', [
+            { provider: types_1.AuthProvider.Anthropic, modelInProvider: 'claude-4.5-opus-thinking' },
+            { provider: types_1.AuthProvider.Windsurf, modelInProvider: 'claude-4.5-opus' },
+            { provider: types_1.AuthProvider.Cursor, modelInProvider: 'claude-4.5-opus' }
+        ]);
+        // GPT-5.2 Codex
+        this.addMapping('gpt-5.2-codex', [
+            { provider: types_1.AuthProvider.OpenAI, modelInProvider: 'gpt-5.2-codex' },
+            { provider: types_1.AuthProvider.Windsurf, modelInProvider: 'gpt-5.2-codex' },
+            { provider: types_1.AuthProvider.Copilot, modelInProvider: 'gpt-5.2-codex' }
+        ]);
+        // NEW HARVESTED MODELS (Mark III)
+        // Claude 3.7 Sonnet (Latest)
+        this.addMapping('claude-3-7-sonnet-20250219', [
+            { provider: types_1.AuthProvider.Anthropic, modelInProvider: 'claude-3-7-sonnet-20250219' },
+            { provider: types_1.AuthProvider.Windsurf, modelInProvider: 'claude-3-7-sonnet' },
+            { provider: types_1.AuthProvider.Cursor, modelInProvider: 'claude-3.7-sonnet' }
+        ]);
+        // Claude 4.5 Sonnet (Internal ID -> Provider ID)
+        this.addMapping('claude-sonnet-4-5', [
+            { provider: types_1.AuthProvider.Anthropic, modelInProvider: 'CLAUDE_SONNET_4_5_20250929_V1_0' },
+            { provider: types_1.AuthProvider.Cursor, modelInProvider: 'claude-4.5-sonnet' }
+        ]);
+        // DeepSeek R1 (Reasoning)
+        this.addMapping('deepseek-r1', [
+            { provider: types_1.AuthProvider.Qwen, modelInProvider: 'deepseek-r1' }, // Qwen provider often proxies DeepSeek
+            { provider: types_1.AuthProvider.Windsurf, modelInProvider: 'deepseek-reasoner' }
+        ]);
+        // Qwen 3 Coder Plus
+        this.addMapping('qwen3-coder-plus', [
+            { provider: types_1.AuthProvider.Qwen, modelInProvider: 'qwen3-coder-plus' }
+        ]);
+        // --- MARK VI: EXPANSION (Protocol: NET_CRAWLER) ---
+        // Anthropic: Claude 4.5 Haiku
+        this.addMapping('claude-haiku-4-5', [
+            { provider: types_1.AuthProvider.Anthropic, modelInProvider: 'claude-haiku-4-5-20251001' },
+            { provider: types_1.AuthProvider.Windsurf, modelInProvider: 'claude-haiku-4.5' }
+        ]);
+        // Gemini: 2.5 Family (The "Workhorse" Suite)
+        this.addMapping('gemini-2.5-pro', [
+            { provider: types_1.AuthProvider.Gemini, modelInProvider: 'gemini-2.5-pro' },
+            { provider: types_1.AuthProvider.Windsurf, modelInProvider: 'gemini-2.5-pro' }
+        ]);
+        this.addMapping('gemini-2.5-flash', [
+            { provider: types_1.AuthProvider.Gemini, modelInProvider: 'gemini-2.5-flash' },
+            { provider: types_1.AuthProvider.Windsurf, modelInProvider: 'gemini-2.5-flash' }
+        ]);
+        this.addMapping('gemini-2.5-flash-lite', [
+            { provider: types_1.AuthProvider.Gemini, modelInProvider: 'gemini-2.5-flash-lite' }
+        ]);
+        this.addMapping('gemini-2.5-flash-image', [
+            { provider: types_1.AuthProvider.Gemini, modelInProvider: 'gemini-2.5-flash-image' }
+        ]);
+        // OpenAI: GPT-5 Family
+        this.addMapping('gpt-5.2-pro', [
+            { provider: types_1.AuthProvider.OpenAI, modelInProvider: 'gpt-5.2-pro' },
+            { provider: types_1.AuthProvider.Copilot, modelInProvider: 'gpt-5.2-pro' }
+        ]);
+        this.addMapping('gpt-5-mini', [
+            { provider: types_1.AuthProvider.OpenAI, modelInProvider: 'gpt-5-mini' }
+        ]);
+        this.addMapping('gpt-5-nano', [
+            { provider: types_1.AuthProvider.OpenAI, modelInProvider: 'gpt-5-nano' }
+        ]);
+        // OpenAI: Deep Research (Reasoning)
+        this.addMapping('o3-deep-research', [
+            { provider: types_1.AuthProvider.OpenAI, modelInProvider: 'o3-deep-research' }
+        ]);
+        this.addMapping('o4-mini-deep-research', [
+            { provider: types_1.AuthProvider.OpenAI, modelInProvider: 'o4-mini-deep-research' }
+        ]);
+        // OpenAI: Sora (Video)
+        this.addMapping('sora-2', [
+            { provider: types_1.AuthProvider.OpenAI, modelInProvider: 'sora-2' }
+        ]);
+        this.addMapping('sora-2-pro', [
+            { provider: types_1.AuthProvider.OpenAI, modelInProvider: 'sora-2-pro' }
+        ]);
+        // DeepSeek: V3.2 Exp
+        this.addMapping('deepseek-v3.2-exp', [
+            { provider: types_1.AuthProvider.Qwen, modelInProvider: 'deepseek-v3.2-exp' } // Via Qwen Proxy
+        ]);
+        // Qwen Models
+        this.addMapping('qwen-max', [
+            { provider: types_1.AuthProvider.Qwen, modelInProvider: 'qwen-max' }
+        ]);
+        this.addMapping('qwen-plus', [
+            { provider: types_1.AuthProvider.Qwen, modelInProvider: 'qwen-plus' }
+        ]);
+        this.addMapping('qwen-turbo', [
+            { provider: types_1.AuthProvider.Qwen, modelInProvider: 'qwen-turbo' }
+        ]);
+        // iFlow Models
+        this.addMapping('iflow-chat', [
+            { provider: types_1.AuthProvider.IFlow, modelInProvider: 'iflow-chat' }
+        ]);
+        // Kiro (AWS) Models
+        this.addMapping('codewhisperer', [
+            { provider: types_1.AuthProvider.Kiro, modelInProvider: 'codewhisperer-analysis' }
+        ]);
+        this.addMapping('amazon-q-dev', [
+            { provider: types_1.AuthProvider.Kiro, modelInProvider: 'amazon-q-developer' }
+        ]);
+    }
+    /**
+     * Resolves the chain of models to try for a request, based on fallback configuration.
+     *
+     * @param requestedModel The initial model requested
+     * @param config The current AuthMonster configuration
+     * @returns Ordered array of models to attempt
+     */
+    resolveModelChain(requestedModel, config) {
+        const modelName = requestedModel.toLowerCase();
+        const fallbacks = config.modelPriorities[modelName] || [];
+        // The chain starts with the requested model
+        const chain = [modelName, ...fallbacks];
+        // Handle directionality if requested (though usually fallbacks are already ordered)
+        // If 'up', we might want to prioritize smarter models in the fallbacks.
+        // However, the prompt says "ordered array of fallback models" in config,
+        // so we'll respect that order mostly.
+        if (config.fallbackDirection === 'up') {
+            // In a real implementation, we might have a 'smarts' score for each model.
+            // For now, we'll assume the user-provided order is what they want,
+            // but let's just make sure we don't have duplicates.
+            return Array.from(new Set(chain));
+        }
+        return Array.from(new Set(chain));
+    }
+    /**
+     * Adds or updates a mapping for a generic model name.
+     */
+    addMapping(modelName, entries) {
+        this.modelMap.set(modelName.toLowerCase(), entries);
+    }
+    /**
+     * Validates and normalizes request parameters, particularly thinking budget.
+     */
+    validateRequest(provider, modelId, thinking) {
+        if (thinking === undefined)
+            return { valid: true };
+        return (0, thinking_validator_1.validateThinking)(provider, modelId, thinking);
+    }
+    /**
+     * Selects the best (Provider, Account) combination to serve a request for a model.
+     * Uses fallback chain if primary model has no available accounts.
+     *
+     * @param modelName Generic model name (e.g., 'gemini-3-flash-preview')
+     * @param allAccounts List of all managed accounts across all providers
+     * @param config Optional config to resolve fallbacks
+     * @returns The selected provider, account, and provider-specific model name
+     */
+    selectModelAccount(modelName, allAccounts, config) {
+        let modelsToTry = [modelName];
+        // If config is provided, resolve the full fallback chain
+        if (config) {
+            modelsToTry = this.resolveModelChain(modelName, config);
+        }
+        for (const model of modelsToTry) {
+            const selection = this.attemptSelectModelAccount(model, allAccounts);
+            if (selection) {
+                return selection;
+            }
+        }
+        return null;
+    }
+    attemptSelectModelAccount(modelName, allAccounts) {
+        const hubEntries = this.modelMap.get(modelName.toLowerCase());
+        // If no explicit mapping, we can't route via Hub
+        if (!hubEntries)
+            return null;
+        // 1. Gather all candidates (Account + Provider Model Info)
+        const candidates = [];
+        for (const entry of hubEntries) {
+            const providerAccounts = allAccounts.filter(a => a.provider === entry.provider);
+            for (const account of providerAccounts) {
+                // Filter out unhealthy or rate-limited accounts
+                if (!this.isAccountUsable(account))
+                    continue;
+                const remainingQuota = this.getRemainingQuota(account, entry.modelInProvider);
+                const healthScore = account.healthScore ?? 70;
+                candidates.push({
+                    provider: entry.provider,
+                    account,
+                    modelInProvider: entry.modelInProvider,
+                    score: healthScore,
+                    remainingQuota
+                });
+            }
+        }
+        if (candidates.length === 0)
+            return null;
+        // 2. Global Load Balancing Logic
+        candidates.sort((a, b) => {
+            // 0. Quota availability (Binary check: Does it have any quota left?)
+            const hasQuotaA = a.remainingQuota > 0 ? 1 : 0;
+            const hasQuotaB = b.remainingQuota > 0 ? 1 : 0;
+            if (hasQuotaA !== hasQuotaB) {
+                return hasQuotaB - hasQuotaA;
+            }
+            // Primary: Health Score (with 5-point buffer to allow secondary sorting)
+            if (Math.abs(a.score - b.score) > 5) {
+                return b.score - a.score;
+            }
+            // Secondary: Quota availability (fine-grained)
+            if (a.remainingQuota !== b.remainingQuota) {
+                return b.remainingQuota - a.remainingQuota;
+            }
+            // Tertiary: PID-based offset to prevent parallel collisions
+            // We use a combination of account ID hash and PID
+            const hashA = this.simpleHash(a.account.id) + process.pid;
+            const hashB = this.simpleHash(b.account.id) + process.pid;
+            return (hashA % 100) - (hashB % 100);
+        });
+        const choice = candidates[0];
+        return {
+            provider: choice.provider,
+            account: choice.account,
+            modelInProvider: choice.modelInProvider
+        };
+    }
+    /**
+     * Basic usability check for an account
+     */
+    isAccountUsable(account) {
+        const now = Date.now();
+        if (account.rateLimitResetTime && now < account.rateLimitResetTime)
+            return false;
+        if (account.cooldownUntil && now < account.cooldownUntil)
+            return false;
+        if ((0, quota_manager_1.isOnCooldown)(account.provider, account.id))
+            return false;
+        if (account.healthScore !== undefined && account.healthScore < 50)
+            return false; // MIN_USABLE
+        return account.isHealthy !== false;
+    }
+    /**
+     * Retrieves remaining quota for a specific model on an account
+     */
+    getRemainingQuota(account, model) {
+        if (!account.quota)
+            return 1000; // Default high value if untracked
+        if (account.quota.modelSpecific?.[model]) {
+            return account.quota.modelSpecific[model].remaining;
+        }
+        return account.quota.remaining;
+    }
+    /**
+     * Simple string hash for tie-breaking
+     */
+    simpleHash(s) {
+        let hash = 0;
+        for (let i = 0; i < s.length; i++) {
+            hash = ((hash << 5) - hash) + s.charCodeAt(i);
+            hash |= 0; // Convert to 32bit integer
+        }
+        return Math.abs(hash);
+    }
+}
+exports.UnifiedModelHub = UnifiedModelHub;
diff --git a/src/core/mcp-bridge.js b/src/core/mcp-bridge.js
new file mode 100644
index 0000000..2a56e71
--- /dev/null
+++ b/src/core/mcp-bridge.js
@@ -0,0 +1,127 @@
+"use strict";
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+    Object.defineProperty(o, "default", { enumerable: true, value: v });
+}) : function(o, v) {
+    o["default"] = v;
+});
+var __importStar = (this && this.__importStar) || (function () {
+    var ownKeys = function(o) {
+        ownKeys = Object.getOwnPropertyNames || function (o) {
+            var ar = [];
+            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
+            return ar;
+        };
+        return ownKeys(o);
+    };
+    return function (mod) {
+        if (mod && mod.__esModule) return mod;
+        var result = {};
+        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
+        __setModuleDefault(result, mod);
+        return result;
+    };
+})();
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.MCPBridge = void 0;
+const child_process_1 = require("child_process");
+const path = __importStar(require("path"));
+const os = __importStar(require("os"));
+const fs = __importStar(require("fs"));
+class MCPBridge {
+    constructor(tokenPath) {
+        this.child = null;
+        this.tokenPath = tokenPath || path.join(os.homedir(), '.auth-mcp-token.json');
+    }
+    /**
+     * Starts the auth-mcp server process.
+     * Assumes `auth-mcp` is in the PATH or references/auth-mcp/auth-mcp exists.
+     */
+    start() {
+        const binPath = path.resolve(__dirname, '../../references/auth-mcp/auth-mcp');
+        // In a real scenario, we might prefer a configured path
+        // For now, we spawn it as a node process directly if possible, or use the wrapper
+        // Check if bin exists, else fallback
+        const cmd = fs.existsSync(binPath) ? binPath : 'auth-mcp';
+        this.child = (0, child_process_1.spawn)(cmd, [], {
+            stdio: ['pipe', 'pipe', 'pipe'],
+            env: process.env
+        });
+        this.child.stderr?.on('data', (data) => {
+            // Log MCP debug output
+            // console.error(`[MCP] ${data.toString()}`);
+        });
+        this.child.on('close', (code) => {
+            // console.log(`[MCP] exited with code ${code}`);
+            this.child = null;
+        });
+    }
+    /**
+     * Performs the JSON-RPC handshake to initialize the session.
+     */
+    async initialize() {
+        return new Promise((resolve, reject) => {
+            if (!this.child || !this.child.stdin || !this.child.stdout) {
+                return reject(new Error('MCP server not running'));
+            }
+            const initMsg = {
+                jsonrpc: '2.0',
+                id: 1,
+                method: 'initialize',
+                params: {
+                    protocolVersion: '2024-11-05',
+                    capabilities: {},
+                    clientInfo: { name: 'opencode-monster', version: '1.0.0' }
+                }
+            };
+            const handler = (chunk) => {
+                const msg = chunk.toString();
+                try {
+                    const json = JSON.parse(msg);
+                    if (json.id === 1 && json.result) {
+                        this.child?.stdout?.off('data', handler);
+                        resolve();
+                    }
+                }
+                catch (e) {
+                    // Ignore partial chunks for this simple MVP
+                }
+            };
+            this.child.stdout.on('data', handler);
+            this.child.stdin.write(JSON.stringify(initMsg) + '\n');
+            // Timeout
+            setTimeout(() => {
+                this.child?.stdout?.off('data', handler);
+                reject(new Error('MCP handshake timeout'));
+            }, 5000);
+        });
+    }
+    /**
+     * Reads the token generated/stored by the MCP server.
+     */
+    getToken() {
+        if (!fs.existsSync(this.tokenPath))
+            return null;
+        try {
+            const data = JSON.parse(fs.readFileSync(this.tokenPath, 'utf8'));
+            return data.token || null;
+        }
+        catch {
+            return null;
+        }
+    }
+    stop() {
+        this.child?.kill();
+    }
+}
+exports.MCPBridge = MCPBridge;
diff --git a/src/core/proxy.js b/src/core/proxy.js
new file mode 100644
index 0000000..fc6f293
--- /dev/null
+++ b/src/core/proxy.js
@@ -0,0 +1,70 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.globalProxyManager = exports.ProxyManager = void 0;
+exports.proxyFetch = proxyFetch;
+const https_proxy_agent_1 = require("https-proxy-agent");
+const socks_proxy_agent_1 = require("socks-proxy-agent");
+const config_1 = require("./config");
+class ProxyManager {
+    constructor(configManager) {
+        this.configManager = configManager || new config_1.ConfigManager();
+    }
+    getProxyUrl() {
+        let config;
+        try {
+            config = this.configManager.loadConfig();
+        }
+        catch (e) {
+            // Fallback if config manager fails during early init
+        }
+        // 1. Check global config
+        if (config?.proxy) {
+            return config.proxy;
+        }
+        // 2. Check environment variables
+        return process.env.HTTPS_PROXY ||
+            process.env.https_proxy ||
+            process.env.HTTP_PROXY ||
+            process.env.http_proxy ||
+            process.env.ALL_PROXY ||
+            process.env.all_proxy;
+    }
+    getAgent(url) {
+        const proxyUrl = this.getProxyUrl();
+        if (!proxyUrl)
+            return undefined;
+        if (proxyUrl.startsWith('socks')) {
+            return new socks_proxy_agent_1.SocksProxyAgent(proxyUrl);
+        }
+        return new https_proxy_agent_1.HttpsProxyAgent(proxyUrl);
+    }
+}
+exports.ProxyManager = ProxyManager;
+exports.globalProxyManager = new ProxyManager();
+/**
+ * Standard fetch wrapper that respects proxy settings.
+ * Handles both SOCKS and HTTP/HTTPS proxies.
+ */
+async function proxyFetch(url, init) {
+    const proxyUrl = exports.globalProxyManager.getProxyUrl();
+    if (!proxyUrl) {
+        return fetch(url, init);
+    }
+    const agent = exports.globalProxyManager.getAgent(url.toString());
+    const newInit = { ...init };
+    if (agent) {
+        // For node-fetch, cross-fetch, and other libraries that support 'agent'
+        newInit.agent = agent;
+        // For Node.js native fetch (undici), it uses 'dispatcher' instead of 'agent'.
+        // However, undici's ProxyAgent is different from https-proxy-agent.
+        // To support native fetch with a proxy, we'd ideally use undici.ProxyAgent.
+        // But since the user requested https-proxy-agent and socks-proxy-agent,
+        // we assume they might be using a fetch implementation that supports 'agent'
+        // or we are providing this for compatibility.
+        // If we want to support native fetch's dispatcher, we'd need:
+        // import { ProxyAgent } from 'undici';
+        // newInit.dispatcher = new ProxyAgent(proxyUrl);
+        // But SOCKS isn't easily supported there without extra work.
+    }
+    return fetch(url, newInit);
+}
diff --git a/src/core/quota-manager.js b/src/core/quota-manager.js
new file mode 100644
index 0000000..54942d4
--- /dev/null
+++ b/src/core/quota-manager.js
@@ -0,0 +1,166 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.getCachedQuota = getCachedQuota;
+exports.setCachedQuota = setCachedQuota;
+exports.isOnCooldown = isOnCooldown;
+exports.getCooldownStatus = getCooldownStatus;
+exports.applyCooldown = applyCooldown;
+exports.extractQuota = extractQuota;
+exports.findHealthyAccount = findHealthyAccount;
+exports.preflightCheck = preflightCheck;
+// ============================================================================
+// QUOTA MANAGER
+// ============================================================================
+const CACHE_TTL_MS = 30000;
+const quotaCache = new Map();
+const cooldownMap = new Map();
+function getCacheKey(provider, accountId) {
+    return `${provider}:${accountId}`;
+}
+/**
+ * Get cached quota result if still valid
+ */
+function getCachedQuota(provider, accountId) {
+    const key = getCacheKey(provider, accountId);
+    const entry = quotaCache.get(key);
+    if (!entry)
+        return null;
+    if (Date.now() - entry.timestamp > CACHE_TTL_MS) {
+        quotaCache.delete(key);
+        return null;
+    }
+    return entry.result;
+}
+/**
+ * Cache quota result
+ */
+function setCachedQuota(provider, accountId, result) {
+    const key = getCacheKey(provider, accountId);
+    quotaCache.set(key, { result, timestamp: Date.now() });
+}
+/**
+ * Check if account is on cooldown
+ */
+function isOnCooldown(provider, accountId) {
+    const key = getCacheKey(provider, accountId);
+    const entry = cooldownMap.get(key);
+    if (!entry)
+        return false;
+    if (Date.now() > entry.until) {
+        cooldownMap.delete(key);
+        return false;
+    }
+    return true;
+}
+function getCooldownStatus(provider, accountId) {
+    const key = getCacheKey(provider, accountId);
+    const entry = cooldownMap.get(key);
+    if (!entry)
+        return { active: false };
+    if (Date.now() > entry.until) {
+        cooldownMap.delete(key);
+        return { active: false };
+    }
+    return { active: true, until: entry.until };
+}
+/**
+ * Apply cooldown to an exhausted account
+ */
+function applyCooldown(provider, accountId, minutes) {
+    const key = getCacheKey(provider, accountId);
+    cooldownMap.set(key, { until: Date.now() + minutes * 60 * 1000 });
+}
+/**
+ * Extract quota from ManagedAccount object.
+ * This effectively replaces "fetchAccountQuota" by using the state we already have.
+ */
+function extractQuota(account) {
+    if (!account.quota) {
+        // If no quota tracking, assume healthy/unlimited
+        return {
+            success: true,
+            remaining: 1000,
+            models: [],
+            lastUpdated: Date.now()
+        };
+    }
+    const models = [];
+    if (account.quota.modelSpecific) {
+        for (const [name, info] of Object.entries(account.quota.modelSpecific)) {
+            models.push({
+                name,
+                percentage: info.limit > 0 ? (info.remaining / info.limit) * 100 : 100,
+                resetTime: info.resetTime || null
+            });
+        }
+    }
+    return {
+        success: true,
+        remaining: account.quota.remaining,
+        models,
+        lastUpdated: Date.now()
+    };
+}
+/**
+ * Find healthy account with remaining quota
+ */
+function findHealthyAccount(provider, allAccounts, excludeIds = []) {
+    // Filter available accounts
+    const available = allAccounts.filter((a) => a.provider === provider &&
+        !excludeIds.includes(a.id) &&
+        !isOnCooldown(provider, a.id) &&
+        a.isHealthy !== false);
+    if (available.length === 0)
+        return null;
+    // Sort by health score + quota
+    available.sort((a, b) => {
+        // Health Score
+        const scoreA = a.healthScore ?? 70;
+        const scoreB = b.healthScore ?? 70;
+        if (Math.abs(scoreA - scoreB) > 5) {
+            return scoreB - scoreA;
+        }
+        // Quota
+        const quotaA = a.quota?.remaining ?? 1000;
+        const quotaB = b.quota?.remaining ?? 1000;
+        return quotaB - quotaA;
+    });
+    return available[0];
+}
+/**
+ * Perform pre-flight quota check before session start
+ */
+function preflightCheck(provider, currentAccount, allAccounts) {
+    // Check cooldown
+    if (isOnCooldown(provider, currentAccount.id)) {
+        const alt = findHealthyAccount(provider, allAccounts, [currentAccount.id]);
+        if (alt) {
+            return {
+                proceed: true,
+                accountId: alt.id,
+                switchedFrom: currentAccount.id,
+                reason: 'Current account on cooldown'
+            };
+        }
+        return { proceed: false, accountId: currentAccount.id, reason: 'Account on cooldown and no alternatives' };
+    }
+    // Check quota
+    const quota = extractQuota(currentAccount);
+    if (quota.remaining <= 0) {
+        applyCooldown(provider, currentAccount.id, 5); // 5 min cooldown
+        const alt = findHealthyAccount(provider, allAccounts, [currentAccount.id]);
+        if (alt) {
+            return {
+                proceed: true,
+                accountId: alt.id,
+                switchedFrom: currentAccount.id,
+                reason: 'Quota exhausted'
+            };
+        }
+    }
+    return {
+        proceed: true,
+        accountId: currentAccount.id,
+        quotaPercent: quota.remaining // simplified
+    };
+}
diff --git a/src/core/reasoning.ts b/src/core/reasoning.ts
deleted file mode 100644
index e0ee0ca..0000000
--- a/src/core/reasoning.ts
+++ /dev/null
@@ -1,31 +0,0 @@
-/**
- * Enforces reasoning ("thinking") behavior in models by injecting instructions into the system prompt.
- */
-export function enforceReasoning(body: any, model?: string): any {
-    if (!body || typeof body !== 'object') return body;
-
-    const reasoningInstruction = "You are a reasoning model. Before answering, you must think step-by-step in a <thinking> block to analyze the user's request, plan your response, and verify your logic. Output the <thinking> block first, then your response.";
-
-    const newBody = JSON.parse(JSON.stringify(body)); // Deep copy
-
-    // Inject into system prompt (OpenAI/Anthropic style)
-    if (newBody.messages && Array.isArray(newBody.messages)) {
-        // Check if system message exists
-        const systemMsgIndex = newBody.messages.findIndex((m: any) => m.role === 'system');
-
-        if (systemMsgIndex > -1) {
-            const existingContent = newBody.messages[systemMsgIndex].content;
-            newBody.messages[systemMsgIndex].content = `${existingContent}\n\n${reasoningInstruction}`;
-        } else {
-            // Prepend system message
-            newBody.messages.unshift({ role: 'system', content: reasoningInstruction });
-        }
-    }
-
-    // Handle Anthropic specific top-level system
-    if (newBody.system) {
-         newBody.system = `${newBody.system}\n\n${reasoningInstruction}`;
-    }
-
-    return newBody;
-}
diff --git a/src/core/redactor.ts b/src/core/redactor.ts
deleted file mode 100644
index 976ab94..0000000
--- a/src/core/redactor.ts
+++ /dev/null
@@ -1,57 +0,0 @@
-export class Redactor {
-  private static SENSITIVE_HEADERS = new Set([
-    'authorization',
-    'x-api-key',
-    'x-auth-token',
-    'cookie',
-    'set-cookie',
-    'openai-organization',
-    'anthropic-version'
-  ]);
-
-  private static KEY_PATTERNS = [
-    /sk-[a-zA-Z0-9]{20,}/g, // OpenAI / Anthropic style
-    /AIza[a-zA-Z0-9_-]{35}/g, // Google
-    /ey[a-zA-Z0-9_-]{20,}\.[a-zA-Z0-9_-]{20,}\.[a-zA-Z0-9_-]{20,}/g, // JWT-like
-    /gh[pousr]-[a-zA-Z0-9]{36}/g // GitHub tokens
-  ];
-
-  /**
-   * Redacts sensitive information from an object, array, or string.
-   * Returns a deep copy with sensitive data replaced.
-   */
-  static redact(data: any): any {
-    if (typeof data === 'string') {
-        return this.redactString(data);
-    }
-    if (Array.isArray(data)) {
-        return data.map(item => this.redact(item));
-    }
-    if (typeof data === 'object' && data !== null) {
-        const copy: any = {};
-        for (const key in data) {
-            if (Object.prototype.hasOwnProperty.call(data, key)) {
-                if (this.SENSITIVE_HEADERS.has(key.toLowerCase())) {
-                    copy[key] = '[REDACTED]';
-                } else {
-                    copy[key] = this.redact(data[key]);
-                }
-            }
-        }
-        return copy;
-    }
-    return data;
-  }
-
-  private static redactString(str: string): string {
-    let result = str;
-    for (const pattern of this.KEY_PATTERNS) {
-        result = result.replace(pattern, (match) => {
-             // Keep first 3 and last 3 chars for debugging context, redact the rest
-             if (match.length < 8) return '[REDACTED]';
-             return match.substring(0, 3) + '...' + match.substring(match.length - 3);
-        });
-    }
-    return result;
-  }
-}
diff --git a/src/core/rotation.js b/src/core/rotation.js
new file mode 100644
index 0000000..4becffb
--- /dev/null
+++ b/src/core/rotation.js
@@ -0,0 +1,197 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.AccountRotator = exports.HealthScoreTracker = exports.DEFAULT_HEALTH_SCORE_CONFIG = void 0;
+const quota_manager_1 = require("./quota-manager");
+const QUOTA_EXHAUSTED_BACKOFFS = [60000, 300000, 1800000, 7200000];
+const RATE_LIMIT_EXCEEDED_BACKOFF = 30000;
+const MODEL_CAPACITY_EXHAUSTED_BACKOFF = 15000;
+const SERVER_ERROR_BACKOFF = 20000;
+const UNKNOWN_BACKOFF = 60000;
+const MIN_BACKOFF_MS = 2000;
+const RATE_LIMIT_DEDUP_WINDOW_MS = 2000;
+exports.DEFAULT_HEALTH_SCORE_CONFIG = {
+    initial: 70,
+    successReward: 1,
+    rateLimitPenalty: -10,
+    failurePenalty: -20,
+    recoveryRatePerHour: 2,
+    minUsable: 50,
+    maxScore: 100,
+};
+// ============================================================================
+// HEALTH SCORE TRACKER
+// ============================================================================
+class HealthScoreTracker {
+    constructor(config = {}) {
+        // Map account ID to last update timestamp for passive recovery calculation
+        this.lastUpdateTimes = new Map();
+        this.config = { ...exports.DEFAULT_HEALTH_SCORE_CONFIG, ...config };
+    }
+    getScore(account) {
+        const currentScore = account.healthScore ?? this.config.initial;
+        const lastUpdate = this.lastUpdateTimes.get(account.id) ?? Date.now();
+        // Apply passive recovery
+        const now = Date.now();
+        const hoursSinceUpdate = (now - lastUpdate) / (1000 * 60 * 60);
+        if (hoursSinceUpdate > 0) {
+            const recoveredPoints = Math.floor(hoursSinceUpdate * this.config.recoveryRatePerHour);
+            return Math.min(this.config.maxScore, currentScore + recoveredPoints);
+        }
+        return currentScore;
+    }
+    recordSuccess(account) {
+        const current = this.getScore(account);
+        account.healthScore = Math.min(this.config.maxScore, current + this.config.successReward);
+        account.consecutiveFailures = 0;
+        account.isHealthy = account.healthScore >= this.config.minUsable;
+        this.lastUpdateTimes.set(account.id, Date.now());
+    }
+    recordRateLimit(account) {
+        const current = this.getScore(account);
+        account.healthScore = Math.max(0, current + this.config.rateLimitPenalty);
+        account.consecutiveFailures = (account.consecutiveFailures ?? 0) + 1;
+        account.isHealthy = account.healthScore >= this.config.minUsable;
+        this.lastUpdateTimes.set(account.id, Date.now());
+    }
+    recordFailure(account) {
+        const current = this.getScore(account);
+        account.healthScore = Math.max(0, current + this.config.failurePenalty);
+        account.consecutiveFailures = (account.consecutiveFailures ?? 0) + 1;
+        account.isHealthy = account.healthScore >= this.config.minUsable;
+        this.lastUpdateTimes.set(account.id, Date.now());
+    }
+    isUsable(account) {
+        return this.getScore(account) >= this.config.minUsable;
+    }
+}
+exports.HealthScoreTracker = HealthScoreTracker;
+// ============================================================================
+// ACCOUNT ROTATOR
+// ============================================================================
+class AccountRotator {
+    constructor(healthConfig) {
+        this.cursor = 0;
+        this.lastRateLimitTimes = new Map();
+        this.healthTracker = new HealthScoreTracker(healthConfig);
+        // PID-based initial offset for round-robin to maximize throughput across parallel instances
+        this.cursor = process.pid;
+    }
+    selectAccount(accounts, strategy = 'sticky') {
+        if (!accounts.length)
+            return null;
+        // Filter out accounts that are cooling down or rate limited OR unhealthy
+        const availableAccounts = accounts.filter(acc => {
+            const now = Date.now();
+            if (acc.rateLimitResetTime && now < acc.rateLimitResetTime)
+                return false;
+            if (acc.cooldownUntil && now < acc.cooldownUntil)
+                return false;
+            // Check global cooldown manager
+            if ((0, quota_manager_1.isOnCooldown)(acc.provider, acc.id))
+                return false;
+            // Check health
+            if (!this.healthTracker.isUsable(acc))
+                return false;
+            return true;
+        });
+        if (availableAccounts.length === 0)
+            return null;
+        switch (strategy) {
+            case 'round-robin':
+                return this.selectRoundRobin(availableAccounts);
+            case 'hybrid':
+                return this.selectHybrid(availableAccounts);
+            case 'quota-optimized':
+                return this.selectQuotaOptimized(availableAccounts);
+            case 'sticky':
+            default:
+                return this.selectSticky(availableAccounts);
+        }
+    }
+    selectQuotaOptimized(accounts) {
+        // Sort by remaining quota (descending)
+        const sorted = [...accounts].sort((a, b) => {
+            const quotaA = a.quota?.remaining ?? 1000;
+            const quotaB = b.quota?.remaining ?? 1000;
+            return quotaB - quotaA;
+        });
+        return sorted[0];
+    }
+    selectRoundRobin(accounts) {
+        const account = accounts[this.cursor % accounts.length];
+        this.cursor++;
+        return account;
+    }
+    selectSticky(accounts) {
+        // Incorporate a process-based offset to ensure different IDE instances
+        // or subagents pick different starting accounts.
+        const offset = process.pid % accounts.length;
+        return accounts[offset];
+    }
+    selectHybrid(accounts) {
+        // Sort by health score (descending) and then by last used (ascending - LRU)
+        // We want the healthiest account that hasn't been used recently.
+        const scored = accounts.map(acc => ({
+            account: acc,
+            score: this.healthTracker.getScore(acc),
+            lastUsed: acc.lastUsed ?? 0
+        }));
+        // Apply PID-based rotation to the base list to break ties in a way that
+        // maximizes throughput across parallel instances.
+        const pidOffset = process.pid % scored.length;
+        const rotatedScored = [
+            ...scored.slice(pidOffset),
+            ...scored.slice(0, pidOffset)
+        ];
+        rotatedScored.sort((a, b) => {
+            // Primary: Health Score
+            if (Math.abs(a.score - b.score) > 5) { // 5 point buffer
+                return b.score - a.score;
+            }
+            // Secondary: LRU (Least Recently Used)
+            return a.lastUsed - b.lastUsed;
+        });
+        return rotatedScored[0].account;
+    }
+    recordSuccess(account) {
+        this.healthTracker.recordSuccess(account);
+        account.lastUsed = Date.now();
+    }
+    recordFailure(account) {
+        this.healthTracker.recordFailure(account);
+    }
+    recordRateLimit(account, retryAfterMs, reason = 'UNKNOWN') {
+        const now = Date.now();
+        const lastAt = this.lastRateLimitTimes.get(account.id) ?? 0;
+        // Deduplicate concurrent 429s within 2000ms window
+        if (now - lastAt < RATE_LIMIT_DEDUP_WINDOW_MS) {
+            if (retryAfterMs) {
+                account.rateLimitResetTime = now + retryAfterMs;
+            }
+            return;
+        }
+        this.lastRateLimitTimes.set(account.id, now);
+        this.healthTracker.recordRateLimit(account);
+        const backoff = retryAfterMs ?? this.calculateBackoff(reason, account.consecutiveFailures ?? 1);
+        account.rateLimitResetTime = now + backoff;
+        account.lastSwitchReason = 'rate-limit';
+    }
+    calculateBackoff(reason, consecutiveFailures) {
+        switch (reason) {
+            case "QUOTA_EXHAUSTED": {
+                const index = Math.min(consecutiveFailures, QUOTA_EXHAUSTED_BACKOFFS.length - 1);
+                return QUOTA_EXHAUSTED_BACKOFFS[index];
+            }
+            case "RATE_LIMIT_EXCEEDED":
+                return RATE_LIMIT_EXCEEDED_BACKOFF;
+            case "MODEL_CAPACITY_EXHAUSTED":
+                return MODEL_CAPACITY_EXHAUSTED_BACKOFF;
+            case "SERVER_ERROR":
+                return SERVER_ERROR_BACKOFF;
+            case "UNKNOWN":
+            default:
+                return UNKNOWN_BACKOFF;
+        }
+    }
+}
+exports.AccountRotator = AccountRotator;
diff --git a/src/core/rotation.ts b/src/core/rotation.ts
index 8ef4485..63e5c62 100644
--- a/src/core/rotation.ts
+++ b/src/core/rotation.ts
@@ -125,10 +125,7 @@ export class AccountRotator {
       // Check global cooldown manager
       if (isOnCooldown(acc.provider, acc.id)) return false;

-      // Check explicit health flag
-      if (acc.isHealthy === false) return false;
-
-      // Check health score
+      // Check health
       if (!this.healthTracker.isUsable(acc)) return false;

       return true;
diff --git a/src/core/secret-storage.ts b/src/core/secret-storage.ts
deleted file mode 100644
index b4fcf1c..0000000
--- a/src/core/secret-storage.ts
+++ /dev/null
@@ -1,94 +0,0 @@
-import { exec } from 'child_process';
-import * as fs from 'fs';
-import * as path from 'path';
-import * as os from 'os';
-import { promisify } from 'util';
-
-const execAsync = promisify(exec);
-
-export class SecretStorage {
-  private useKeychain: boolean;
-  private storagePath: string;
-
-  constructor(storageDir: string) {
-    this.storagePath = path.join(storageDir, 'auth-monster-secrets.json');
-    this.useKeychain = os.platform() === 'darwin';
-  }
-
-  async saveSecret(service: string, account: string, secret: string): Promise<void> {
-    if (this.useKeychain) {
-      try {
-        // macOS Keychain
-        // security add-generic-password -a "account" -s "service" -w "secret" -U
-        // -U updates if exists
-        await execAsync(`security add-generic-password -a "${account}" -s "${service}" -w "${secret}" -U`);
-        return;
-      } catch (e) {
-        console.warn('Failed to save to keychain, falling back to file:', e);
-      }
-    }
-
-    // Fallback: Encrypted file (mock encryption for now, or simple obfuscation)
-    await this.saveToFile(service, account, secret);
-  }
-
-  async getSecret(service: string, account: string): Promise<string | null> {
-    if (this.useKeychain) {
-      try {
-        // security find-generic-password -a "account" -s "service" -w
-        const { stdout } = await execAsync(`security find-generic-password -a "${account}" -s "${service}" -w`);
-        return stdout.trim();
-      } catch (e) {
-        // Not found or error
-      }
-    }
-
-    return this.getFromFile(service, account);
-  }
-
-  async deleteSecret(service: string, account: string): Promise<void> {
-    if (this.useKeychain) {
-      try {
-        await execAsync(`security delete-generic-password -a "${account}" -s "${service}"`);
-      } catch (e) {}
-    }
-    await this.deleteFromFile(service, account);
-  }
-
-  // Simple file-based fallback
-  private async saveToFile(service: string, account: string, secret: string) {
-    let data: Record<string, string> = {};
-    if (fs.existsSync(this.storagePath)) {
-      try {
-          data = JSON.parse(fs.readFileSync(this.storagePath, 'utf8'));
-      } catch(e) {}
-    }
-    const key = `${service}:${account}`;
-    data[key] = Buffer.from(secret).toString('base64'); // Simple obfuscation
-    fs.writeFileSync(this.storagePath, JSON.stringify(data, null, 2), { mode: 0o600 });
-  }
-
-  private async getFromFile(service: string, account: string): Promise<string | null> {
-    if (!fs.existsSync(this.storagePath)) return null;
-    try {
-        const data = JSON.parse(fs.readFileSync(this.storagePath, 'utf8'));
-        const key = `${service}:${account}`;
-        if (data[key]) {
-          return Buffer.from(data[key], 'base64').toString('utf8');
-        }
-    } catch (e) {}
-    return null;
-  }
-
-  private async deleteFromFile(service: string, account: string) {
-    if (!fs.existsSync(this.storagePath)) return;
-    try {
-        const data = JSON.parse(fs.readFileSync(this.storagePath, 'utf8'));
-        const key = `${service}:${account}`;
-        if (data[key]) {
-          delete data[key];
-          fs.writeFileSync(this.storagePath, JSON.stringify(data, null, 2), { mode: 0o600 });
-        }
-    } catch (e) {}
-  }
-}
diff --git a/src/core/storage.js b/src/core/storage.js
new file mode 100644
index 0000000..46d47d6
--- /dev/null
+++ b/src/core/storage.js
@@ -0,0 +1,84 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.StorageManager = void 0;
+const fs_1 = __importDefault(require("fs"));
+const path_1 = __importDefault(require("path"));
+const xdg_basedir_1 = require("xdg-basedir");
+const proper_lockfile_1 = require("proper-lockfile");
+class StorageManager {
+    constructor(customPath) {
+        const configDir = customPath || path_1.default.join(xdg_basedir_1.xdgConfig || '', 'opencode');
+        if (!fs_1.default.existsSync(configDir)) {
+            fs_1.default.mkdirSync(configDir, { recursive: true });
+        }
+        this.storagePath = path_1.default.join(configDir, 'auth-monster-accounts.json');
+    }
+    async loadAccounts() {
+        if (!fs_1.default.existsSync(this.storagePath)) {
+            return [];
+        }
+        try {
+            const release = await (0, proper_lockfile_1.lock)(this.storagePath, { retries: 5 });
+            try {
+                const data = fs_1.default.readFileSync(this.storagePath, 'utf8');
+                return JSON.parse(data);
+            }
+            finally {
+                await release();
+            }
+        }
+        catch (error) {
+            console.error('Failed to load accounts:', error);
+            return [];
+        }
+    }
+    async saveAccounts(accounts) {
+        const dir = path_1.default.dirname(this.storagePath);
+        if (!fs_1.default.existsSync(dir)) {
+            fs_1.default.mkdirSync(dir, { recursive: true });
+        }
+        // Ensure file exists for locking
+        if (!fs_1.default.existsSync(this.storagePath)) {
+            fs_1.default.writeFileSync(this.storagePath, '[]', 'utf8');
+        }
+        try {
+            const release = await (0, proper_lockfile_1.lock)(this.storagePath, { retries: 5 });
+            try {
+                fs_1.default.writeFileSync(this.storagePath, JSON.stringify(accounts, null, 2), 'utf8');
+            }
+            finally {
+                await release();
+            }
+        }
+        catch (error) {
+            console.error('Failed to save accounts:', error);
+            throw error;
+        }
+    }
+    async addAccount(account) {
+        const accounts = await this.loadAccounts();
+        const index = accounts.findIndex(a => a.id === account.id || (a.email === account.email && a.provider === account.provider));
+        if (index >= 0) {
+            accounts[index] = { ...accounts[index], ...account };
+        }
+        else {
+            accounts.push(account);
+        }
+        await this.saveAccounts(accounts);
+    }
+    async deleteAccount(id) {
+        const accounts = await this.loadAccounts();
+        const filtered = accounts.filter(a => a.id !== id);
+        if (accounts.length !== filtered.length) {
+            await this.saveAccounts(filtered);
+        }
+    }
+    async getAccountsByProvider(provider) {
+        const accounts = await this.loadAccounts();
+        return accounts.filter(a => a.provider === provider);
+    }
+}
+exports.StorageManager = StorageManager;
diff --git a/src/core/storage.ts b/src/core/storage.ts
index e62c3ae..43e376e 100644
--- a/src/core/storage.ts
+++ b/src/core/storage.ts
@@ -3,11 +3,9 @@ import path from 'path';
 import { xdgConfig } from 'xdg-basedir';
 import { lock } from 'proper-lockfile';
 import { ManagedAccount, AuthProvider } from './types';
-import { SecretStorage } from './secret-storage';

 export class StorageManager {
   private storagePath: string;
-  private secretStorage: SecretStorage;

   constructor(customPath?: string) {
     const configDir = customPath || path.join(xdgConfig || '', 'opencode');
@@ -15,7 +13,6 @@ export class StorageManager {
       fs.mkdirSync(configDir, { recursive: true });
     }
     this.storagePath = path.join(configDir, 'auth-monster-accounts.json');
-    this.secretStorage = new SecretStorage(configDir);
   }

   async loadAccounts(): Promise<ManagedAccount[]> {
@@ -25,30 +22,12 @@ export class StorageManager {

     try {
       const release = await lock(this.storagePath, { retries: 5 });
-      let accounts: ManagedAccount[] = [];
       try {
         const data = fs.readFileSync(this.storagePath, 'utf8');
-        accounts = JSON.parse(data);
+        return JSON.parse(data);
       } finally {
         await release();
       }
-
-      // Rehydrate tokens from secret storage
-      const hydratedAccounts = await Promise.all(accounts.map(async (acc) => {
-          // Fallback to what's in JSON if not in secret storage (for legacy data)
-          const accessToken = await this.secretStorage.getSecret('accessToken', acc.id);
-          const refreshToken = await this.secretStorage.getSecret('refreshToken', acc.id);
-          const apiKey = await this.secretStorage.getSecret('apiKey', acc.id);
-
-          if (accessToken) acc.tokens.accessToken = accessToken;
-          if (refreshToken) acc.tokens.refreshToken = refreshToken;
-          if (apiKey) acc.apiKey = apiKey;
-
-          return acc;
-      }));
-
-      return hydratedAccounts;
-
     } catch (error) {
       console.error('Failed to load accounts:', error);
       return [];
@@ -67,32 +46,9 @@ export class StorageManager {
     }

     try {
-      // 1. Save secrets first
-      await Promise.all(accounts.map(async (acc) => {
-          if (acc.tokens.accessToken) {
-              await this.secretStorage.saveSecret('accessToken', acc.id, acc.tokens.accessToken);
-          }
-          if (acc.tokens.refreshToken) {
-              await this.secretStorage.saveSecret('refreshToken', acc.id, acc.tokens.refreshToken);
-          }
-          if (acc.apiKey) {
-              await this.secretStorage.saveSecret('apiKey', acc.id, acc.apiKey);
-          }
-      }));
-
-      // 2. Prepare accounts for JSON storage (strip sensitive data)
-      const sanitizedAccounts = accounts.map(acc => {
-          const clone = { ...acc, tokens: { ...acc.tokens } };
-          // Remove sensitive data from the clone that will be saved to disk
-          clone.tokens.accessToken = '';
-          clone.tokens.refreshToken = '';
-          clone.apiKey = '';
-          return clone;
-      });
-
       const release = await lock(this.storagePath, { retries: 5 });
       try {
-        fs.writeFileSync(this.storagePath, JSON.stringify(sanitizedAccounts, null, 2), 'utf8');
+        fs.writeFileSync(this.storagePath, JSON.stringify(accounts, null, 2), 'utf8');
       } finally {
         await release();
       }
@@ -120,10 +76,6 @@ export class StorageManager {
     const filtered = accounts.filter(a => a.id !== id);
     if (accounts.length !== filtered.length) {
       await this.saveAccounts(filtered);
-      // Cleanup secrets
-      await this.secretStorage.deleteSecret('accessToken', id);
-      await this.secretStorage.deleteSecret('refreshToken', id);
-      await this.secretStorage.deleteSecret('apiKey', id);
     }
   }

diff --git a/src/core/thinking-validator.js b/src/core/thinking-validator.js
new file mode 100644
index 0000000..6f498f7
--- /dev/null
+++ b/src/core/thinking-validator.js
@@ -0,0 +1,191 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.THINKING_AUTO_VALUE = exports.THINKING_OFF_VALUES = exports.VALID_THINKING_LEVELS = exports.THINKING_LEVEL_RANK = exports.THINKING_LEVEL_BUDGETS = exports.THINKING_BUDGET_DEFAULT_MIN = exports.THINKING_BUDGET_MAX = exports.THINKING_BUDGET_MIN = void 0;
+exports.getModelThinkingSupport = getModelThinkingSupport;
+exports.capLevelAtMax = capLevelAtMax;
+exports.validateThinking = validateThinking;
+const types_1 = require("./types");
+/**
+ * Thinking budget bounds
+ */
+exports.THINKING_BUDGET_MIN = 0;
+exports.THINKING_BUDGET_MAX = 100000;
+exports.THINKING_BUDGET_DEFAULT_MIN = 512;
+exports.THINKING_LEVEL_BUDGETS = {
+    minimal: 512,
+    low: 1024,
+    medium: 8192,
+    high: 24576,
+    xhigh: 32768,
+};
+exports.THINKING_LEVEL_RANK = {
+    minimal: 1,
+    low: 2,
+    medium: 3,
+    high: 4,
+    xhigh: 5,
+};
+exports.VALID_THINKING_LEVELS = ['minimal', 'low', 'medium', 'high', 'xhigh', 'auto'];
+exports.THINKING_OFF_VALUES = ['off', 'none', 'disabled', '0'];
+exports.THINKING_AUTO_VALUE = 'auto';
+/**
+ * Get thinking support for a specific model/provider combo.
+ * This acts as a mini-catalog.
+ */
+function getModelThinkingSupport(provider, modelId) {
+    const model = modelId.toLowerCase();
+    // Anthropic / Claude
+    if (provider === types_1.AuthProvider.Anthropic || model.includes('claude')) {
+        if (model.includes('3-7-sonnet') || model.includes('3.7-sonnet')) {
+            return {
+                type: 'budget',
+                min: 1024,
+                max: 32000, // 3.7 supports up to 64k extended, typically
+                zeroAllowed: true,
+                dynamicAllowed: true
+            };
+        }
+        if (model.includes('4-5-opus') || model.includes('4.5-opus')) {
+            // Hypothetical 4.5 Opus support
+            return {
+                type: 'budget',
+                min: 2048,
+                max: 64000,
+                zeroAllowed: false,
+                dynamicAllowed: true
+            };
+        }
+    }
+    // OpenAI / Codex / O-series
+    if (provider === types_1.AuthProvider.OpenAI || model.includes('o1') || model.includes('o3') || model.includes('codex')) {
+        // O1/O3 use levels (low/medium/high) usually, but sometimes budget
+        return {
+            type: 'levels',
+            levels: ['low', 'medium', 'high'],
+            default: 'medium',
+            dynamicAllowed: false
+        };
+    }
+    // Default: check if it's a known reasoning model
+    if (model.includes('reasoning') || model.includes('thinking')) {
+        return {
+            type: 'budget',
+            min: 1024,
+            max: 16000,
+            dynamicAllowed: true
+        };
+    }
+    // No thinking support by default
+    return { type: 'none' };
+}
+function capLevelAtMax(level, maxLevel) {
+    if (!maxLevel)
+        return { level, capped: false };
+    const levelRank = exports.THINKING_LEVEL_RANK[level] ?? 0;
+    const maxRank = exports.THINKING_LEVEL_RANK[maxLevel] ?? 5;
+    if (levelRank > maxRank) {
+        return { level: maxLevel, capped: true };
+    }
+    return { level, capped: false };
+}
+function findClosestLevel(input, validLevels) {
+    const normalized = input.toLowerCase().trim();
+    if (validLevels.includes(normalized)) {
+        return normalized;
+    }
+    for (const level of validLevels) {
+        if (level.startsWith(normalized)) {
+            return level;
+        }
+    }
+    return undefined;
+}
+function validateThinking(provider, modelId, value) {
+    const thinking = getModelThinkingSupport(provider, modelId);
+    if (typeof value === 'string' && value.length > 100) {
+        return { valid: false, value: 'off', warning: 'Thinking value too long.' };
+    }
+    if (typeof value === 'string' && value.trim() === '') {
+        return { valid: false, value: 'off', warning: 'Empty thinking value.' };
+    }
+    if (typeof value === 'string') {
+        const normalizedValue = value.toLowerCase().trim();
+        if (exports.THINKING_OFF_VALUES.includes(normalizedValue)) {
+            return { valid: true, value: 'off' };
+        }
+    }
+    if (!thinking) {
+        return { valid: true, value, warning: `Unknown thinking support for ${modelId}.` };
+    }
+    if (thinking.type === 'none') {
+        return { valid: false, value: 'off', warning: `Model ${modelId} does not support thinking.` };
+    }
+    if (typeof value === 'string' && value.toLowerCase().trim() === exports.THINKING_AUTO_VALUE) {
+        if (!thinking.dynamicAllowed) {
+            const fallback = thinking.type === 'budget' ? (thinking.min ?? 1024) : (thinking.levels?.[0] ?? 'low');
+            return { valid: false, value: fallback, warning: 'Dynamic thinking not supported. Using minimum.' };
+        }
+        return { valid: true, value: 'auto' };
+    }
+    if (thinking.type === 'budget') {
+        return validateBudgetThinking(thinking, value, modelId);
+    }
+    if (thinking.type === 'levels') {
+        return validateLevelThinking(thinking, value, modelId);
+    }
+    return { valid: true, value };
+}
+function validateBudgetThinking(thinking, value, modelId) {
+    const min = thinking.min ?? exports.THINKING_BUDGET_MIN;
+    const max = thinking.max ?? exports.THINKING_BUDGET_MAX;
+    let budget;
+    if (typeof value === 'string') {
+        const normalizedLevel = value.toLowerCase().trim();
+        if (normalizedLevel in exports.THINKING_LEVEL_BUDGETS) {
+            budget = exports.THINKING_LEVEL_BUDGETS[normalizedLevel];
+        }
+        else {
+            const parsed = Number(value);
+            if (isNaN(parsed) || !Number.isFinite(parsed)) {
+                return { valid: false, value: min, warning: `Invalid budget "${value}".` };
+            }
+            budget = parsed;
+        }
+    }
+    else {
+        budget = value;
+    }
+    if (budget < min) {
+        return { valid: true, value: min, warning: `Budget ${budget} below min. Clamped to ${min}.` };
+    }
+    if (budget > max) {
+        return { valid: true, value: max, warning: `Budget ${budget} exceeds max. Clamped to ${max}.` };
+    }
+    return { valid: true, value: budget };
+}
+function validateLevelThinking(thinking, value, modelId) {
+    const validLevels = thinking.levels ?? [];
+    if (typeof value === 'number') {
+        // Map number to level
+        let closestLevel = validLevels[0] ?? 'low';
+        let closestDiff = Infinity;
+        for (const level of validLevels) {
+            const budget = exports.THINKING_LEVEL_BUDGETS[level] ?? 8192;
+            const diff = Math.abs(budget - value);
+            if (diff < closestDiff) {
+                closestDiff = diff;
+                closestLevel = level;
+            }
+        }
+        return { valid: true, value: closestLevel, warning: `Mapped budget ${value} to level ${closestLevel}.` };
+    }
+    const normalized = value.toLowerCase().trim();
+    if (validLevels.includes(normalized)) {
+        return { valid: true, value: normalized };
+    }
+    const closest = findClosestLevel(normalized, validLevels);
+    if (closest) {
+        return { valid: true, value: closest, warning: `Mapped ${value} to ${closest}.` };
+    }
+    return { valid: false, value: validLevels[0] ?? 'low', warning: `Invalid level ${value}.` };
+}
diff --git a/src/core/transport.js b/src/core/transport.js
new file mode 100644
index 0000000..926bb81
--- /dev/null
+++ b/src/core/transport.js
@@ -0,0 +1,68 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.ProtoWriter = void 0;
+exports.createConnectFrame = createConnectFrame;
+const buffer_1 = require("buffer");
+/**
+ * Writer for manual Protobuf encoding.
+ * Essential for communicating with restrictive gRPC/Connect backends without heavy dependencies.
+ */
+class ProtoWriter {
+    constructor() {
+        this.parts = [];
+    }
+    /**
+     * Writes a variable-length integer (Varint).
+     */
+    writeVarint(v) {
+        const b = [];
+        while (v > 127) {
+            b.push((v & 0x7f) | 0x80);
+            v >>>= 7;
+        }
+        b.push(v & 0x7f);
+        this.parts.push(buffer_1.Buffer.from(b));
+    }
+    /**
+     * Writes a string field.
+     */
+    writeString(field, value) {
+        const buf = buffer_1.Buffer.from(value, 'utf8');
+        this.writeVarint((field << 3) | 2); // WireType 2 = Length-delimited
+        this.writeVarint(buf.length);
+        this.parts.push(buf);
+    }
+    /**
+     * Writes a nested message field.
+     */
+    writeMessage(field, writer) {
+        const buf = writer.toBuffer();
+        this.writeVarint((field << 3) | 2);
+        this.writeVarint(buf.length);
+        this.parts.push(buf);
+    }
+    /**
+     * Writes a 32-bit integer field.
+     */
+    writeInt32(field, value) {
+        this.writeVarint((field << 3) | 0); // WireType 0 = Varint (technically int32 is varint encoded usually, or fixed32)
+        // Note: Standard protobuf int32 is varint. fixed32 is WireType 5.
+        // Based on reference implementation using writeVarint for int32.
+        this.writeVarint(value);
+    }
+    toBuffer() {
+        return buffer_1.Buffer.concat(this.parts);
+    }
+}
+exports.ProtoWriter = ProtoWriter;
+/**
+ * Creates a Connect-RPC envelope frame.
+ * Format: [CompressionFlag(1)] + [Length(4, BigEndian)] + [Payload]
+ */
+function createConnectFrame(payload, compressed = false) {
+    const frame = buffer_1.Buffer.alloc(5 + payload.length);
+    frame[0] = compressed ? 1 : 0;
+    frame.writeUInt32BE(payload.length, 1);
+    payload.copy(frame, 5);
+    return frame;
+}
diff --git a/src/core/types.js b/src/core/types.js
new file mode 100644
index 0000000..09ff863
--- /dev/null
+++ b/src/core/types.js
@@ -0,0 +1,50 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.AuthMonsterConfigSchema = exports.AuthProvider = void 0;
+const zod_1 = require("zod");
+var AuthProvider;
+(function (AuthProvider) {
+    AuthProvider["Gemini"] = "gemini";
+    AuthProvider["Windsurf"] = "windsurf";
+    AuthProvider["Anthropic"] = "anthropic";
+    AuthProvider["Cursor"] = "cursor";
+    AuthProvider["Qwen"] = "qwen";
+    AuthProvider["IFlow"] = "iflow";
+    AuthProvider["OpenAI"] = "openai";
+    AuthProvider["Copilot"] = "copilot";
+    AuthProvider["Kiro"] = "kiro";
+    AuthProvider["Zhipu"] = "zhipu";
+    AuthProvider["Minimax"] = "minimax";
+    AuthProvider["Azure"] = "azure";
+    AuthProvider["Grok"] = "grok";
+    AuthProvider["DeepSeek"] = "deepseek";
+    AuthProvider["Generic"] = "generic";
+})(AuthProvider || (exports.AuthProvider = AuthProvider = {}));
+exports.AuthMonsterConfigSchema = zod_1.z.object({
+    active: zod_1.z.nativeEnum(AuthProvider).default(AuthProvider.Gemini),
+    fallback: zod_1.z.array(zod_1.z.nativeEnum(AuthProvider)).default([]),
+    method: zod_1.z.enum(['sticky', 'round-robin', 'hybrid', 'quota-optimized']).default('sticky'),
+    proxy: zod_1.z.string().optional(),
+    modelPriorities: zod_1.z.record(zod_1.z.string(), zod_1.z.array(zod_1.z.string())).default({
+        'gemini-3-pro-preview': ['claude-4.5-opus-thinking', 'gpt-5.2-codex'],
+        'claude-4.5-opus-thinking': ['gpt-5.2-codex', 'gemini-3-pro-preview'],
+        'gpt-5.2-codex': ['claude-4.5-opus-thinking', 'gemini-3-pro-preview']
+    }),
+    fallbackDirection: zod_1.z.enum(['up', 'down']).default('down'),
+    thinking: zod_1.z.object({
+        enabled: zod_1.z.boolean().default(true),
+        defaultBudget: zod_1.z.number().default(1024),
+        defaultLevel: zod_1.z.string().default('low')
+    }).optional(),
+    quota: zod_1.z.object({
+        enabled: zod_1.z.boolean().default(true),
+        cooldownMinutes: zod_1.z.number().default(5),
+        preflightCheck: zod_1.z.boolean().default(true)
+    }).optional(),
+    providers: zod_1.z.record(zod_1.z.string(), zod_1.z.object({
+        enabled: zod_1.z.boolean().default(true),
+        profile: zod_1.z.string().optional(),
+        port: zod_1.z.number().optional(),
+        options: zod_1.z.record(zod_1.z.string(), zod_1.z.any()).optional()
+    })).default({})
+});
diff --git a/src/core/types.ts b/src/core/types.ts
index 8ba3b03..637f113 100644
--- a/src/core/types.ts
+++ b/src/core/types.ts
@@ -44,13 +44,6 @@ export interface ManagedAccount {
   cooldownUntil?: number;
   lastSwitchReason?: string;

-  // Usage Stats (Phase 3)
-  usage?: {
-    totalInputTokens: number;
-    totalOutputTokens: number;
-    totalCost: number; // USD
-  };
-
   // Quota Management
   quota?: {
     limit: number;
diff --git a/src/index.js b/src/index.js
new file mode 100644
index 0000000..5e95394
--- /dev/null
+++ b/src/index.js
@@ -0,0 +1,374 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.AuthMonster = void 0;
+exports.createAuthMonster = createAuthMonster;
+const types_1 = require("./core/types");
+const storage_1 = require("./core/storage");
+const rotation_1 = require("./core/rotation");
+const hub_1 = require("./core/hub");
+const sanitizer_1 = require("./utils/sanitizer");
+const proxy_1 = require("./core/proxy");
+// Import Providers
+const gemini_1 = require("./providers/gemini");
+const anthropic_1 = require("./providers/anthropic");
+const cursor_1 = require("./providers/cursor");
+const windsurf_1 = require("./providers/windsurf");
+const qwen_1 = require("./providers/qwen");
+const iflow_1 = require("./providers/iflow");
+const kiro_1 = require("./providers/kiro");
+const zhipu_1 = require("./providers/zhipu");
+const minimax_1 = require("./providers/minimax");
+const azure_1 = require("./providers/azure");
+const grok_1 = require("./providers/grok");
+const deepseek_1 = require("./providers/deepseek");
+class AuthMonster {
+    constructor(context) {
+        this.accounts = [];
+        this.lastUsedAccountId = null;
+        this.lastWarmupTime = new Map();
+        this.config = context.config;
+        this.storage = new storage_1.StorageManager(context.storagePath);
+        this.rotator = new rotation_1.AccountRotator();
+        this.hub = new hub_1.UnifiedModelHub();
+    }
+    async init() {
+        this.accounts = await this.storage.loadAccounts();
+    }
+    async getAuthDetails(modelOrProvider) {
+        // 1. Try routing via Unified Model Hub if it looks like a model name
+        if (modelOrProvider && typeof modelOrProvider === 'string' &&
+            !Object.values(types_1.AuthProvider).includes(modelOrProvider)) {
+            const modelChain = this.hub.resolveModelChain(modelOrProvider, this.config);
+            for (const modelName of modelChain) {
+                const hubChoice = this.hub.selectModelAccount(modelName, this.accounts);
+                if (hubChoice) {
+                    const details = this.selectAccount(hubChoice.provider, [hubChoice.account], hubChoice.modelInProvider);
+                    if (details)
+                        return details;
+                }
+            }
+        }
+        // 2. Default provider-based selection
+        const targetProvider = modelOrProvider || this.config.active;
+        const providerAccounts = this.accounts.filter(a => a.provider === targetProvider);
+        if (providerAccounts.length === 0) {
+            // Try fallback
+            for (const fallbackProvider of this.config.fallback) {
+                const fallbackAccounts = this.accounts.filter(a => a.provider === fallbackProvider);
+                if (fallbackAccounts.length > 0) {
+                    return this.selectAccount(fallbackProvider, fallbackAccounts);
+                }
+            }
+            return null;
+        }
+        return this.selectAccount(targetProvider, providerAccounts);
+    }
+    selectAccount(provider, accounts, modelInProvider) {
+        const account = this.rotator.selectAccount(accounts, this.config.method);
+        if (!account) {
+            return null;
+        }
+        // Thinking Warmup: Triggered when switching to a new account
+        if (this.lastUsedAccountId !== account.id) {
+            this.runThinkingWarmup(account.id).catch(err => console.error(`[AuthMonster] Warmup background task failed for ${account.email}:`, err));
+            this.lastUsedAccountId = account.id;
+        }
+        const headers = this.getHeadersForAccount(provider, account);
+        return {
+            provider,
+            account,
+            headers,
+            modelInProvider
+        };
+    }
+    /**
+     * Performs a request with transparent model fallback and retries.
+     * If a model in the chain fails with a quota error, it automatically
+     * reports the error and moves to the next model in the chain.
+     */
+    async request(model, url, options) {
+        const modelChain = this.hub.resolveModelChain(model, this.config);
+        let lastError = new Error(`No available accounts for model chain: ${modelChain.join(', ')}`);
+        for (const currentModel of modelChain) {
+            const auth = await this.getAuthDetails(currentModel);
+            if (!auth)
+                continue;
+            try {
+                const headers = { ...options.headers, ...auth.headers };
+                let body = options.body;
+                // Transform body if it's an object (AI request)
+                if (body && typeof body === 'object' && !(body instanceof FormData) && !(body instanceof Blob)) {
+                    body = JSON.stringify(this.transformRequest(auth.provider, body, auth.modelInProvider));
+                }
+                const targetUrl = this.getRequestUrl(auth.provider, auth.modelInProvider || model, auth.account) || url;
+                if (auth.provider === types_1.AuthProvider.Windsurf) {
+                    return this.handleWindsurfRequest(auth, options);
+                }
+                const response = await (0, proxy_1.proxyFetch)(targetUrl, {
+                    ...options,
+                    headers,
+                    body
+                });
+                if (response.status === 429 || response.status === 403) {
+                    const text = await response.clone().text().catch(() => '');
+                    if (text.toLowerCase().includes('quota') || text.toLowerCase().includes('rate limit')) {
+                        console.warn(`[AuthMonster] Quota exceeded for ${auth.account.email} (${auth.provider}). Falling back...`);
+                        await this.reportRateLimit(auth.account.id, 60000, 'QUOTA_EXHAUSTED');
+                        continue; // Try next in chain
+                    }
+                }
+                if (!response.ok) {
+                    const errorText = await response.clone().text().catch(() => 'Unknown error');
+                    console.warn(`[AuthMonster] Request failed for ${auth.account.email} (${auth.provider}): ${response.status} ${errorText}`);
+                    // For non-quota errors, we might still want to report failure but maybe not fallback?
+                    // Actually, let's report failure and see if we should continue.
+                    await this.reportFailure(auth.account.id);
+                    // If it's a 5xx error, maybe we should try another model too.
+                    if (response.status >= 500)
+                        continue;
+                }
+                else {
+                    await this.reportSuccess(auth.account.id);
+                }
+                return response;
+            }
+            catch (error) {
+                console.error(`[AuthMonster] Error during request with ${auth.account.email}:`, error);
+                await this.reportFailure(auth.account.id);
+                lastError = error;
+                continue; // Try next in chain
+            }
+        }
+        throw lastError;
+    }
+    /**
+     * Sends a lightweight request to 'wake up' reasoning models
+     */
+    async runThinkingWarmup(accountId) {
+        const account = this.accounts.find(a => a.id === accountId);
+        if (!account)
+            return;
+        // Only warmup reasoning models (Anthropic Claude 4.5 Opus / Thinking)
+        if (account.provider !== types_1.AuthProvider.Anthropic)
+            return;
+        // Throttle warmups to once every 5 minutes per account
+        const lastWarmup = this.lastWarmupTime.get(accountId) ?? 0;
+        if (Date.now() - lastWarmup < 5 * 60 * 1000)
+            return;
+        const isReasoningModel = account.metadata?.model?.includes('opus') ||
+            account.metadata?.model?.includes('thinking') ||
+            !account.metadata?.model; // Assume reasoning if model unknown for Anthropic
+        if (!isReasoningModel)
+            return;
+        try {
+            const headers = this.getHeadersForAccount(account.provider, account);
+            const url = account.apiKey
+                ? "https://api.anthropic.com/v1/messages"
+                : "https://console.anthropic.com/api/v1/messages";
+            const body = {
+                model: account.metadata?.model || "claude-4.5-opus-thinking",
+                max_tokens: 1,
+                messages: [{ role: "user", content: "Hello" }]
+            };
+            // Enable thinking if supported
+            if (body.model.includes('thinking') || body.model.includes('opus')) {
+                body.thinking = { type: "enabled", budget_tokens: 1024 };
+            }
+            await (0, proxy_1.proxyFetch)(url, {
+                method: "POST",
+                headers,
+                body: JSON.stringify(body),
+                signal: AbortSignal.timeout(5000) // Don't hang on warmup
+            });
+            this.lastWarmupTime.set(accountId, Date.now());
+        }
+        catch (error) {
+            // Warmup failures are non-critical, but log them
+            console.warn(`[AuthMonster] Thinking warmup failed for ${account.email}:`, error);
+        }
+    }
+    /**
+     * Generates headers using provider-specific logic
+     */
+    getHeadersForAccount(provider, account) {
+        switch (provider) {
+            case types_1.AuthProvider.Gemini:
+                return gemini_1.GeminiProvider.getHeaders(account);
+            case types_1.AuthProvider.Anthropic:
+                return anthropic_1.AnthropicProvider.getHeaders(account);
+            case types_1.AuthProvider.Cursor:
+                return cursor_1.cursorProvider.getHeaders(account);
+            case types_1.AuthProvider.Windsurf:
+                return windsurf_1.WindsurfProvider.getHeaders(account);
+            case types_1.AuthProvider.Qwen:
+                return qwen_1.QwenProvider.getHeaders(account);
+            case types_1.AuthProvider.IFlow:
+                return iflow_1.IFlowProvider.getHeaders(account);
+            case types_1.AuthProvider.Kiro:
+                return kiro_1.KiroProvider.getHeaders(account);
+            case types_1.AuthProvider.Zhipu:
+                return zhipu_1.ZhipuProvider.getHeaders(account);
+            case types_1.AuthProvider.Minimax:
+                return minimax_1.MinimaxProvider.getHeaders(account);
+            case types_1.AuthProvider.Azure:
+                return azure_1.AzureProvider.getHeaders(account);
+            case types_1.AuthProvider.Grok:
+                return grok_1.GrokProvider.getHeaders(account);
+            case types_1.AuthProvider.DeepSeek:
+                return deepseek_1.DeepSeekProvider.getHeaders(account);
+            default:
+                // Default header generation fallback
+                const headers = {};
+                if (account.apiKey) {
+                    headers['Authorization'] = `Bearer ${account.apiKey}`;
+                }
+                else if (account.tokens.accessToken) {
+                    headers['Authorization'] = `Bearer ${account.tokens.accessToken}`;
+                }
+                return headers;
+        }
+    }
+    /**
+     * Provider-specific request transformations
+     */
+    transformRequest(provider, body, modelInProvider) {
+        // 1. Cross-model signature sanitization (Gemini <-> Claude conflicts)
+        const sanitizedBody = (0, sanitizer_1.sanitizeCrossModelRequest)(body);
+        // 2. Inject hub-selected model if present
+        if (modelInProvider) {
+            sanitizedBody.model = modelInProvider;
+        }
+        // 3. Provider-specific transformations
+        switch (provider) {
+            case types_1.AuthProvider.Anthropic:
+                return (0, anthropic_1.transformRequest)(sanitizedBody);
+            case types_1.AuthProvider.Gemini:
+                return gemini_1.GeminiProvider.transformRequest(sanitizedBody);
+            default:
+                return sanitizedBody;
+        }
+    }
+    /**
+     * Provider-specific response transformations
+     */
+    transformResponse(provider, text) {
+        switch (provider) {
+            case types_1.AuthProvider.Anthropic:
+                return (0, anthropic_1.transformResponseText)(text);
+            default:
+                return text;
+        }
+    }
+    getRequestUrl(provider, model, account) {
+        if (provider === types_1.AuthProvider.Generic ||
+            (this.config.providers && this.config.providers[provider]?.options?.baseUrl)) {
+            const baseUrl = this.config.providers[provider]?.options?.baseUrl;
+            if (baseUrl) {
+                return `${baseUrl.replace(/\/$/, '')}/chat/completions`;
+            }
+        }
+        switch (provider) {
+            case types_1.AuthProvider.Gemini: return gemini_1.GeminiProvider.getUrl(model, account);
+            case types_1.AuthProvider.Anthropic: return anthropic_1.AnthropicProvider.getUrl(model, account);
+            case types_1.AuthProvider.Cursor: return cursor_1.cursorProvider.getUrl(model, account);
+            case types_1.AuthProvider.Windsurf: return windsurf_1.WindsurfProvider.getUrl(model, account);
+            case types_1.AuthProvider.Qwen: return qwen_1.QwenProvider.getUrl(model, account);
+            case types_1.AuthProvider.Azure: return azure_1.AzureProvider.getUrl(model, account);
+            case types_1.AuthProvider.Grok: return grok_1.GrokProvider.getUrl(model, account);
+            case types_1.AuthProvider.DeepSeek: return deepseek_1.DeepSeekProvider.getUrl(model, account);
+            default: return null;
+        }
+    }
+    async handleWindsurfRequest(auth, options) {
+        let messages = [];
+        let model = auth.modelInProvider || 'default';
+        try {
+            const bodyObj = typeof options.body === 'string' ? JSON.parse(options.body) : options.body;
+            if (bodyObj) {
+                messages = bodyObj.messages || [];
+                if (bodyObj.model)
+                    model = bodyObj.model;
+            }
+        }
+        catch (e) { }
+        const credentials = {
+            apiKey: auth.account.apiKey || auth.account.tokens.accessToken,
+            port: auth.account.metadata?.port,
+            csrfToken: auth.account.metadata?.csrfToken,
+            version: auth.account.metadata?.version
+        };
+        if (!credentials.apiKey || !credentials.port || !credentials.csrfToken) {
+            throw new Error("Missing Windsurf credentials (port, csrfToken, or apiKey)");
+        }
+        const text = await (0, windsurf_1.streamChat)(credentials, { model, messages });
+        return new Response(JSON.stringify({
+            id: 'chatcmpl-' + Date.now(),
+            object: 'chat.completion',
+            created: Math.floor(Date.now() / 1000),
+            model: model,
+            choices: [{
+                    index: 0,
+                    message: { role: 'assistant', content: text },
+                    finish_reason: 'stop'
+                }],
+            usage: { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 }
+        }), { status: 200, headers: { 'Content-Type': 'application/json' } });
+    }
+    /**
+     * Returns all managed accounts (including tokens)
+     */
+    getAccounts() {
+        return this.accounts;
+    }
+    /**
+     * Returns health info for all accounts
+     */
+    getAllAccountsStatus() {
+        return this.accounts.map(acc => ({
+            id: acc.id,
+            email: acc.email,
+            provider: acc.provider,
+            isHealthy: acc.isHealthy,
+            healthScore: acc.healthScore ?? 70, // Default initial score if not set
+            consecutiveFailures: acc.consecutiveFailures ?? 0,
+            lastUsed: acc.lastUsed,
+            cooldownUntil: acc.cooldownUntil,
+            rateLimitResetTime: acc.rateLimitResetTime,
+            lastSwitchReason: acc.lastSwitchReason
+        }));
+    }
+    async addAccount(account) {
+        await this.storage.addAccount(account);
+        await this.init(); // Refresh local cache
+    }
+    async deleteAccount(id) {
+        await this.storage.deleteAccount(id);
+        await this.init(); // Refresh local cache
+    }
+    async reportSuccess(accountId) {
+        const account = this.accounts.find(a => a.id === accountId);
+        if (account) {
+            this.rotator.recordSuccess(account);
+            await this.storage.saveAccounts(this.accounts);
+        }
+    }
+    async reportFailure(accountId) {
+        const account = this.accounts.find(a => a.id === accountId);
+        if (account) {
+            this.rotator.recordFailure(account);
+            await this.storage.saveAccounts(this.accounts);
+        }
+    }
+    async reportRateLimit(accountId, retryAfterMs, reason = 'UNKNOWN') {
+        const account = this.accounts.find(a => a.id === accountId);
+        if (account) {
+            this.rotator.recordRateLimit(account, retryAfterMs, reason);
+            await this.storage.saveAccounts(this.accounts);
+        }
+    }
+}
+exports.AuthMonster = AuthMonster;
+// Example usage/factory
+function createAuthMonster(context) {
+    return new AuthMonster(context);
+}
diff --git a/src/index.ts b/src/index.ts
index 9fb198b..a22176a 100644
--- a/src/index.ts
+++ b/src/index.ts
@@ -10,8 +10,6 @@ import { AccountRotator, RateLimitReason } from './core/rotation';
 import { UnifiedModelHub } from './core/hub';
 import { sanitizeCrossModelRequest } from './utils/sanitizer';
 import { proxyFetch } from './core/proxy';
-import { CostEstimator } from './core/cost-estimator';
-import { HistoryManager } from './core/history';

 // Import Providers
 import { GeminiProvider } from './providers/gemini';
@@ -35,7 +33,6 @@ export class AuthMonster {
   private config: AuthMonsterConfig;
   private rotator: AccountRotator;
   private hub: UnifiedModelHub;
-  private history: HistoryManager;
   private lastUsedAccountId: string | null = null;
   private lastWarmupTime: Map<string, number> = new Map();

@@ -44,7 +41,6 @@ export class AuthMonster {
     this.storage = new StorageManager(context.storagePath);
     this.rotator = new AccountRotator();
     this.hub = new UnifiedModelHub();
-    this.history = new HistoryManager(context.storagePath);
   }

   async init() {
@@ -120,109 +116,29 @@ export class AuthMonster {
     let lastError: any = new Error(`No available accounts for model chain: ${modelChain.join(', ')}`);

     for (const currentModel of modelChain) {
-      let auth = await this.getAuthDetails(currentModel);
-
-      // --- Rate Limit Parking (Phase 3) ---
-      if (!auth) {
-        // If no usable accounts found, check if any are just rate-limited and wait
-        const accountsWithReset = this.accounts.filter(a => a.rateLimitResetTime && a.rateLimitResetTime > Date.now());
-        if (accountsWithReset.length > 0) {
-            const earliestReset = Math.min(...accountsWithReset.map(a => a.rateLimitResetTime!));
-            const waitTime = earliestReset - Date.now();
-
-            // Only park if the wait is reasonable (< 60s)
-            if (waitTime > 0 && waitTime < 60000) {
-                console.log(`[AuthMonster] All accounts busy. Parking request for ${Math.ceil(waitTime / 1000)}s...`);
-                await new Promise(resolve => setTimeout(resolve, waitTime + 100)); // Wait + buffer
-                auth = await this.getAuthDetails(currentModel);
-            }
-        }
-      }
-
+      const auth = await this.getAuthDetails(currentModel);
       if (!auth) continue;

-      const startTime = Date.now();
-      let requestBody = options.body;
-
       try {
         const headers = { ...options.headers, ...auth.headers };
+        let body = options.body;

         // Transform body if it's an object (AI request)
-        if (requestBody && typeof requestBody === 'object' && !(requestBody instanceof FormData) && !(requestBody instanceof Blob)) {
-          requestBody = JSON.stringify(this.transformRequest(auth.provider, requestBody, auth.modelInProvider));
+        if (body && typeof body === 'object' && !(body instanceof FormData) && !(body instanceof Blob)) {
+          body = JSON.stringify(this.transformRequest(auth.provider, body, auth.modelInProvider));
         }

         const targetUrl = this.getRequestUrl(auth.provider, auth.modelInProvider || model, auth.account) || url;

-        let response: Response;
-
         if (auth.provider === AuthProvider.Windsurf) {
-           response = await this.handleWindsurfRequest(auth, options);
-        } else {
-           response = await proxyFetch(targetUrl, {
-             ...options,
-             headers,
-             body: requestBody
-           });
+           return this.handleWindsurfRequest(auth, options);
         }

-        // --- Stats & History Collection (Phase 3) ---
-        const collectStats = async () => {
-             // console.log("[AuthMonster] Collecting stats...");
-             const durationMs = Date.now() - startTime;
-             const responseClone = response.clone();
-             let responseBody: any;
-             let inputTokens = 0;
-             let outputTokens = 0;
-
-             try {
-                 const text = await responseClone.text();
-                 try { responseBody = JSON.parse(text); } catch { responseBody = text; }
-             } catch {}
-
-             // Extract tokens
-             if (responseBody && typeof responseBody === 'object' && responseBody.usage) {
-                 inputTokens = responseBody.usage.prompt_tokens || responseBody.usage.input_tokens || 0;
-                 outputTokens = responseBody.usage.completion_tokens || responseBody.usage.output_tokens || 0;
-             }
-
-             // Estimate tokens if missing
-             if (inputTokens === 0 && typeof requestBody === 'string') inputTokens = CostEstimator.estimateTokens(requestBody);
-             if (outputTokens === 0) {
-                 if (typeof responseBody === 'string') outputTokens = CostEstimator.estimateTokens(responseBody);
-                 else if (responseBody?.choices?.[0]?.message?.content) outputTokens = CostEstimator.estimateTokens(responseBody.choices[0].message.content);
-             }
-
-             const cost = CostEstimator.calculateCost(auth!.modelInProvider || currentModel, inputTokens, outputTokens);
-
-             // Update Usage
-             if (!auth!.account.usage) auth!.account.usage = { totalInputTokens: 0, totalOutputTokens: 0, totalCost: 0 };
-             auth!.account.usage.totalInputTokens += inputTokens;
-             auth!.account.usage.totalOutputTokens += outputTokens;
-             auth!.account.usage.totalCost += cost;
-
-             // Log to History
-             let parsedRequest = requestBody;
-             if (typeof requestBody === 'string') {
-                 try { parsedRequest = JSON.parse(requestBody); } catch {}
-             }
-
-             await this.history.addEntry({
-                 model: currentModel,
-                 provider: auth!.provider,
-                 accountId: auth!.account.id,
-                 tokens: { input: inputTokens, output: outputTokens },
-                 cost,
-                 request: parsedRequest,
-                 response: responseBody,
-                 durationMs,
-                 success: response.ok,
-                 error: !response.ok ? `Status ${response.status}` : undefined
-             });
-        };
-
-        // Don't await stats collection to avoid blocking the response return (fire and forget)
-        collectStats().catch(err => console.error('[AuthMonster] Stats collection failed:', err));
+        const response = await proxyFetch(targetUrl, {
+          ...options,
+          headers,
+          body
+        });

         if (response.status === 429 || response.status === 403) {
           const text = await response.clone().text().catch(() => '');
@@ -236,7 +152,10 @@ export class AuthMonster {
         if (!response.ok) {
           const errorText = await response.clone().text().catch(() => 'Unknown error');
           console.warn(`[AuthMonster] Request failed for ${auth.account.email} (${auth.provider}): ${response.status} ${errorText}`);
+          // For non-quota errors, we might still want to report failure but maybe not fallback?
+          // Actually, let's report failure and see if we should continue.
           await this.reportFailure(auth.account.id);
+          // If it's a 5xx error, maybe we should try another model too.
           if (response.status >= 500) continue;
         } else {
           await this.reportSuccess(auth.account.id);
@@ -245,19 +164,6 @@ export class AuthMonster {
         return response;
       } catch (error) {
         console.error(`[AuthMonster] Error during request with ${auth.account.email}:`, error);
-
-        // Log failure to history
-        this.history.addEntry({
-            model: currentModel,
-            provider: auth.provider,
-            accountId: auth.account.id,
-            request: requestBody,
-            response: null,
-            durationMs: Date.now() - startTime,
-            success: false,
-            error: String(error)
-        }).catch(() => {});
-
         await this.reportFailure(auth.account.id);
         lastError = error;
         continue; // Try next in chain
diff --git a/src/providers/anthropic/index.js b/src/providers/anthropic/index.js
new file mode 100644
index 0000000..ad11525
--- /dev/null
+++ b/src/providers/anthropic/index.js
@@ -0,0 +1,116 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.transformResponseText = exports.transformRequest = exports.AnthropicProvider = void 0;
+const types_1 = require("../../core/types");
+const transform_1 = require("./transform");
+Object.defineProperty(exports, "transformRequest", { enumerable: true, get: function () { return transform_1.transformRequest; } });
+Object.defineProperty(exports, "transformResponseText", { enumerable: true, get: function () { return transform_1.transformResponseText; } });
+const oauth_server_1 = require("../../utils/oauth-server");
+const proxy_1 = require("../../core/proxy");
+const CLIENT_ID = "9d1c250a-e61b-44d9-88ed-5944d1962f5e";
+class AnthropicProvider {
+    static getHeaders(account) {
+        const headers = {
+            'content-type': 'application/json',
+        };
+        if (account.apiKey) {
+            headers['x-api-key'] = account.apiKey;
+            headers['anthropic-version'] = '2023-06-01';
+        }
+        else if (account.tokens.accessToken) {
+            headers['authorization'] = `Bearer ${account.tokens.accessToken}`;
+            // Beta headers logic from reference
+            const betas = [
+                "oauth-2025-04-20",
+                "interleaved-thinking-2025-05-14",
+                "claude-code-20250219" // Always include for now as per reference logic implying it's needed for Claude Code features
+            ];
+            headers['anthropic-beta'] = betas.join(',');
+            headers['user-agent'] = 'claude-cli/2.1.2 (external, cli)';
+        }
+        return headers;
+    }
+    static getUrl(model, account) {
+        return "https://api.anthropic.com/v1/messages";
+    }
+    static async refreshTokens(account) {
+        if (!account.tokens.refreshToken) {
+            return account;
+        }
+        try {
+            const response = await (0, proxy_1.proxyFetch)("https://console.anthropic.com/v1/oauth/token", {
+                method: "POST",
+                headers: {
+                    "Content-Type": "application/json",
+                },
+                body: JSON.stringify({
+                    grant_type: "refresh_token",
+                    refresh_token: account.tokens.refreshToken,
+                    client_id: CLIENT_ID,
+                }),
+            });
+            if (!response.ok) {
+                throw new Error(`Token refresh failed: ${response.status}`);
+            }
+            const json = await response.json();
+            return {
+                ...account,
+                tokens: {
+                    ...account.tokens,
+                    accessToken: json.access_token,
+                    refreshToken: json.refresh_token || account.tokens.refreshToken, // Use new refresh token if provided
+                    expiryDate: Date.now() + json.expires_in * 1000,
+                    tokenType: json.token_type || 'Bearer',
+                },
+                lastUsed: Date.now(),
+            };
+        }
+        catch (error) {
+            console.error('Failed to refresh Anthropic tokens:', error);
+            // Return account as is, or maybe mark as unhealthy?
+            // For now, returning as is but the caller might check expiry.
+            return {
+                ...account,
+                isHealthy: false
+            };
+        }
+    }
+    /**
+     * Performs interactive OAuth login using the standardized local callback server.
+     */
+    static async login() {
+        const port = 1455;
+        const redirectUri = `http://localhost:${port}/callback`;
+        const authUrl = `https://console.anthropic.com/v1/oauth/authorize?response_type=code&client_id=${CLIENT_ID}&redirect_uri=${encodeURIComponent(redirectUri)}&scope=offline_access`;
+        console.log(`\nTo authenticate with Anthropic, please open your browser and visit:`);
+        console.log(`\x1b[36m${authUrl}\x1b[0m\n`);
+        console.log(`Waiting for callback on port ${port}...`);
+        const code = await (0, oauth_server_1.listenForCode)(port);
+        console.log('Code received, exchanging for tokens...');
+        const response = await (0, proxy_1.proxyFetch)("https://console.anthropic.com/v1/oauth/token", {
+            method: "POST",
+            headers: {
+                "Content-Type": "application/json",
+            },
+            body: JSON.stringify({
+                grant_type: "authorization_code",
+                code,
+                client_id: CLIENT_ID,
+                redirect_uri: redirectUri,
+            }),
+        });
+        if (!response.ok) {
+            const errorText = await response.text();
+            throw new Error(`Failed to exchange code for tokens: ${response.status} ${errorText}`);
+        }
+        const json = await response.json();
+        return {
+            accessToken: json.access_token,
+            refreshToken: json.refresh_token,
+            expiryDate: Date.now() + (json.expires_in * 1000),
+            tokenType: json.token_type || 'Bearer',
+        };
+    }
+}
+exports.AnthropicProvider = AnthropicProvider;
+AnthropicProvider.provider = types_1.AuthProvider.Anthropic;
diff --git a/src/providers/anthropic/transform.js b/src/providers/anthropic/transform.js
new file mode 100644
index 0000000..4bccd53
--- /dev/null
+++ b/src/providers/anthropic/transform.js
@@ -0,0 +1,86 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.transformRequest = transformRequest;
+exports.transformResponseText = transformResponseText;
+const TOOL_PREFIX = "mcp_";
+const CLAUDE_USER_ID = "user_7b18c0b8358639d7ff4cdbf78a1552a7d5ca63ba83aee236c4b22ae2be77ba5f_account_3bb3dcbe-4efe-4795-b248-b73603575290_session_4a72737c-93d6-4c45-aebe-6e2d47281338";
+/**
+ * Deeply replaces 'OpenCode' with 'Claude Code' in any string value within an object.
+ */
+function deepSpoof(obj) {
+    if (typeof obj === 'string') {
+        return obj
+            .replace(/OpenCode/g, 'Claude Code')
+            .replace(/opencode/gi, 'Claude');
+    }
+    if (Array.isArray(obj)) {
+        return obj.map(item => deepSpoof(item));
+    }
+    if (typeof obj === 'object' && obj !== null) {
+        const newObj = {};
+        for (const key in obj) {
+            if (Object.prototype.hasOwnProperty.call(obj, key)) {
+                newObj[key] = deepSpoof(obj[key]);
+            }
+        }
+        return newObj;
+    }
+    return obj;
+}
+/**
+ * Transforms the request body for Anthropic.
+ * - Deep spoofs 'OpenCode' to 'Claude Code' in system and messages.
+ * - Prefixes tool names with "mcp_".
+ * - Injects a dummy user_id in metadata for bypass.
+ */
+function transformRequest(body) {
+    const transformed = { ...body };
+    // Apply deep spoofing specifically to system and messages to bypass server-side blocks
+    if (transformed.system) {
+        transformed.system = deepSpoof(transformed.system);
+    }
+    if (transformed.messages && Array.isArray(transformed.messages)) {
+        transformed.messages = transformed.messages.map((msg) => ({
+            ...msg,
+            content: deepSpoof(msg.content)
+        }));
+    }
+    // Add user_id to metadata if missing
+    if (!transformed.metadata) {
+        transformed.metadata = {};
+    }
+    if (!transformed.metadata.user_id) {
+        transformed.metadata.user_id = CLAUDE_USER_ID;
+    }
+    // Add prefix to tools definitions
+    if (transformed.tools && Array.isArray(transformed.tools)) {
+        transformed.tools = transformed.tools.map((tool) => ({
+            ...tool,
+            name: tool.name ? (tool.name.startsWith(TOOL_PREFIX) ? tool.name : `${TOOL_PREFIX}${tool.name}`) : tool.name,
+        }));
+    }
+    // Add prefix to tool_use blocks in messages
+    if (transformed.messages && Array.isArray(transformed.messages)) {
+        transformed.messages = transformed.messages.map((msg) => {
+            if (msg.content && Array.isArray(msg.content)) {
+                msg.content = msg.content.map((block) => {
+                    if (block.type === "tool_use" && block.name) {
+                        return {
+                            ...block,
+                            name: block.name.startsWith(TOOL_PREFIX) ? block.name : `${TOOL_PREFIX}${block.name}`
+                        };
+                    }
+                    return block;
+                });
+            }
+            return msg;
+        });
+    }
+    return transformed;
+}
+/**
+ * Transforms the response text to remove the tool prefix.
+ */
+function transformResponseText(text) {
+    return text.replace(/"name"\s*:\s*"mcp_([^"]+)"/g, '"name": "$1"');
+}
diff --git a/src/providers/azure/index.js b/src/providers/azure/index.js
new file mode 100644
index 0000000..2810a10
--- /dev/null
+++ b/src/providers/azure/index.js
@@ -0,0 +1,32 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.AzureProvider = void 0;
+const types_1 = require("../../core/types");
+class AzureProvider {
+    static getHeaders(account) {
+        const headers = {
+            'Content-Type': 'application/json',
+        };
+        if (account.apiKey) {
+            headers['api-key'] = account.apiKey;
+        }
+        else if (account.tokens.accessToken) {
+            // Azure AD auth support
+            headers['Authorization'] = `Bearer ${account.tokens.accessToken}`;
+        }
+        return headers;
+    }
+    static getUrl(model, account) {
+        const resourceName = account.metadata?.resourceName;
+        const deploymentId = account.metadata?.deploymentId || model;
+        const apiVersion = account.metadata?.apiVersion || '2024-02-15-preview';
+        if (!resourceName) {
+            // Fallback or error? For now return a placeholder that will likely fail DNS if not set,
+            // reminding user to set metadata.
+            return `https://YOUR_RESOURCE_NAME.openai.azure.com/openai/deployments/${deploymentId}/chat/completions?api-version=${apiVersion}`;
+        }
+        return `https://${resourceName}.openai.azure.com/openai/deployments/${deploymentId}/chat/completions?api-version=${apiVersion}`;
+    }
+}
+exports.AzureProvider = AzureProvider;
+AzureProvider.provider = types_1.AuthProvider.Azure;
diff --git a/src/providers/cursor/index.js b/src/providers/cursor/index.js
new file mode 100644
index 0000000..e23f964
--- /dev/null
+++ b/src/providers/cursor/index.js
@@ -0,0 +1,93 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.cursorProvider = exports.CursorProvider = void 0;
+const node_crypto_1 = require("node:crypto");
+const types_1 = require("../../core/types");
+const proto_1 = require("./proto");
+const extractor_1 = require("../../utils/extractor");
+const proxy_1 = require("../../core/proxy");
+const CURSOR_API_BASE_URL = "https://api2.cursor.sh";
+const REFRESH_ENDPOINT = "/auth/refresh";
+class CursorProvider {
+    /**
+     * Get request headers for Cursor API
+     */
+    getHeaders(account) {
+        const accessToken = account.tokens.accessToken;
+        const checksum = (0, proto_1.generateChecksum)(accessToken);
+        return {
+            "authorization": `Bearer ${accessToken}`,
+            "content-type": "application/grpc-web+proto",
+            "user-agent": "connect-es/1.4.0",
+            "x-cursor-checksum": checksum,
+            "x-cursor-client-version": "cli-2025.11.25-d5b3271",
+            "x-cursor-client-type": "cli",
+            "x-cursor-timezone": Intl.DateTimeFormat().resolvedOptions().timeZone,
+            "x-ghost-mode": "true",
+            "x-request-id": (0, node_crypto_1.randomUUID)(),
+            "host": new URL(CURSOR_API_BASE_URL).host,
+        };
+    }
+    getUrl(model, account) {
+        return `${CURSOR_API_BASE_URL}/aiserver.v1.AiService/StreamChat`;
+    }
+    /**
+     * Refresh the access token using the refresh token
+     */
+    async refreshTokens(refreshToken) {
+        try {
+            const response = await (0, proxy_1.proxyFetch)(`${CURSOR_API_BASE_URL}${REFRESH_ENDPOINT}`, {
+                method: "POST",
+                headers: {
+                    "Content-Type": "application/json",
+                    "Authorization": `Bearer ${refreshToken}`,
+                },
+                body: JSON.stringify({}),
+            });
+            if (!response.ok) {
+                return null;
+            }
+            const result = await response.json();
+            if (typeof result === "object" &&
+                result !== null &&
+                "accessToken" in result &&
+                "refreshToken" in result) {
+                return {
+                    accessToken: result.accessToken,
+                    refreshToken: result.refreshToken,
+                    // Cursor tokens are JWTs, but we don't parse them here to get expiry.
+                    // The consumer can parse the JWT if needed.
+                    tokenType: 'Bearer'
+                };
+            }
+        }
+        catch (error) {
+            console.error("Failed to refresh Cursor tokens:", error);
+        }
+        return null;
+    }
+    /**
+     * Automatically discover local Cursor accounts
+     */
+    async discover() {
+        const data = extractor_1.TokenExtractor.extractCursorFromKeychain() || extractor_1.TokenExtractor.extractCursorFromSQLite();
+        if (!data)
+            return null;
+        // data is string (accessToken)
+        return {
+            id: `cursor-local-${Date.now()}`,
+            email: 'local@cursor',
+            provider: types_1.AuthProvider.Cursor,
+            tokens: {
+                accessToken: data,
+            },
+            isHealthy: true,
+            metadata: {
+                discoveredAt: Date.now(),
+                method: 'local'
+            }
+        };
+    }
+}
+exports.CursorProvider = CursorProvider;
+exports.cursorProvider = new CursorProvider();
diff --git a/src/providers/cursor/proto.js b/src/providers/cursor/proto.js
new file mode 100644
index 0000000..1c75286
--- /dev/null
+++ b/src/providers/cursor/proto.js
@@ -0,0 +1,130 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.generateChecksum = generateChecksum;
+exports.addConnectEnvelope = addConnectEnvelope;
+exports.encodeVarint = encodeVarint;
+exports.encodeStringField = encodeStringField;
+exports.encodeInt32Field = encodeInt32Field;
+exports.encodeMessageField = encodeMessageField;
+exports.concatBytes = concatBytes;
+const node_crypto_1 = require("node:crypto");
+// --- Checksum Generation ---
+/**
+ * Generate checksum for Cursor API requests
+ * Based on OpenCursor's implementation
+ */
+function generateChecksum(token) {
+    const salt = token.split(".");
+    // XOR-based obfuscation
+    const calc = (data) => {
+        let t = 165;
+        for (let i = 0; i < data.length; i++) {
+            data[i] = ((data[i] ^ t) + i) & 0xff;
+            t = data[i];
+        }
+    };
+    // Timestamp rounded to 30-minute intervals
+    const now = new Date();
+    now.setMinutes(30 * Math.floor(now.getMinutes() / 30), 0, 0);
+    const timestamp = Math.floor(now.getTime() / 1e6);
+    // Create timestamp buffer
+    const timestampBuffer = Buffer.alloc(6);
+    let temp = timestamp;
+    for (let i = 5; i >= 0; i--) {
+        timestampBuffer[i] = temp & 0xff;
+        temp = Math.floor(temp / 256);
+    }
+    calc(timestampBuffer);
+    // SHA-256 hashes
+    const calcHex = (input) => {
+        return (0, node_crypto_1.createHash)("sha256").update(input).digest("hex").slice(0, 8);
+    };
+    const hex1 = salt[1] ? calcHex(salt[1]) : "00000000";
+    const hex2 = calcHex(token);
+    return `${timestampBuffer.toString("base64url")}${hex1}/${hex2}`;
+}
+// --- Connect-RPC / Protobuf Helpers ---
+/**
+ * Add Connect-RPC envelope (5-byte header)
+ * Format: [flags: 1 byte][length: 4 bytes big-endian][payload]
+ */
+function addConnectEnvelope(data, flags = 0) {
+    const result = new Uint8Array(5 + data.length);
+    result[0] = flags;
+    result[1] = (data.length >> 24) & 0xff;
+    result[2] = (data.length >> 16) & 0xff;
+    result[3] = (data.length >> 8) & 0xff;
+    result[4] = data.length & 0xff;
+    result.set(data, 5);
+    return result;
+}
+/**
+ * Encode a varint (variable-length integer)
+ */
+function encodeVarint(value) {
+    const bytes = [];
+    while (value > 127) {
+        bytes.push((value & 0x7f) | 0x80);
+        value >>>= 7;
+    }
+    bytes.push(value);
+    return new Uint8Array(bytes);
+}
+/**
+ * Encode a string field in protobuf format
+ * Field format: (field_number << 3) | wire_type
+ * String wire type = 2
+ */
+function encodeStringField(fieldNumber, value) {
+    if (!value)
+        return new Uint8Array(0);
+    const fieldTag = (fieldNumber << 3) | 2; // wire type 2 = length-delimited
+    const encoded = new TextEncoder().encode(value);
+    const length = encodeVarint(encoded.length);
+    const result = new Uint8Array(1 + length.length + encoded.length);
+    result[0] = fieldTag;
+    result.set(length, 1);
+    result.set(encoded, 1 + length.length);
+    return result;
+}
+/**
+ * Encode an int32 field in protobuf format
+ * Wire type = 0 (varint)
+ */
+function encodeInt32Field(fieldNumber, value) {
+    if (value === 0)
+        return new Uint8Array(0);
+    const fieldTag = (fieldNumber << 3) | 0; // wire type 0 = varint
+    const encoded = encodeVarint(value);
+    const result = new Uint8Array(1 + encoded.length);
+    result[0] = fieldTag;
+    result.set(encoded, 1);
+    return result;
+}
+/**
+ * Encode a nested message field
+ */
+function encodeMessageField(fieldNumber, data) {
+    if (data.length === 0)
+        return new Uint8Array(0);
+    const fieldTag = (fieldNumber << 3) | 2; // wire type 2 = length-delimited
+    const length = encodeVarint(data.length);
+    const result = new Uint8Array(1 + length.length + data.length);
+    result[0] = fieldTag;
+    result.set(length, 1);
+    result.set(data, 1 + length.length);
+    return result;
+}
+/**
+ * Concatenate multiple Uint8Arrays
+ */
+function concatBytes(...arrays) {
+    const totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);
+    const result = new Uint8Array(totalLength);
+    let offset = 0;
+    for (const arr of arrays) {
+        result.set(arr, offset);
+        offset += arr.length;
+    }
+    return result;
+}
diff --git a/src/providers/deepseek/index.js b/src/providers/deepseek/index.js
new file mode 100644
index 0000000..91771bf
--- /dev/null
+++ b/src/providers/deepseek/index.js
@@ -0,0 +1,23 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.DeepSeekProvider = void 0;
+const types_1 = require("../../core/types");
+class DeepSeekProvider {
+    static getHeaders(account) {
+        const headers = {
+            'Content-Type': 'application/json',
+        };
+        if (account.apiKey) {
+            headers['Authorization'] = `Bearer ${account.apiKey}`;
+        }
+        else if (account.tokens.accessToken) {
+            headers['Authorization'] = `Bearer ${account.tokens.accessToken}`;
+        }
+        return headers;
+    }
+    static getUrl(model, account) {
+        return "https://api.deepseek.com/chat/completions";
+    }
+}
+exports.DeepSeekProvider = DeepSeekProvider;
+DeepSeekProvider.provider = types_1.AuthProvider.DeepSeek;
diff --git a/src/providers/gemini/index.js b/src/providers/gemini/index.js
new file mode 100644
index 0000000..bd764eb
--- /dev/null
+++ b/src/providers/gemini/index.js
@@ -0,0 +1,198 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.GeminiProvider = void 0;
+const types_1 = require("../../core/types");
+const oauth_server_1 = require("../../utils/oauth-server");
+const proxy_1 = require("../../core/proxy");
+const GEMINI_CLIENT_ID = process.env.GEMINI_CLIENT_ID || "";
+const GEMINI_CLIENT_SECRET = process.env.GEMINI_CLIENT_SECRET || "";
+const GEMINI_SCOPES = [
+    "https://www.googleapis.com/auth/cloud-platform",
+    "https://www.googleapis.com/auth/userinfo.email",
+    "https://www.googleapis.com/auth/userinfo.profile"
+];
+class GeminiProvider {
+    static getHeaders(account) {
+        const headers = {
+            'Content-Type': 'application/json',
+        };
+        if (account.apiKey) {
+            headers['x-goog-api-key'] = account.apiKey;
+        }
+        else if (account.tokens.accessToken) {
+            headers['Authorization'] = `Bearer ${account.tokens.accessToken}`;
+        }
+        // Ported from vibe-open-auth: Multi-account metadata headers if needed
+        if (account.metadata?.projectId) {
+            headers['x-goog-user-project'] = account.metadata.projectId;
+        }
+        return headers;
+    }
+    static getUrl(model, account) {
+        return `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;
+    }
+    static async refreshTokens(account) {
+        if (!account.tokens.refreshToken) {
+            return account;
+        }
+        try {
+            // Parse project ID from refresh token if it was stored that way (ref: shantur-opencode-gemini-auth)
+            const [refreshToken, projectId = ""] = account.tokens.refreshToken.split('|');
+            const response = await (0, proxy_1.proxyFetch)("https://oauth2.googleapis.com/token", {
+                method: "POST",
+                headers: {
+                    "Content-Type": "application/x-www-form-urlencoded",
+                },
+                body: new URLSearchParams({
+                    grant_type: "refresh_token",
+                    refresh_token: refreshToken,
+                    client_id: GEMINI_CLIENT_ID,
+                    client_secret: GEMINI_CLIENT_SECRET,
+                }),
+            });
+            if (!response.ok) {
+                throw new Error(`Token refresh failed: ${response.status}`);
+            }
+            const json = await response.json();
+            return {
+                ...account,
+                tokens: {
+                    ...account.tokens,
+                    accessToken: json.access_token,
+                    refreshToken: json.refresh_token ? `${json.refresh_token}|${projectId}` : account.tokens.refreshToken,
+                    expiryDate: Date.now() + (json.expires_in * 1000),
+                    tokenType: json.token_type || 'Bearer',
+                },
+                lastUsed: Date.now(),
+                isHealthy: true
+            };
+        }
+        catch (error) {
+            console.error('Failed to refresh Gemini tokens:', error);
+            return {
+                ...account,
+                isHealthy: false
+            };
+        }
+    }
+    /**
+     * Performs interactive OAuth login using the standardized local callback server.
+     */
+    static async login() {
+        const port = 1455;
+        const redirectUri = `http://localhost:${port}/callback`;
+        const pkce = await (0, oauth_server_1.generatePKCE)();
+        // Optional: Ask for project ID
+        console.log("\n=== Google Gemini OAuth Setup ===");
+        console.log("If you have a specific Google Cloud Project ID, you can use it.");
+        console.log("Otherwise, the system will attempt to use/create a managed project.");
+        // In a real CLI we would use readline, but here we'll just proceed with default/empty
+        const projectId = "";
+        const url = new URL("https://accounts.google.com/o/oauth2/v2/auth");
+        url.searchParams.set("client_id", GEMINI_CLIENT_ID);
+        url.searchParams.set("response_type", "code");
+        url.searchParams.set("redirect_uri", redirectUri);
+        url.searchParams.set("scope", GEMINI_SCOPES.join(" "));
+        url.searchParams.set("code_challenge", pkce.challenge);
+        url.searchParams.set("code_challenge_method", "S256");
+        url.searchParams.set("state", Buffer.from(JSON.stringify({ verifier: pkce.verifier, projectId })).toString('base64'));
+        url.searchParams.set("access_type", "offline");
+        url.searchParams.set("prompt", "consent");
+        console.log(`\nPlease visit the following URL to authorize Gemini:\n`);
+        console.log(`\x1b[36m${url.toString()}\x1b[0m\n`);
+        console.log(`Waiting for callback on port ${port}...`);
+        const codeWithState = await (0, oauth_server_1.listenForCode)(port);
+        const [code, state] = codeWithState.split('#');
+        console.log('Code received, exchanging for tokens...');
+        const { verifier, projectId: stateProjectId } = JSON.parse(Buffer.from(state, 'base64').toString());
+        const response = await (0, proxy_1.proxyFetch)("https://oauth2.googleapis.com/token", {
+            method: "POST",
+            headers: {
+                "Content-Type": "application/x-www-form-urlencoded",
+            },
+            body: new URLSearchParams({
+                client_id: GEMINI_CLIENT_ID,
+                client_secret: GEMINI_CLIENT_SECRET,
+                code: code,
+                grant_type: "authorization_code",
+                redirect_uri: redirectUri,
+                code_verifier: verifier,
+            }),
+        });
+        if (!response.ok) {
+            const errorText = await response.text();
+            throw new Error(`Failed to exchange Gemini code: ${response.status} ${errorText}`);
+        }
+        const json = await response.json();
+        // Get user info to get email
+        const userInfoResponse = await (0, proxy_1.proxyFetch)("https://www.googleapis.com/oauth2/v1/userinfo?alt=json", {
+            headers: {
+                "Authorization": `Bearer ${json.access_token}`
+            }
+        });
+        const userInfo = userInfoResponse.ok ? await userInfoResponse.json() : { email: 'unknown@google.com' };
+        return {
+            accessToken: json.access_token,
+            refreshToken: `${json.refresh_token}|${stateProjectId || ""}`,
+            expiryDate: Date.now() + (json.expires_in * 1000),
+            tokenType: json.token_type || 'Bearer',
+            email: userInfo.email,
+            metadata: {
+                projectId: stateProjectId
+            }
+        };
+    }
+    /**
+     * Transforms standardized OpenAI-like request to Gemini's format.
+     */
+    static transformRequest(body) {
+        if (body.contents)
+            return body; // Already in Gemini format
+        const transformed = {
+            contents: []
+        };
+        if (body.messages && Array.isArray(body.messages)) {
+            transformed.contents = body.messages.map((msg) => {
+                // Convert roles
+                let role = msg.role;
+                if (role === 'assistant')
+                    role = 'model';
+                if (role === 'system')
+                    role = 'user'; // Gemini system instruction is handled differently but for simple cases we can map to user
+                // Convert content to parts
+                let parts = [];
+                if (typeof msg.content === 'string') {
+                    parts = [{ text: msg.content }];
+                }
+                else if (Array.isArray(msg.content)) {
+                    parts = msg.content.map((part) => {
+                        if (part.type === 'text')
+                            return { text: part.text };
+                        if (part.type === 'image_url') {
+                            // Handle image mapping if needed
+                            return { text: '[Image]' };
+                        }
+                        return part;
+                    });
+                }
+                return { role, parts };
+            });
+        }
+        // Move model
+        if (body.model) {
+            // In Gemini API, the model is often in the URL, but some clients expect it in body
+            transformed.model = body.model;
+        }
+        // Safety settings, generation config, etc.
+        transformed.generationConfig = {
+            temperature: body.temperature,
+            maxOutputTokens: body.max_tokens,
+            topP: body.top_p,
+            topK: body.top_k,
+            stopSequences: body.stop
+        };
+        return transformed;
+    }
+}
+exports.GeminiProvider = GeminiProvider;
+GeminiProvider.provider = types_1.AuthProvider.Gemini;
diff --git a/src/providers/grok/index.js b/src/providers/grok/index.js
new file mode 100644
index 0000000..683c589
--- /dev/null
+++ b/src/providers/grok/index.js
@@ -0,0 +1,23 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.GrokProvider = void 0;
+const types_1 = require("../../core/types");
+class GrokProvider {
+    static getHeaders(account) {
+        const headers = {
+            'Content-Type': 'application/json',
+        };
+        if (account.apiKey) {
+            headers['Authorization'] = `Bearer ${account.apiKey}`;
+        }
+        else if (account.tokens.accessToken) {
+            headers['Authorization'] = `Bearer ${account.tokens.accessToken}`;
+        }
+        return headers;
+    }
+    static getUrl(model, account) {
+        return "https://api.x.ai/v1/chat/completions";
+    }
+}
+exports.GrokProvider = GrokProvider;
+GrokProvider.provider = types_1.AuthProvider.Grok;
diff --git a/src/providers/iflow/index.js b/src/providers/iflow/index.js
new file mode 100644
index 0000000..8f95834
--- /dev/null
+++ b/src/providers/iflow/index.js
@@ -0,0 +1,140 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.IFlowProvider = void 0;
+const types_1 = require("../../core/types");
+const proxy_1 = require("../../core/proxy");
+const oauth_server_1 = require("../../utils/oauth-server");
+const CLIENT_ID = "10009311001";
+const CLIENT_SECRET = process.env.IFLOW_CLIENT_SECRET || "4Z3YjXycVsQvyGF1etiNlIBB4RsqSDtW";
+const AUTH_URL = "https://iflow.cn/oauth";
+const TOKEN_URL = "https://iflow.cn/oauth/token";
+const USER_INFO_URL = "https://iflow.cn/api/oauth/getUserInfo";
+const CALLBACK_PORT = 11451;
+class IFlowProvider {
+    static getHeaders(account) {
+        const headers = {
+            'content-type': 'application/json',
+        };
+        if (account.apiKey) {
+            headers['Authorization'] = `Bearer ${account.apiKey}`;
+        }
+        else if (account.tokens.accessToken) {
+            headers['Authorization'] = `Bearer ${account.tokens.accessToken}`;
+        }
+        return headers;
+    }
+    static async refreshTokens(account) {
+        if (!account.tokens.refreshToken) {
+            return account;
+        }
+        try {
+            const basic = Buffer.from(`${CLIENT_ID}:${CLIENT_SECRET}`).toString('base64');
+            const response = await (0, proxy_1.proxyFetch)(TOKEN_URL, {
+                method: "POST",
+                headers: {
+                    "Content-Type": "application/x-www-form-urlencoded",
+                    "Accept": "application/json",
+                    "Authorization": `Basic ${basic}`
+                },
+                body: new URLSearchParams({
+                    grant_type: "refresh_token",
+                    refresh_token: account.tokens.refreshToken,
+                    client_id: CLIENT_ID,
+                    client_secret: CLIENT_SECRET
+                }).toString()
+            });
+            if (!response.ok) {
+                throw new Error(`Token refresh failed: ${response.status}`);
+            }
+            const json = await response.json();
+            return {
+                ...account,
+                tokens: {
+                    ...account.tokens,
+                    accessToken: json.access_token,
+                    refreshToken: json.refresh_token || account.tokens.refreshToken,
+                    expiryDate: Date.now() + json.expires_in * 1000,
+                    tokenType: json.token_type || 'Bearer',
+                },
+                lastUsed: Date.now(),
+            };
+        }
+        catch (error) {
+            console.error('Failed to refresh iFlow tokens:', error);
+            return {
+                ...account,
+                isHealthy: false
+            };
+        }
+    }
+    static async login() {
+        const redirectUri = `http://localhost:${CALLBACK_PORT}/oauth2callback`;
+        const state = Math.random().toString(36).substring(7);
+        const params = new URLSearchParams({
+            loginMethod: "phone",
+            type: "phone",
+            redirect: redirectUri,
+            state: state,
+            client_id: CLIENT_ID
+        });
+        const authUrl = `${AUTH_URL}?${params.toString()}`;
+        console.log(`\nTo authenticate with iFlow, please open your browser and visit:`);
+        console.log(`\x1b[36m${authUrl}\x1b[0m\n`);
+        console.log(`Waiting for callback on port ${CALLBACK_PORT}...`);
+        const codeWithState = await (0, oauth_server_1.listenForCode)(CALLBACK_PORT);
+        const code = codeWithState.split('#')[0];
+        console.log('Code received, exchanging for tokens...');
+        const basic = Buffer.from(`${CLIENT_ID}:${CLIENT_SECRET}`).toString('base64');
+        const response = await (0, proxy_1.proxyFetch)(TOKEN_URL, {
+            method: "POST",
+            headers: {
+                "Content-Type": "application/x-www-form-urlencoded",
+                "Accept": "application/json",
+                "Authorization": `Basic ${basic}`
+            },
+            body: new URLSearchParams({
+                grant_type: "authorization_code",
+                code,
+                redirect_uri: redirectUri,
+                client_id: CLIENT_ID,
+                client_secret: CLIENT_SECRET,
+            }).toString()
+        });
+        if (!response.ok) {
+            const errorText = await response.text();
+            throw new Error(`Failed to exchange code for tokens: ${response.status} ${errorText}`);
+        }
+        const json = await response.json();
+        const accessToken = json.access_token;
+        // Fetch User Info to get API Key
+        let apiKey = undefined;
+        let email = undefined;
+        if (accessToken) {
+            try {
+                const userInfoResp = await (0, proxy_1.proxyFetch)(`${USER_INFO_URL}?accessToken=${encodeURIComponent(accessToken)}`, {
+                    headers: { "Accept": "application/json" }
+                });
+                if (userInfoResp.ok) {
+                    const userInfo = await userInfoResp.json();
+                    if (userInfo.success && userInfo.data) {
+                        apiKey = userInfo.data.apiKey;
+                        email = userInfo.data.email || userInfo.data.phone;
+                    }
+                }
+            }
+            catch (e) {
+                console.warn("Failed to fetch iFlow user info:", e);
+            }
+        }
+        return {
+            accessToken: json.access_token,
+            refreshToken: json.refresh_token,
+            expiryDate: Date.now() + (json.expires_in * 1000),
+            tokenType: json.token_type || 'Bearer',
+            apiKey,
+            email
+        };
+    }
+}
+exports.IFlowProvider = IFlowProvider;
+IFlowProvider.provider = types_1.AuthProvider.IFlow;
diff --git a/src/providers/iflow/index.ts b/src/providers/iflow/index.ts
index 2462c5f..a6e7097 100644
--- a/src/providers/iflow/index.ts
+++ b/src/providers/iflow/index.ts
@@ -3,7 +3,7 @@ import { proxyFetch } from '../../core/proxy';
 import { listenForCode } from '../../utils/oauth-server';

 const CLIENT_ID = "10009311001";
-const CLIENT_SECRET = process.env.IFLOW_CLIENT_SECRET || "";
+const CLIENT_SECRET = process.env.IFLOW_CLIENT_SECRET || "4Z3YjXycVsQvyGF1etiNlIBB4RsqSDtW";
 const AUTH_URL = "https://iflow.cn/oauth";
 const TOKEN_URL = "https://iflow.cn/oauth/token";
 const USER_INFO_URL = "https://iflow.cn/api/oauth/getUserInfo";
diff --git a/src/providers/kiro/index.js b/src/providers/kiro/index.js
new file mode 100644
index 0000000..c554495
--- /dev/null
+++ b/src/providers/kiro/index.js
@@ -0,0 +1,36 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.KiroProvider = void 0;
+const types_1 = require("../../core/types");
+const extractor_1 = require("../../utils/extractor");
+class KiroProvider {
+    static getHeaders(account) {
+        const headers = {
+            'content-type': 'application/x-amz-json-1.0',
+        };
+        if (account.tokens.accessToken) {
+            headers['Authorization'] = `Bearer ${account.tokens.accessToken}`;
+        }
+        return headers;
+    }
+    static async discoverAccount() {
+        const token = await extractor_1.TokenExtractor.extractKiroFromSSOCache();
+        if (!token)
+            return null;
+        return {
+            id: `kiro-local-${Date.now()}`,
+            email: token.email || 'local-kiro@aws',
+            provider: types_1.AuthProvider.Kiro,
+            tokens: {
+                accessToken: token.token,
+            },
+            isHealthy: true,
+            healthScore: 100,
+            metadata: {
+                source: 'aws-sso-cache'
+            }
+        };
+    }
+}
+exports.KiroProvider = KiroProvider;
+KiroProvider.provider = types_1.AuthProvider.Kiro;
diff --git a/src/providers/minimax/index.js b/src/providers/minimax/index.js
new file mode 100644
index 0000000..40ac280
--- /dev/null
+++ b/src/providers/minimax/index.js
@@ -0,0 +1,26 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.MinimaxProvider = void 0;
+const types_1 = require("../../core/types");
+class MinimaxProvider {
+    static getHeaders(account) {
+        const headers = {
+            'content-type': 'application/json',
+        };
+        if (account.apiKey) {
+            headers['Authorization'] = `Bearer ${account.apiKey}`;
+        }
+        return headers;
+    }
+    static async login() {
+        const { Password } = require('enquirer');
+        const prompt = new Password({
+            name: 'apiKey',
+            message: 'Enter your MiniMax API Key'
+        });
+        const apiKey = await prompt.run();
+        return { apiKey };
+    }
+}
+exports.MinimaxProvider = MinimaxProvider;
+MinimaxProvider.provider = types_1.AuthProvider.Minimax;
diff --git a/src/providers/qwen/index.js b/src/providers/qwen/index.js
new file mode 100644
index 0000000..3eed33d
--- /dev/null
+++ b/src/providers/qwen/index.js
@@ -0,0 +1,185 @@
+"use strict";
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+    Object.defineProperty(o, "default", { enumerable: true, value: v });
+}) : function(o, v) {
+    o["default"] = v;
+});
+var __importStar = (this && this.__importStar) || (function () {
+    var ownKeys = function(o) {
+        ownKeys = Object.getOwnPropertyNames || function (o) {
+            var ar = [];
+            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
+            return ar;
+        };
+        return ownKeys(o);
+    };
+    return function (mod) {
+        if (mod && mod.__esModule) return mod;
+        var result = {};
+        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
+        __setModuleDefault(result, mod);
+        return result;
+    };
+})();
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.QwenProvider = void 0;
+const types_1 = require("../../core/types");
+const proxy_1 = require("../../core/proxy");
+const crypto = __importStar(require("crypto"));
+const CLIENT_ID = "f0304373b74a44d2b584a3fb70ca9e56";
+const DEVICE_CODE_URL = "https://chat.qwen.ai/api/v1/oauth2/device/code";
+const TOKEN_URL = "https://chat.qwen.ai/api/v1/oauth2/token";
+const SCOPE = "openid profile email model.completion";
+const GRANT_TYPE = "urn:ietf:params:oauth:grant-type:device_code";
+function generateCodeVerifier() {
+    return base64URLEncode(crypto.randomBytes(32));
+}
+function generateCodeChallenge(verifier) {
+    return base64URLEncode(crypto.createHash('sha256').update(verifier).digest());
+}
+function base64URLEncode(buffer) {
+    return buffer.toString('base64')
+        .replace(/\+/g, '-')
+        .replace(/\//g, '_')
+        .replace(/=/g, '');
+}
+class QwenProvider {
+    static getHeaders(account) {
+        const headers = {
+            'content-type': 'application/json',
+        };
+        if (account.tokens.accessToken) {
+            headers['authorization'] = `Bearer ${account.tokens.accessToken}`;
+        }
+        return headers;
+    }
+    static getUrl(model, account) {
+        return "https://chat.qwen.ai/api/v1/chat/completions";
+    }
+    static async refreshTokens(account) {
+        if (!account.tokens.refreshToken) {
+            return account;
+        }
+        try {
+            const response = await (0, proxy_1.proxyFetch)(TOKEN_URL, {
+                method: "POST",
+                headers: {
+                    "Content-Type": "application/x-www-form-urlencoded",
+                    "Accept": "application/json"
+                },
+                body: new URLSearchParams({
+                    grant_type: "refresh_token",
+                    refresh_token: account.tokens.refreshToken,
+                    client_id: CLIENT_ID,
+                }).toString()
+            });
+            if (!response.ok) {
+                throw new Error(`Token refresh failed: ${response.status}`);
+            }
+            const json = await response.json();
+            return {
+                ...account,
+                tokens: {
+                    ...account.tokens,
+                    accessToken: json.access_token,
+                    refreshToken: json.refresh_token || account.tokens.refreshToken,
+                    expiryDate: Date.now() + json.expires_in * 1000,
+                    tokenType: json.token_type || 'Bearer',
+                },
+                lastUsed: Date.now(),
+            };
+        }
+        catch (error) {
+            console.error('Failed to refresh Qwen tokens:', error);
+            return {
+                ...account,
+                isHealthy: false
+            };
+        }
+    }
+    static async login() {
+        // 1. Generate PKCE
+        const verifier = generateCodeVerifier();
+        const challenge = generateCodeChallenge(verifier);
+        // 2. Initiate Device Flow
+        const deviceResp = await (0, proxy_1.proxyFetch)(DEVICE_CODE_URL, {
+            method: 'POST',
+            headers: {
+                'Content-Type': 'application/x-www-form-urlencoded',
+                'Accept': 'application/json'
+            },
+            body: new URLSearchParams({
+                client_id: CLIENT_ID,
+                scope: SCOPE,
+                code_challenge: challenge,
+                code_challenge_method: 'S256'
+            }).toString()
+        });
+        if (!deviceResp.ok) {
+            throw new Error(`Device flow initiation failed: ${deviceResp.status} ${await deviceResp.text()}`);
+        }
+        const deviceData = await deviceResp.json();
+        const deviceCode = deviceData.device_code;
+        const userCode = deviceData.user_code;
+        const verificationUri = deviceData.verification_uri_complete || deviceData.verification_uri;
+        const interval = deviceData.interval || 5;
+        console.log(`\nTo authenticate with Qwen, please visit:`);
+        console.log(`\x1b[36m${verificationUri}\x1b[0m`);
+        console.log(`And enter code: \x1b[1m${userCode}\x1b[0m\n`);
+        console.log(`Waiting for confirmation...`);
+        // 3. Poll for token
+        while (true) {
+            await new Promise(resolve => setTimeout(resolve, interval * 1000));
+            const tokenResp = await (0, proxy_1.proxyFetch)(TOKEN_URL, {
+                method: 'POST',
+                headers: {
+                    'Content-Type': 'application/x-www-form-urlencoded'
+                },
+                body: new URLSearchParams({
+                    grant_type: GRANT_TYPE,
+                    client_id: CLIENT_ID,
+                    device_code: deviceCode,
+                    code_verifier: verifier
+                }).toString()
+            });
+            if (tokenResp.ok) {
+                const json = await tokenResp.json();
+                return {
+                    accessToken: json.access_token,
+                    refreshToken: json.refresh_token,
+                    expiryDate: Date.now() + (json.expires_in * 1000),
+                    tokenType: json.token_type || 'Bearer'
+                };
+            }
+            const errorText = await tokenResp.text();
+            let errorData = {};
+            try {
+                errorData = JSON.parse(errorText);
+            }
+            catch { }
+            if (errorData.error === 'authorization_pending') {
+                continue;
+            }
+            else if (errorData.error === 'slow_down') {
+                await new Promise(resolve => setTimeout(resolve, 5000));
+                continue;
+            }
+            else {
+                throw new Error(`Polling failed: ${tokenResp.status} ${errorText}`);
+            }
+        }
+    }
+}
+exports.QwenProvider = QwenProvider;
+QwenProvider.provider = types_1.AuthProvider.Qwen;
diff --git a/src/providers/windsurf/auth.js b/src/providers/windsurf/auth.js
new file mode 100644
index 0000000..9cd5b01
--- /dev/null
+++ b/src/providers/windsurf/auth.js
@@ -0,0 +1,298 @@
+"use strict";
+/**
+ * Windsurf Credential Discovery Module
+ *
+ * Automatically discovers credentials from the running Windsurf language server:
+ * - CSRF token from process arguments
+ * - Port from process arguments (extension_server_port + 2)
+ * - API key from VSCode state database (~/Library/Application Support/Windsurf/User/globalStorage/state.vscdb)
+ * - Version from process arguments
+ */
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+    Object.defineProperty(o, "default", { enumerable: true, value: v });
+}) : function(o, v) {
+    o["default"] = v;
+});
+var __importStar = (this && this.__importStar) || (function () {
+    var ownKeys = function(o) {
+        ownKeys = Object.getOwnPropertyNames || function (o) {
+            var ar = [];
+            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
+            return ar;
+        };
+        return ownKeys(o);
+    };
+    return function (mod) {
+        if (mod && mod.__esModule) return mod;
+        var result = {};
+        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
+        __setModuleDefault(result, mod);
+        return result;
+    };
+})();
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.WindsurfError = exports.WindsurfErrorCode = void 0;
+exports.getCSRFToken = getCSRFToken;
+exports.getPort = getPort;
+exports.getApiKey = getApiKey;
+exports.getWindsurfVersion = getWindsurfVersion;
+exports.getCredentials = getCredentials;
+exports.isWindsurfRunning = isWindsurfRunning;
+exports.isWindsurfInstalled = isWindsurfInstalled;
+exports.validateCredentials = validateCredentials;
+const child_process_1 = require("child_process");
+const fs = __importStar(require("fs"));
+const path = __importStar(require("path"));
+const os = __importStar(require("os"));
+var WindsurfErrorCode;
+(function (WindsurfErrorCode) {
+    WindsurfErrorCode["NOT_RUNNING"] = "NOT_RUNNING";
+    WindsurfErrorCode["CSRF_MISSING"] = "CSRF_MISSING";
+    WindsurfErrorCode["API_KEY_MISSING"] = "API_KEY_MISSING";
+    WindsurfErrorCode["CONNECTION_FAILED"] = "CONNECTION_FAILED";
+    WindsurfErrorCode["AUTH_FAILED"] = "AUTH_FAILED";
+    WindsurfErrorCode["STREAM_ERROR"] = "STREAM_ERROR";
+})(WindsurfErrorCode || (exports.WindsurfErrorCode = WindsurfErrorCode = {}));
+class WindsurfError extends Error {
+    constructor(message, code, details) {
+        super(message);
+        this.name = 'WindsurfError';
+        this.code = code;
+        this.details = details;
+    }
+}
+exports.WindsurfError = WindsurfError;
+// ============================================================================
+// Config Paths
+// ============================================================================
+// Paths for API key discovery
+const VSCODE_STATE_PATHS = {
+    darwin: path.join(os.homedir(), 'Library/Application Support/Windsurf/User/globalStorage/state.vscdb'),
+    linux: path.join(os.homedir(), '.config/Windsurf/User/globalStorage/state.vscdb'),
+    win32: path.join(os.homedir(), 'AppData/Roaming/Windsurf/User/globalStorage/state.vscdb'),
+};
+// Legacy config path (fallback)
+const LEGACY_CONFIG_PATH = path.join(os.homedir(), '.codeium', 'config.json');
+// Platform-specific process names
+const LANGUAGE_SERVER_PATTERNS = {
+    darwin: 'language_server_macos',
+    linux: 'language_server_linux',
+    win32: 'language_server_windows',
+};
+// ============================================================================
+// Process Discovery
+// ============================================================================
+/**
+ * Get the language server process pattern for the current platform
+ */
+function getLanguageServerPattern() {
+    const platform = process.platform;
+    return LANGUAGE_SERVER_PATTERNS[platform] || 'language_server';
+}
+/**
+ * Get process listing for language server
+ */
+function getLanguageServerProcess() {
+    const pattern = getLanguageServerPattern();
+    try {
+        if (process.platform === 'win32') {
+            // Windows: use WMIC
+            const output = (0, child_process_1.execSync)(`wmic process where "name like '%${pattern}%'" get CommandLine /format:list`, { encoding: 'utf8', timeout: 5000 });
+            return output;
+        }
+        else {
+            // Unix-like: use ps
+            const output = (0, child_process_1.execSync)(`ps aux | grep ${pattern}`, { encoding: 'utf8', timeout: 5000 });
+            return output;
+        }
+    }
+    catch {
+        return null;
+    }
+}
+/**
+ * Extract CSRF token from running Windsurf language server process
+ */
+function getCSRFToken() {
+    const processInfo = getLanguageServerProcess();
+    if (!processInfo) {
+        throw new WindsurfError('Windsurf language server not found. Is Windsurf running?', WindsurfErrorCode.NOT_RUNNING);
+    }
+    const match = processInfo.match(/--csrf_token\s+([a-f0-9-]+)/);
+    if (match?.[1]) {
+        return match[1];
+    }
+    throw new WindsurfError('CSRF token not found in Windsurf process. Is Windsurf running?', WindsurfErrorCode.CSRF_MISSING);
+}
+/**
+ * Get the language server gRPC port dynamically using lsof
+ * The port offset from extension_server_port varies (--random_port flag), so we use lsof
+ */
+function getPort() {
+    const processInfo = getLanguageServerProcess();
+    if (!processInfo) {
+        throw new WindsurfError('Windsurf language server not found. Is Windsurf running?', WindsurfErrorCode.NOT_RUNNING);
+    }
+    // Extract PID from ps output (second column)
+    const pidMatch = processInfo.match(/^\s*\S+\s+(\d+)/);
+    const pid = pidMatch ? pidMatch[1] : null;
+    // Get extension_server_port as a reference point
+    const portMatch = processInfo.match(/--extension_server_port\s+(\d+)/);
+    const extPort = portMatch ? parseInt(portMatch[1], 10) : null;
+    // Use lsof to find actual listening ports for this specific PID
+    if (process.platform !== 'win32' && pid) {
+        try {
+            const lsof = (0, child_process_1.execSync)(`lsof -p ${pid} -i -P -n 2>/dev/null | grep LISTEN`, { encoding: 'utf8', timeout: 15000 });
+            // Extract all listening ports
+            const portMatches = lsof.matchAll(/:(\d+)\s+\(LISTEN\)/g);
+            const ports = Array.from(portMatches).map(m => parseInt(m[1], 10));
+            if (ports.length > 0) {
+                // If we have extension_server_port, prefer the port closest to it (usually +3)
+                if (extPort) {
+                    // Sort by distance from extPort and pick the closest one > extPort
+                    const candidatePorts = ports.filter(p => p > extPort).sort((a, b) => a - b);
+                    if (candidatePorts.length > 0) {
+                        return candidatePorts[0]; // Return the first port after extPort
+                    }
+                }
+                // Otherwise just return the first listening port
+                return ports[0];
+            }
+        }
+        catch {
+            // Fall through to offset-based approach
+        }
+    }
+    // Fallback: try common offsets (+3, +2, +4)
+    if (extPort) {
+        return extPort + 3;
+    }
+    throw new WindsurfError('Windsurf language server port not found. Is Windsurf running?', WindsurfErrorCode.NOT_RUNNING);
+}
+/**
+ * Read API key from VSCode state database (windsurfAuthStatus)
+ *
+ * The API key is stored in the SQLite database at:
+ * ~/Library/Application Support/Windsurf/User/globalStorage/state.vscdb
+ *
+ * It's stored in the 'windsurfAuthStatus' key as JSON containing apiKey.
+ */
+function getApiKey() {
+    const platform = process.platform;
+    const statePath = VSCODE_STATE_PATHS[platform];
+    if (!statePath) {
+        throw new WindsurfError(`Unsupported platform: ${process.platform}`, WindsurfErrorCode.API_KEY_MISSING);
+    }
+    // Try to get API key from VSCode state database
+    if (fs.existsSync(statePath)) {
+        try {
+            const result = (0, child_process_1.execSync)(`sqlite3 "${statePath}" "SELECT value FROM ItemTable WHERE key = 'windsurfAuthStatus';"`, { encoding: 'utf8', timeout: 5000 }).trim();
+            if (result) {
+                const parsed = JSON.parse(result);
+                if (parsed.apiKey) {
+                    return parsed.apiKey;
+                }
+            }
+        }
+        catch (error) {
+            // Fall through to legacy config
+        }
+    }
+    // Try legacy config file
+    if (fs.existsSync(LEGACY_CONFIG_PATH)) {
+        try {
+            const config = fs.readFileSync(LEGACY_CONFIG_PATH, 'utf8');
+            const parsed = JSON.parse(config);
+            if (parsed.apiKey) {
+                return parsed.apiKey;
+            }
+        }
+        catch {
+            // Fall through
+        }
+    }
+    throw new WindsurfError('API key not found. Please login to Windsurf first.', WindsurfErrorCode.API_KEY_MISSING);
+}
+/**
+ * Get Windsurf version from process arguments
+ */
+function getWindsurfVersion() {
+    const processInfo = getLanguageServerProcess();
+    if (processInfo) {
+        const match = processInfo.match(/--windsurf_version\s+([^\s]+)/);
+        if (match) {
+            // Extract just the version number (before + if present)
+            const version = match[1].split('+')[0];
+            return version;
+        }
+    }
+    // Default fallback version
+    return '1.13.104';
+}
+// ============================================================================
+// Public API
+// ============================================================================
+/**
+ * Get all credentials needed to communicate with Windsurf
+ */
+function getCredentials() {
+    return {
+        csrfToken: getCSRFToken(),
+        port: getPort(),
+        apiKey: getApiKey(),
+        version: getWindsurfVersion(),
+    };
+}
+/**
+ * Check if Windsurf is running and accessible
+ */
+function isWindsurfRunning() {
+    try {
+        getCSRFToken();
+        getPort();
+        return true;
+    }
+    catch {
+        return false;
+    }
+}
+/**
+ * Check if Windsurf is installed (app exists)
+ */
+function isWindsurfInstalled() {
+    if (process.platform === 'darwin') {
+        return fs.existsSync('/Applications/Windsurf.app');
+    }
+    else if (process.platform === 'linux') {
+        return (fs.existsSync('/usr/share/windsurf') ||
+            fs.existsSync(path.join(os.homedir(), '.local/share/windsurf')));
+    }
+    else if (process.platform === 'win32') {
+        return (fs.existsSync('C:\\Program Files\\Windsurf') ||
+            fs.existsSync(path.join(os.homedir(), 'AppData\\Local\\Programs\\Windsurf')));
+    }
+    return false;
+}
+/**
+ * Validate credentials structure
+ */
+function validateCredentials(credentials) {
+    return (typeof credentials.csrfToken === 'string' &&
+        credentials.csrfToken.length > 0 &&
+        typeof credentials.port === 'number' &&
+        credentials.port > 0 &&
+        typeof credentials.apiKey === 'string' &&
+        credentials.apiKey.length > 0 &&
+        typeof credentials.version === 'string');
+}
diff --git a/src/providers/windsurf/discovery.js b/src/providers/windsurf/discovery.js
new file mode 100644
index 0000000..8d61d28
--- /dev/null
+++ b/src/providers/windsurf/discovery.js
@@ -0,0 +1,147 @@
+"use strict";
+/**
+ * Windsurf Extension Discovery & Analysis
+ *
+ * dynamically analyzes the installed Windsurf extension.js to discover
+ * Protobuf field numbers that may change between versions.
+ */
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+    Object.defineProperty(o, "default", { enumerable: true, value: v });
+}) : function(o, v) {
+    o["default"] = v;
+});
+var __importStar = (this && this.__importStar) || (function () {
+    var ownKeys = function(o) {
+        ownKeys = Object.getOwnPropertyNames || function (o) {
+            var ar = [];
+            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
+            return ar;
+        };
+        return ownKeys(o);
+    };
+    return function (mod) {
+        if (mod && mod.__esModule) return mod;
+        var result = {};
+        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
+        __setModuleDefault(result, mod);
+        return result;
+    };
+})();
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.DEFAULT_METADATA_FIELDS = void 0;
+exports.getMetadataFields = getMetadataFields;
+const fs = __importStar(require("fs"));
+const path = __importStar(require("path"));
+const os = __importStar(require("os"));
+// Default metadata fields if discovery fails (matches current spec/most common)
+exports.DEFAULT_METADATA_FIELDS = {
+    api_key: 1,
+    ide_name: 2,
+    ide_version: 3,
+    extension_version: 4,
+    session_id: 5,
+    locale: 6,
+};
+let cachedFields = null;
+/**
+ * Locate the Windsurf extension.js file
+ */
+function findExtensionFile() {
+    const commonPaths = [
+        // macOS
+        '/Applications/Windsurf.app/Contents/Resources/app/extensions/windsurf/dist/extension.js',
+        path.join(os.homedir(), 'Applications/Windsurf.app/Contents/Resources/app/extensions/windsurf/dist/extension.js'),
+        // Linux
+        '/usr/share/windsurf/resources/app/extensions/windsurf/dist/extension.js',
+        path.join(os.homedir(), '.local/share/windsurf/resources/app/extensions/windsurf/dist/extension.js'),
+        // Windows
+        'C:\\Program Files\\Windsurf\\resources\\app\\extensions\\windsurf\\dist\\extension.js',
+        path.join(os.homedir(), 'AppData\\Local\\Programs\\Windsurf\\resources\\app\\extensions\\windsurf\\dist\\extension.js'),
+    ];
+    for (const p of commonPaths) {
+        if (fs.existsSync(p))
+            return p;
+    }
+    return null;
+}
+/**
+ * Analyze extension.js content to find Metadata field numbers
+ */
+function parseMetadataFields(content) {
+    // Look for field lists like: newFieldList(()=>[{no:1,name:"api_key",...},...])
+    const fieldLists = [...content.matchAll(/newFieldList\(\(\)=>\[(.*?)\]\)/g)];
+    for (const match of fieldLists) {
+        const listContent = match[1];
+        // The Metadata message must contain both api_key and ide_name
+        // AND must NOT contain "event_name" (which indicates a telemetry message)
+        if (listContent.includes('"api_key"') &&
+            listContent.includes('"ide_name"') &&
+            !listContent.includes('"event_name"')) {
+            const fields = { ...exports.DEFAULT_METADATA_FIELDS };
+            // regex to extract {no:X,name:"field_name"}
+            // Handles minified variations
+            const extractField = (name) => {
+                // pattern: {no:(\d+),name:"NAME"
+                const regex = new RegExp(`{no:(\\d+),name:"${name}"`);
+                const m = listContent.match(regex);
+                return m ? parseInt(m[1], 10) : null;
+            };
+            const apiKey = extractField('api_key');
+            const ideName = extractField('ide_name');
+            if (apiKey && ideName) {
+                fields.api_key = apiKey;
+                fields.ide_name = ideName;
+                // Try other fields
+                const ideVersion = extractField('ide_version');
+                if (ideVersion)
+                    fields.ide_version = ideVersion;
+                const extVersion = extractField('extension_version');
+                if (extVersion)
+                    fields.extension_version = extVersion;
+                const sessionId = extractField('session_id');
+                if (sessionId)
+                    fields.session_id = sessionId;
+                const locale = extractField('locale');
+                if (locale)
+                    fields.locale = locale;
+                return fields;
+            }
+        }
+    }
+    return null;
+}
+/**
+ * Get Metadata field mapping, using cached discovery or defaults
+ */
+function getMetadataFields() {
+    if (cachedFields)
+        return cachedFields;
+    try {
+        const extPath = findExtensionFile();
+        if (extPath) {
+            const content = fs.readFileSync(extPath, 'utf8');
+            const discovered = parseMetadataFields(content);
+            if (discovered) {
+                cachedFields = discovered;
+                return cachedFields;
+            }
+        }
+    }
+    catch (error) {
+        throw new Error('[Windsurf] Failed to discover extension fields: ' + error);
+    }
+    // Fallback to default
+    cachedFields = exports.DEFAULT_METADATA_FIELDS;
+    return cachedFields;
+}
diff --git a/src/providers/windsurf/grpc-client.js b/src/providers/windsurf/grpc-client.js
new file mode 100644
index 0000000..bea27a4
--- /dev/null
+++ b/src/providers/windsurf/grpc-client.js
@@ -0,0 +1,569 @@
+"use strict";
+/**
+ * gRPC Client for Windsurf Language Server
+ *
+ * Implements HTTP/2-based gRPC communication with the local Windsurf language server.
+ * Uses manual protobuf encoding (no external protobuf library needed).
+ */
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+    Object.defineProperty(o, "default", { enumerable: true, value: v });
+}) : function(o, v) {
+    o["default"] = v;
+});
+var __importStar = (this && this.__importStar) || (function () {
+    var ownKeys = function(o) {
+        ownKeys = Object.getOwnPropertyNames || function (o) {
+            var ar = [];
+            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
+            return ar;
+        };
+        return ownKeys(o);
+    };
+    return function (mod) {
+        if (mod && mod.__esModule) return mod;
+        var result = {};
+        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
+        __setModuleDefault(result, mod);
+        return result;
+    };
+})();
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.streamChat = streamChat;
+exports.streamChatGenerator = streamChatGenerator;
+const http2 = __importStar(require("http2"));
+const crypto = __importStar(require("crypto"));
+const types_1 = require("./types");
+const models_1 = require("./models");
+const auth_1 = require("./auth");
+// ============================================================================
+// Protobuf Encoding Helpers
+// ============================================================================
+/**
+ * Encode a number as a varint (variable-length integer)
+ */
+function encodeVarint(value) {
+    const bytes = [];
+    let v = BigInt(value);
+    while (v > 127n) {
+        bytes.push(Number(v & 0x7fn) | 0x80);
+        v >>= 7n;
+    }
+    bytes.push(Number(v));
+    return bytes;
+}
+/**
+ * Encode a string field (wire type 2: length-delimited)
+ */
+function encodeString(fieldNum, str) {
+    const strBytes = Buffer.from(str, 'utf8');
+    return [(fieldNum << 3) | 2, ...encodeVarint(strBytes.length), ...strBytes];
+}
+/**
+ * Encode a nested message field (wire type 2: length-delimited)
+ */
+function encodeMessage(fieldNum, data) {
+    return [(fieldNum << 3) | 2, ...encodeVarint(data.length), ...data];
+}
+/**
+ * Encode a varint field (wire type 0)
+ */
+function encodeVarintField(fieldNum, value) {
+    return [(fieldNum << 3) | 0, ...encodeVarint(value)];
+}
+// ============================================================================
+// Request Building
+// ============================================================================
+/**
+ * Generate a UUID for message and conversation IDs
+ */
+function generateUUID() {
+    return crypto.randomUUID();
+}
+/**
+ * Encode a google.protobuf.Timestamp
+ * Field 1: seconds (int64)
+ * Field 2: nanos (int32)
+ */
+function encodeTimestamp() {
+    const now = Date.now();
+    const seconds = Math.floor(now / 1000);
+    const nanos = (now % 1000) * 1000000;
+    const bytes = [];
+    bytes.push(...encodeVarintField(1, seconds));
+    if (nanos > 0) {
+        bytes.push(...encodeVarintField(2, nanos));
+    }
+    return bytes;
+}
+/**
+ * Encode IntentGeneric message
+ * Field 1: text (string)
+ */
+function encodeIntentGeneric(text) {
+    return encodeString(1, text);
+}
+/**
+ * Encode ChatMessageIntent message
+ * Field 1: generic (IntentGeneric, oneof)
+ * Field 12: num_tokens (int32)
+ */
+function encodeChatMessageIntent(text) {
+    const generic = encodeIntentGeneric(text);
+    return encodeMessage(1, generic);
+}
+/**
+ * Encode a ChatMessage for the RawGetChatMessageRequest
+ *
+ * ChatMessage structure (from reverse engineering):
+ * Field 1: message_id (string, required)
+ * Field 2: source (enum: 1=USER, 2=SYSTEM, 3=ASSISTANT)
+ * Field 3: timestamp (google.protobuf.Timestamp, required)
+ * Field 4: conversation_id (string, required)
+ * Field 5: For USER/SYSTEM/TOOL: intent (ChatMessageIntent)
+ *          For ASSISTANT: text (string)
+ */
+function encodeChatMessage(content, source, conversationId) {
+    const messageId = generateUUID();
+    const bytes = [];
+    // Field 1: message_id (required)
+    bytes.push(...encodeString(1, messageId));
+    // Field 2: source
+    bytes.push(...encodeVarintField(2, source));
+    // Field 3: timestamp (required)
+    const timestamp = encodeTimestamp();
+    bytes.push(...encodeMessage(3, timestamp));
+    // Field 4: conversation_id (required)
+    bytes.push(...encodeString(4, conversationId));
+    // Field 5: content
+    if (source === types_1.ChatMessageSource.ASSISTANT) {
+        // Assistant replies use plain text field
+        bytes.push(...encodeString(5, content));
+    }
+    else {
+        const intent = encodeChatMessageIntent(content);
+        bytes.push(...encodeMessage(5, intent));
+    }
+    return bytes;
+}
+/**
+ * Build the metadata message for the request
+ *
+ * Metadata structure:
+ * Field 1: ide_name (string)
+ * Field 2: extension_version (string)
+ * Field 3: api_key (string, required)
+ * Field 4: locale (string)
+ * Field 7: ide_version (string)
+ * Field 12: extension_name (string)
+ */
+const discovery_1 = require("./discovery");
+/**
+ * Build the metadata message for the request
+ * Dynamically maps fields using discovered extension.js values
+ */
+function encodeMetadata(apiKey, version) {
+    const fields = (0, discovery_1.getMetadataFields)();
+    return [
+        ...encodeString(fields.api_key, apiKey), // api_key
+        ...encodeString(fields.ide_name, 'windsurf'), // ide_name
+        ...encodeString(fields.ide_version, version), // ide_version
+        ...encodeString(fields.extension_version, version), // extension_version
+        // Optional fields
+        ...(fields.session_id ? encodeString(fields.session_id, generateUUID()) : []),
+        ...(fields.locale ? encodeString(fields.locale, 'en') : []),
+        // Add extension_name equivalent if needed (often mapped to 12 in older versions or same as ide_name)
+        // For safety, we only encode defined discovered fields
+    ];
+}
+/**
+ * Map role string to ChatMessageSource enum value
+ */
+function roleToSource(role) {
+    switch (role) {
+        case 'user':
+            return types_1.ChatMessageSource.USER;
+        case 'assistant':
+            return types_1.ChatMessageSource.ASSISTANT;
+        case 'system':
+            return types_1.ChatMessageSource.SYSTEM;
+        case 'tool':
+            return types_1.ChatMessageSource.TOOL;
+        default:
+            return types_1.ChatMessageSource.USER;
+    }
+}
+/**
+ * Build the complete chat request buffer using RawGetChatMessageRequest format
+ *
+ * RawGetChatMessageRequest structure:
+ * Field 1: metadata (Metadata message)
+ * Field 2: chat_messages (repeated ChatMessage)
+ * Field 3: system_prompt_override (string) - optional
+ * Field 4: chat_model (enum: Model)
+ * Field 5: chat_model_name (string) - optional
+ */
+function buildChatRequest(apiKey, version, modelEnum, messages, modelName) {
+    const metadata = encodeMetadata(apiKey, version);
+    const conversationId = generateUUID();
+    // Build the request with all messages
+    const request = [];
+    // Field 1: metadata
+    request.push(...encodeMessage(1, metadata));
+    // Field 2: chat_messages (repeated ChatMessage)
+    // Extract system message if present and handle separately
+    let systemPrompt = '';
+    for (const msg of messages) {
+        if (msg.role === 'system') {
+            systemPrompt = msg.content;
+        }
+        else {
+            // Encode each message as ChatMessage with ChatMessageIntent
+            const source = roleToSource(msg.role);
+            const chatMsg = encodeChatMessage(msg.content, source, conversationId);
+            request.push(...encodeMessage(2, chatMsg));
+        }
+    }
+    // Field 3: system_prompt_override (if we have a system message)
+    if (systemPrompt) {
+        request.push(...encodeString(3, systemPrompt));
+    }
+    // Field 4: model enum
+    request.push(...encodeVarintField(4, modelEnum));
+    // Field 5: chat_model_name (string) if provided
+    if (modelName) {
+        request.push(...encodeString(5, modelName));
+    }
+    const payload = Buffer.from(request);
+    // gRPC framing: 1 byte compression flag (0) + 4 bytes length + payload
+    const frame = Buffer.alloc(5 + payload.length);
+    frame[0] = 0; // No compression
+    frame.writeUInt32BE(payload.length, 1);
+    payload.copy(frame, 5);
+    return frame;
+}
+// ============================================================================
+// Response Parsing (Protobuf Decoding)
+// ============================================================================
+/**
+ * Decode a varint from a buffer starting at offset
+ * @returns [value, bytesRead]
+ */
+function decodeVarint(buffer, offset) {
+    let result = 0n;
+    let shift = 0n;
+    let bytesRead = 0;
+    while (offset + bytesRead < buffer.length) {
+        const byte = buffer[offset + bytesRead];
+        bytesRead++;
+        result |= BigInt(byte & 0x7f) << shift;
+        if ((byte & 0x80) === 0) {
+            break;
+        }
+        shift += 7n;
+    }
+    return [result, bytesRead];
+}
+/**
+ * Parse a protobuf field from buffer
+ * @returns { fieldNum, wireType, value, bytesConsumed } or null if can't parse
+ */
+function parseProtobufField(buffer, offset) {
+    if (offset >= buffer.length)
+        return null;
+    const [tag, tagBytes] = decodeVarint(buffer, offset);
+    const fieldNum = Number(tag >> 3n);
+    const wireType = Number(tag & 0x7n);
+    let bytesConsumed = tagBytes;
+    let value;
+    switch (wireType) {
+        case 0: // Varint
+            const [varintValue, varintBytes] = decodeVarint(buffer, offset + bytesConsumed);
+            value = varintValue;
+            bytesConsumed += varintBytes;
+            break;
+        case 2: // Length-delimited (string, bytes, embedded message)
+            const [length, lengthBytes] = decodeVarint(buffer, offset + bytesConsumed);
+            bytesConsumed += lengthBytes;
+            const len = Number(length);
+            if (offset + bytesConsumed + len > buffer.length) {
+                // Not enough data
+                return null;
+            }
+            value = buffer.subarray(offset + bytesConsumed, offset + bytesConsumed + len);
+            bytesConsumed += len;
+            break;
+        case 1: // 64-bit (fixed64, sfixed64, double)
+            if (offset + bytesConsumed + 8 > buffer.length)
+                return null;
+            value = buffer.subarray(offset + bytesConsumed, offset + bytesConsumed + 8);
+            bytesConsumed += 8;
+            break;
+        case 5: // 32-bit (fixed32, sfixed32, float)
+            if (offset + bytesConsumed + 4 > buffer.length)
+                return null;
+            value = buffer.subarray(offset + bytesConsumed, offset + bytesConsumed + 4);
+            bytesConsumed += 4;
+            break;
+        default:
+            // Unknown wire type, can't parse
+            return null;
+    }
+    return { fieldNum, wireType, value, bytesConsumed };
+}
+/**
+ * Extract text from RawChatMessage protobuf
+ *
+ * RawChatMessage structure:
+ * Field 1: message_id (string)
+ * Field 2: source (enum)
+ * Field 3: timestamp (message)
+ * Field 4: conversation_id (string)
+ * Field 5: text (string)  What we want
+ * Field 6: in_progress (bool)
+ * Field 7: is_error (bool)
+ */
+function extractTextFromRawChatMessage(buffer) {
+    let offset = 0;
+    while (offset < buffer.length) {
+        const field = parseProtobufField(buffer, offset);
+        if (!field)
+            break;
+        offset += field.bytesConsumed;
+        // Field 5 is the text content
+        if (field.fieldNum === 5 && field.wireType === 2 && Buffer.isBuffer(field.value)) {
+            return field.value.toString('utf8');
+        }
+    }
+    return '';
+}
+/**
+ * Extract text from RawGetChatMessageResponse protobuf
+ *
+ * RawGetChatMessageResponse structure:
+ * Field 1: delta_message (RawChatMessage)
+ */
+function extractTextFromResponse(buffer) {
+    let offset = 0;
+    while (offset < buffer.length) {
+        const field = parseProtobufField(buffer, offset);
+        if (!field)
+            break;
+        offset += field.bytesConsumed;
+        // Field 1 is delta_message (RawChatMessage)
+        if (field.fieldNum === 1 && field.wireType === 2 && Buffer.isBuffer(field.value)) {
+            const text = extractTextFromRawChatMessage(field.value);
+            if (text)
+                return text;
+        }
+    }
+    return '';
+}
+/**
+ * Extract readable text from a gRPC response chunk
+ *
+ * The response is gRPC-framed: 1 byte compression + 4 bytes length + protobuf payload
+ * We parse the protobuf to extract the text field from RawChatMessage.
+ */
+function extractTextFromChunk(chunk) {
+    // gRPC frame: 1 byte compression flag + 4 bytes message length + message
+    // Multiple messages may be concatenated in a single chunk
+    const results = [];
+    let offset = 0;
+    while (offset + 5 <= chunk.length) {
+        const compressed = chunk[offset];
+        const messageLength = chunk.readUInt32BE(offset + 1);
+        if (compressed !== 0) {
+            // Compressed data not supported, skip
+            offset += 5 + messageLength;
+            continue;
+        }
+        if (offset + 5 + messageLength > chunk.length) {
+            // Not enough data for the full message, try as raw protobuf
+            break;
+        }
+        const messageData = chunk.subarray(offset + 5, offset + 5 + messageLength);
+        const text = extractTextFromResponse(messageData);
+        if (text) {
+            results.push(text);
+        }
+        offset += 5 + messageLength;
+    }
+    // If we extracted text from proper protobuf parsing, return it
+    if (results.length > 0) {
+        return results.join('');
+    }
+    // Fallback: try parsing the entire chunk as protobuf (in case framing was already stripped)
+    const fallbackText = extractTextFromResponse(chunk);
+    if (fallbackText) {
+        return fallbackText;
+    }
+    // Last resort: heuristic extraction for edge cases
+    return extractTextHeuristic(chunk);
+}
+/**
+ * Fallback heuristic text extraction - DISABLED
+ * The proper protobuf parsing should handle all cases.
+ * If it fails, we return empty rather than risk returning garbage.
+ */
+function extractTextHeuristic(_chunk) {
+    // Heuristic extraction is too unreliable and returns garbage metadata.
+    // The proper protobuf parsing (extractTextFromResponse) should work.
+    // If it doesn't, we return empty string rather than corrupted output.
+    return '';
+}
+// ============================================================================
+// Streaming API
+// ============================================================================
+/**
+ * Stream chat completion using Promise-based API
+ *
+ * @param credentials - Windsurf credentials (csrf, port, apiKey, version)
+ * @param options - Chat options including model, messages, and callbacks
+ * @returns Promise that resolves to the full response text
+ */
+function streamChat(credentials, options) {
+    const { csrfToken, port, apiKey, version } = credentials;
+    const resolved = (0, models_1.resolveModel)(options.model);
+    const modelEnum = resolved.enumValue;
+    const modelName = resolved.variant ? `${resolved.modelId}:${resolved.variant}` : resolved.modelId;
+    const body = buildChatRequest(apiKey, version, modelEnum, options.messages, modelName);
+    return new Promise((resolve, reject) => {
+        const client = http2.connect(`http://localhost:${port}`);
+        const chunks = [];
+        client.on('error', (err) => {
+            options.onError?.(err);
+            reject(new auth_1.WindsurfError(`Connection failed: ${err.message}`, auth_1.WindsurfErrorCode.CONNECTION_FAILED, err));
+        });
+        client.on('connect', () => {
+            const req = client.request({
+                ':method': 'POST',
+                ':path': '/exa.language_server_pb.LanguageServerService/RawGetChatMessage',
+                'content-type': 'application/grpc',
+                'te': 'trailers',
+                'x-codeium-csrf-token': csrfToken,
+            });
+            req.on('data', (chunk) => {
+                const text = extractTextFromChunk(chunk);
+                if (text) {
+                    chunks.push(text);
+                    options.onChunk?.(text);
+                }
+            });
+            req.on('trailers', (trailers) => {
+                const status = trailers['grpc-status'];
+                if (status !== '0') {
+                    const message = trailers['grpc-message'];
+                    const err = new auth_1.WindsurfError(`gRPC error ${status}: ${message ? decodeURIComponent(message) : 'Unknown error'}`, auth_1.WindsurfErrorCode.STREAM_ERROR);
+                    options.onError?.(err);
+                    reject(err);
+                }
+            });
+            req.on('end', () => {
+                client.close();
+                const fullText = chunks.join('');
+                options.onComplete?.(fullText);
+                resolve(fullText);
+            });
+            req.on('error', (err) => {
+                client.close();
+                options.onError?.(err);
+                reject(new auth_1.WindsurfError(`Request failed: ${err.message}`, auth_1.WindsurfErrorCode.STREAM_ERROR, err));
+            });
+            req.write(body);
+            req.end();
+        });
+        // Timeout after 2 minutes
+        setTimeout(() => {
+            client.close();
+            const fullText = chunks.join('');
+            options.onComplete?.(fullText);
+            resolve(fullText);
+        }, 120000);
+    });
+}
+/**
+ * Stream chat completion using async generator
+ *
+ * Yields text chunks as they arrive, for use with SSE streaming.
+ *
+ * @param credentials - Windsurf credentials
+ * @param options - Chat options (model and messages)
+ * @yields Text chunks as they arrive
+ */
+async function* streamChatGenerator(credentials, options) {
+    const { csrfToken, port, apiKey, version } = credentials;
+    const resolved = (0, models_1.resolveModel)(options.model);
+    const modelEnum = resolved.enumValue;
+    const modelName = resolved.variant ? `${resolved.modelId}:${resolved.variant}` : resolved.modelId;
+    const body = buildChatRequest(apiKey, version, modelEnum, options.messages, modelName);
+    const client = http2.connect(`http://localhost:${port}`);
+    const chunkQueue = [];
+    let done = false;
+    let error = null;
+    let resolveWait = null;
+    client.on('error', (err) => {
+        error = new auth_1.WindsurfError(`Connection failed: ${err.message}`, auth_1.WindsurfErrorCode.CONNECTION_FAILED, err);
+        done = true;
+        resolveWait?.();
+    });
+    const req = client.request({
+        ':method': 'POST',
+        ':path': '/exa.language_server_pb.LanguageServerService/RawGetChatMessage',
+        'content-type': 'application/grpc',
+        'te': 'trailers',
+        'x-codeium-csrf-token': csrfToken,
+    });
+    req.on('data', (chunk) => {
+        const text = extractTextFromChunk(chunk);
+        if (text) {
+            chunkQueue.push(text);
+            resolveWait?.();
+        }
+    });
+    req.on('trailers', (trailers) => {
+        const status = trailers['grpc-status'];
+        if (status !== '0') {
+            const message = trailers['grpc-message'];
+            error = new auth_1.WindsurfError(`gRPC error ${status}: ${message ? decodeURIComponent(message) : 'Unknown error'}`, auth_1.WindsurfErrorCode.STREAM_ERROR);
+        }
+    });
+    req.on('end', () => {
+        done = true;
+        client.close();
+        resolveWait?.();
+    });
+    req.on('error', (err) => {
+        error = new auth_1.WindsurfError(`Request failed: ${err.message}`, auth_1.WindsurfErrorCode.STREAM_ERROR, err);
+        done = true;
+        client.close();
+        resolveWait?.();
+    });
+    req.write(body);
+    req.end();
+    // Yield chunks as they arrive
+    while (!done || chunkQueue.length > 0) {
+        if (chunkQueue.length > 0) {
+            yield chunkQueue.shift();
+        }
+        else if (!done) {
+            await new Promise((resolve) => {
+                resolveWait = resolve;
+            });
+            resolveWait = null;
+        }
+    }
+    if (error) {
+        throw error;
+    }
+}
diff --git a/src/providers/windsurf/index.js b/src/providers/windsurf/index.js
new file mode 100644
index 0000000..a9826ca
--- /dev/null
+++ b/src/providers/windsurf/index.js
@@ -0,0 +1,117 @@
+"use strict";
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __exportStar = (this && this.__exportStar) || function(m, exports) {
+    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.WindsurfProvider = void 0;
+const types_1 = require("../../core/types");
+const auth_1 = require("./auth");
+const extractor_1 = require("../../utils/extractor");
+class WindsurfProvider {
+    static getHeaders(account) {
+        const headers = {
+            'Content-Type': 'application/grpc',
+        };
+        if (account.metadata?.csrfToken) {
+            headers['x-codeium-csrf-token'] = account.metadata.csrfToken;
+        }
+        return headers;
+    }
+    static getUrl(model, account) {
+        const port = account.metadata?.port || 0;
+        return `http://localhost:${port}/exa.language_server_pb.LanguageServerService/RawGetChatMessage`;
+    }
+    static async refreshTokens(account) {
+        try {
+            // Re-discover credentials
+            const credentials = (0, auth_1.getCredentials)();
+            // Update account with new credentials
+            return {
+                ...account,
+                apiKey: credentials.apiKey,
+                metadata: {
+                    ...account.metadata,
+                    csrfToken: credentials.csrfToken,
+                    port: credentials.port,
+                    version: credentials.version,
+                    lastRefreshed: Date.now()
+                },
+                isHealthy: true
+            };
+        }
+        catch (error) {
+            console.error('Failed to refresh Windsurf credentials:', error);
+            return {
+                ...account,
+                isHealthy: false,
+                lastSwitchReason: error instanceof Error ? error.message : 'Unknown error during refresh'
+            };
+        }
+    }
+    /**
+     * Automatically discover local Windsurf accounts
+     */
+    static async discover() {
+        try {
+            const credentials = (0, auth_1.getCredentials)();
+            return {
+                id: `windsurf-local-${Date.now()}`,
+                email: 'local@windsurf',
+                provider: types_1.AuthProvider.Windsurf,
+                tokens: { accessToken: credentials.apiKey },
+                apiKey: credentials.apiKey,
+                metadata: {
+                    csrfToken: credentials.csrfToken,
+                    port: credentials.port,
+                    version: credentials.version,
+                    discoveredAt: Date.now()
+                },
+                isHealthy: true
+            };
+        }
+        catch (error) {
+            // If process not running, try direct SQLite extraction via TokenExtractor
+            const apiKey = extractor_1.TokenExtractor.extractWindsurfFromSQLite();
+            if (apiKey) {
+                return {
+                    id: `windsurf-local-${Date.now()}`,
+                    email: 'local@windsurf',
+                    provider: types_1.AuthProvider.Windsurf,
+                    tokens: { accessToken: apiKey },
+                    apiKey: apiKey,
+                    isHealthy: true,
+                    metadata: {
+                        discoveredAt: Date.now(),
+                        method: 'sqlite'
+                    }
+                };
+            }
+            return null;
+        }
+    }
+    // Helper to initialize a new account from environment
+    static async discoverAccount() {
+        const account = await this.discover();
+        if (!account) {
+            throw new Error('Could not discover local Windsurf account');
+        }
+        return account;
+    }
+}
+exports.WindsurfProvider = WindsurfProvider;
+WindsurfProvider.provider = types_1.AuthProvider.Windsurf;
+__exportStar(require("./grpc-client"), exports);
+__exportStar(require("./auth"), exports);
+__exportStar(require("./types"), exports);
+__exportStar(require("./models"), exports);
diff --git a/src/providers/windsurf/models.js b/src/providers/windsurf/models.js
new file mode 100644
index 0000000..4d5a1c7
--- /dev/null
+++ b/src/providers/windsurf/models.js
@@ -0,0 +1,652 @@
+"use strict";
+/**
+ * Model name to enum mappings for Windsurf gRPC protocol
+ *
+ * Maps OpenAI-compatible model names to Windsurf protobuf enum values.
+ * These values were extracted from Windsurf's extension.js.
+ *
+ * To discover/verify these values:
+ * 1. Find: /Applications/Windsurf.app/Contents/Resources/app/extensions/windsurf/dist/extension.js
+ * 2. Search: grep -oE 'CLAUDE[A-Z0-9_]+\s*=\s*[0-9]+' extension.js
+ */
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.resolveModel = resolveModel;
+exports.modelNameToEnum = modelNameToEnum;
+exports.enumToModelName = enumToModelName;
+exports.getSupportedModels = getSupportedModels;
+exports.isModelSupported = isModelSupported;
+exports.getDefaultModel = getDefaultModel;
+exports.getDefaultModelEnum = getDefaultModelEnum;
+exports.getCanonicalModels = getCanonicalModels;
+exports.getModelVariants = getModelVariants;
+const types_1 = require("./types");
+// ==========================================================================
+// Variant Catalog
+// ==========================================================================
+const VARIANT_CATALOG = {
+    // Claude thinking variants
+    'claude-3.7-sonnet': {
+        id: 'claude-3.7-sonnet',
+        defaultEnum: types_1.ModelEnum.CLAUDE_3_7_SONNET_20250219,
+        variants: {
+            thinking: { enumValue: types_1.ModelEnum.CLAUDE_3_7_SONNET_20250219_THINKING, description: 'Thinking mode' },
+        },
+    },
+    'claude-4.5-sonnet': {
+        id: 'claude-4.5-sonnet',
+        defaultEnum: types_1.ModelEnum.CLAUDE_4_5_SONNET,
+        variants: {
+            thinking: { enumValue: types_1.ModelEnum.CLAUDE_4_5_SONNET_THINKING, description: 'Thinking mode' },
+        },
+    },
+    'claude-4.5-opus': {
+        id: 'claude-4.5-opus',
+        defaultEnum: types_1.ModelEnum.CLAUDE_4_5_OPUS,
+        variants: {
+            thinking: { enumValue: types_1.ModelEnum.CLAUDE_4_5_OPUS_THINKING, description: 'Thinking mode' },
+        },
+    },
+    'claude-4.1-opus': {
+        id: 'claude-4.1-opus',
+        defaultEnum: types_1.ModelEnum.CLAUDE_4_1_OPUS,
+        variants: {
+            thinking: { enumValue: types_1.ModelEnum.CLAUDE_4_1_OPUS_THINKING, description: 'Thinking mode' },
+        },
+        aliases: ['claude-4-1-opus'],
+    },
+    'claude-4-opus': {
+        id: 'claude-4-opus',
+        defaultEnum: types_1.ModelEnum.CLAUDE_4_OPUS,
+        variants: {
+            thinking: { enumValue: types_1.ModelEnum.CLAUDE_4_OPUS_THINKING, description: 'Thinking mode' },
+        },
+    },
+    'claude-4-sonnet': {
+        id: 'claude-4-sonnet',
+        defaultEnum: types_1.ModelEnum.CLAUDE_4_SONNET,
+        variants: {
+            thinking: { enumValue: types_1.ModelEnum.CLAUDE_4_SONNET_THINKING, description: 'Thinking mode' },
+        },
+    },
+    // Google Gemini 2.5 / 3.0
+    'gemini-2.5-flash': {
+        id: 'gemini-2.5-flash',
+        defaultEnum: types_1.ModelEnum.GEMINI_2_5_FLASH,
+        variants: {
+            thinking: { enumValue: types_1.ModelEnum.GEMINI_2_5_FLASH_THINKING, description: 'Thinking budget enabled' },
+            lite: { enumValue: types_1.ModelEnum.GEMINI_2_5_FLASH_LITE, description: 'Lite / lower cost' },
+        },
+        aliases: ['gemini-2-5-flash'],
+    },
+    // Google Gemini 3.0 Pro
+    'gemini-3.0-pro': {
+        id: 'gemini-3.0-pro',
+        defaultEnum: types_1.ModelEnum.GEMINI_3_0_PRO_MEDIUM,
+        variants: {
+            minimal: { enumValue: types_1.ModelEnum.GEMINI_3_0_PRO_MINIMAL, description: 'Cheaper, least reasoning' },
+            low: { enumValue: types_1.ModelEnum.GEMINI_3_0_PRO_LOW, description: 'Lower cost / speed' },
+            medium: { enumValue: types_1.ModelEnum.GEMINI_3_0_PRO_MEDIUM, description: 'Balanced (default)' },
+            high: { enumValue: types_1.ModelEnum.GEMINI_3_0_PRO_HIGH, description: 'Higher reasoning budget' },
+        },
+        aliases: ['gemini-3-0-pro'],
+    },
+    // Google Gemini 3.0 Flash
+    'gemini-3.0-flash': {
+        id: 'gemini-3.0-flash',
+        defaultEnum: types_1.ModelEnum.GEMINI_3_0_FLASH_MEDIUM,
+        variants: {
+            minimal: { enumValue: types_1.ModelEnum.GEMINI_3_0_FLASH_MINIMAL, description: 'Cheapest, lowest latency' },
+            low: { enumValue: types_1.ModelEnum.GEMINI_3_0_FLASH_LOW, description: 'Low thinking budget' },
+            medium: { enumValue: types_1.ModelEnum.GEMINI_3_0_FLASH_MEDIUM, description: 'Balanced (default)' },
+            high: { enumValue: types_1.ModelEnum.GEMINI_3_0_FLASH_HIGH, description: 'Higher reasoning budget' },
+        },
+        aliases: ['gemini-3-0-flash'],
+    },
+    // GPT 5.2
+    'gpt-5.2': {
+        id: 'gpt-5.2',
+        defaultEnum: types_1.ModelEnum.GPT_5_2_MEDIUM,
+        variants: {
+            low: { enumValue: types_1.ModelEnum.GPT_5_2_LOW, description: 'Lower cost' },
+            medium: { enumValue: types_1.ModelEnum.GPT_5_2_MEDIUM, description: 'Balanced (default)' },
+            high: { enumValue: types_1.ModelEnum.GPT_5_2_HIGH, description: 'Higher capability' },
+            xhigh: { enumValue: types_1.ModelEnum.GPT_5_2_XHIGH, description: 'Maximum capability' },
+            priority: { enumValue: types_1.ModelEnum.GPT_5_2_MEDIUM_PRIORITY, description: 'Priority routing (medium)' },
+            'low-priority': { enumValue: types_1.ModelEnum.GPT_5_2_LOW_PRIORITY, description: 'Priority routing (low)' },
+            'high-priority': { enumValue: types_1.ModelEnum.GPT_5_2_HIGH_PRIORITY, description: 'Priority routing (high)' },
+            'xhigh-priority': { enumValue: types_1.ModelEnum.GPT_5_2_XHIGH_PRIORITY, description: 'Priority routing (xhigh)' },
+        },
+        aliases: ['gpt-5-2'],
+    },
+    // GPT 5
+    'gpt-5': {
+        id: 'gpt-5',
+        defaultEnum: types_1.ModelEnum.GPT_5,
+        variants: {
+            low: { enumValue: types_1.ModelEnum.GPT_5_LOW, description: 'Lower cost' },
+            high: { enumValue: types_1.ModelEnum.GPT_5_HIGH, description: 'Higher capability' },
+            nano: { enumValue: types_1.ModelEnum.GPT_5_NANO, description: 'Small footprint' },
+        },
+    },
+    // GPT 5.1 Codex families
+    'gpt-5.1-codex-mini': {
+        id: 'gpt-5.1-codex-mini',
+        defaultEnum: types_1.ModelEnum.GPT_5_1_CODEX_MINI_MEDIUM,
+        variants: {
+            low: { enumValue: types_1.ModelEnum.GPT_5_1_CODEX_MINI_LOW },
+            medium: { enumValue: types_1.ModelEnum.GPT_5_1_CODEX_MINI_MEDIUM },
+            high: { enumValue: types_1.ModelEnum.GPT_5_1_CODEX_MINI_HIGH },
+        },
+        aliases: ['gpt-5-1-codex-mini'],
+    },
+    'gpt-5.1-codex': {
+        id: 'gpt-5.1-codex',
+        defaultEnum: types_1.ModelEnum.GPT_5_1_CODEX_MEDIUM,
+        variants: {
+            low: { enumValue: types_1.ModelEnum.GPT_5_1_CODEX_LOW },
+            medium: { enumValue: types_1.ModelEnum.GPT_5_1_CODEX_MEDIUM },
+            high: { enumValue: types_1.ModelEnum.GPT_5_1_CODEX_HIGH },
+        },
+        aliases: ['gpt-5-1-codex'],
+    },
+    'gpt-5.1-codex-max': {
+        id: 'gpt-5.1-codex-max',
+        defaultEnum: types_1.ModelEnum.GPT_5_1_CODEX_MAX_MEDIUM,
+        variants: {
+            low: { enumValue: types_1.ModelEnum.GPT_5_1_CODEX_MAX_LOW },
+            medium: { enumValue: types_1.ModelEnum.GPT_5_1_CODEX_MAX_MEDIUM },
+            high: { enumValue: types_1.ModelEnum.GPT_5_1_CODEX_MAX_HIGH },
+        },
+        aliases: ['gpt-5-1-codex-max'],
+    },
+    // O series
+    o3: {
+        id: 'o3',
+        defaultEnum: types_1.ModelEnum.O3,
+        variants: {
+            low: { enumValue: types_1.ModelEnum.O3_LOW },
+            high: { enumValue: types_1.ModelEnum.O3_HIGH },
+        },
+    },
+    'o3-pro': {
+        id: 'o3-pro',
+        defaultEnum: types_1.ModelEnum.O3_PRO,
+        variants: {
+            low: { enumValue: types_1.ModelEnum.O3_PRO_LOW },
+            high: { enumValue: types_1.ModelEnum.O3_PRO_HIGH },
+        },
+    },
+    'o4-mini': {
+        id: 'o4-mini',
+        defaultEnum: types_1.ModelEnum.O4_MINI,
+        variants: {
+            low: { enumValue: types_1.ModelEnum.O4_MINI_LOW },
+            high: { enumValue: types_1.ModelEnum.O4_MINI_HIGH },
+        },
+    },
+};
+const VARIANT_NAME_SET = new Set();
+for (const entry of Object.values(VARIANT_CATALOG)) {
+    if (entry.variants) {
+        for (const variantKey of Object.keys(entry.variants)) {
+            VARIANT_NAME_SET.add(`${entry.id}-${variantKey}`);
+            if (entry.aliases) {
+                for (const alias of entry.aliases) {
+                    VARIANT_NAME_SET.add(`${alias}-${variantKey}`);
+                }
+            }
+        }
+    }
+}
+// Mapping of alias -> canonical id for quick lookup
+const ALIAS_TO_ID = Object.values(VARIANT_CATALOG).reduce((acc, entry) => {
+    acc[entry.id] = entry.id;
+    for (const alias of entry.aliases || []) {
+        acc[alias] = entry.id;
+    }
+    return acc;
+}, {});
+function normalizeModelId(modelName) {
+    return modelName.toLowerCase().trim();
+}
+function splitModelAndVariant(raw) {
+    const normalized = normalizeModelId(raw);
+    // Allow colon-delimited (opencode variants) or suffix "-<variant>"
+    const colonIdx = normalized.indexOf(':');
+    if (colonIdx !== -1) {
+        const base = normalized.slice(0, colonIdx);
+        const variant = normalized.slice(colonIdx + 1).trim();
+        return { base, variant: variant || undefined };
+    }
+    const parts = normalized.split('-');
+    if (parts.length > 1) {
+        const maybeVariant = parts[parts.length - 1];
+        const base = parts.slice(0, -1).join('-');
+        if (VARIANT_CATALOG[ALIAS_TO_ID[base] || base]?.variants?.[maybeVariant]) {
+            return { base, variant: maybeVariant };
+        }
+    }
+    return { base: normalized };
+}
+// ============================================================================
+// Model Name Mappings (legacy fallback)
+// ============================================================================
+/**
+ * Map of model name strings to their protobuf enum values
+ * Supports multiple aliases for each model
+ */
+const MODEL_NAME_TO_ENUM = {
+    // ============================================================================
+    // Claude Models
+    // ============================================================================
+    'claude-3-opus': types_1.ModelEnum.CLAUDE_3_OPUS_20240229,
+    'claude-3-opus-20240229': types_1.ModelEnum.CLAUDE_3_OPUS_20240229,
+    'claude-3-sonnet': types_1.ModelEnum.CLAUDE_3_SONNET_20240229,
+    'claude-3-sonnet-20240229': types_1.ModelEnum.CLAUDE_3_SONNET_20240229,
+    'claude-3-haiku': types_1.ModelEnum.CLAUDE_3_HAIKU_20240307,
+    'claude-3-haiku-20240307': types_1.ModelEnum.CLAUDE_3_HAIKU_20240307,
+    'claude-3.5-sonnet': types_1.ModelEnum.CLAUDE_3_5_SONNET_20241022,
+    'claude-3-5-sonnet': types_1.ModelEnum.CLAUDE_3_5_SONNET_20241022,
+    'claude-3-5-sonnet-20241022': types_1.ModelEnum.CLAUDE_3_5_SONNET_20241022,
+    'claude-3.5-haiku': types_1.ModelEnum.CLAUDE_3_5_HAIKU_20241022,
+    'claude-3-5-haiku': types_1.ModelEnum.CLAUDE_3_5_HAIKU_20241022,
+    'claude-3-5-haiku-20241022': types_1.ModelEnum.CLAUDE_3_5_HAIKU_20241022,
+    'claude-3.7-sonnet': types_1.ModelEnum.CLAUDE_3_7_SONNET_20250219,
+    'claude-3-7-sonnet': types_1.ModelEnum.CLAUDE_3_7_SONNET_20250219,
+    'claude-3-7-sonnet-20250219': types_1.ModelEnum.CLAUDE_3_7_SONNET_20250219,
+    'claude-3.7-sonnet-thinking': types_1.ModelEnum.CLAUDE_3_7_SONNET_20250219_THINKING,
+    'claude-3-7-sonnet-thinking': types_1.ModelEnum.CLAUDE_3_7_SONNET_20250219_THINKING,
+    'claude-4-opus': types_1.ModelEnum.CLAUDE_4_OPUS,
+    'claude-4-opus-thinking': types_1.ModelEnum.CLAUDE_4_OPUS_THINKING,
+    'claude-4-sonnet': types_1.ModelEnum.CLAUDE_4_SONNET,
+    'claude-4-sonnet-thinking': types_1.ModelEnum.CLAUDE_4_SONNET_THINKING,
+    'claude-4.1-opus': types_1.ModelEnum.CLAUDE_4_1_OPUS,
+    'claude-4-1-opus': types_1.ModelEnum.CLAUDE_4_1_OPUS,
+    'claude-4.1-opus-thinking': types_1.ModelEnum.CLAUDE_4_1_OPUS_THINKING,
+    'claude-4-1-opus-thinking': types_1.ModelEnum.CLAUDE_4_1_OPUS_THINKING,
+    'claude-4.5-sonnet': types_1.ModelEnum.CLAUDE_4_5_SONNET,
+    'claude-4-5-sonnet': types_1.ModelEnum.CLAUDE_4_5_SONNET,
+    'claude-4.5-sonnet-thinking': types_1.ModelEnum.CLAUDE_4_5_SONNET_THINKING,
+    'claude-4-5-sonnet-thinking': types_1.ModelEnum.CLAUDE_4_5_SONNET_THINKING,
+    // NOTE: claude-4.5-sonnet-1m is defined in enum but not available via API
+    'claude-4.5-opus': types_1.ModelEnum.CLAUDE_4_5_OPUS,
+    'claude-4-5-opus': types_1.ModelEnum.CLAUDE_4_5_OPUS,
+    'claude-4.5-opus-thinking': types_1.ModelEnum.CLAUDE_4_5_OPUS_THINKING,
+    'claude-4-5-opus-thinking': types_1.ModelEnum.CLAUDE_4_5_OPUS_THINKING,
+    'claude-code': types_1.ModelEnum.CLAUDE_CODE,
+    // ============================================================================
+    // GPT Models
+    // ============================================================================
+    'gpt-4': types_1.ModelEnum.GPT_4,
+    'gpt-4-turbo': types_1.ModelEnum.GPT_4_1106_PREVIEW,
+    'gpt-4-1106-preview': types_1.ModelEnum.GPT_4_1106_PREVIEW,
+    'gpt-4o': types_1.ModelEnum.GPT_4O_2024_08_06,
+    'gpt-4o-2024-08-06': types_1.ModelEnum.GPT_4O_2024_08_06,
+    'gpt-4o-mini': types_1.ModelEnum.GPT_4O_MINI_2024_07_18,
+    'gpt-4o-mini-2024-07-18': types_1.ModelEnum.GPT_4O_MINI_2024_07_18,
+    // NOTE: gpt-4.5 is defined in enum but not available via API
+    'gpt-4.1': types_1.ModelEnum.GPT_4_1_2025_04_14,
+    'gpt-4-1': types_1.ModelEnum.GPT_4_1_2025_04_14,
+    'gpt-4.1-mini': types_1.ModelEnum.GPT_4_1_MINI_2025_04_14,
+    'gpt-4-1-mini': types_1.ModelEnum.GPT_4_1_MINI_2025_04_14,
+    'gpt-4.1-nano': types_1.ModelEnum.GPT_4_1_NANO_2025_04_14,
+    'gpt-4-1-nano': types_1.ModelEnum.GPT_4_1_NANO_2025_04_14,
+    'gpt-5': types_1.ModelEnum.GPT_5,
+    'gpt-5-nano': types_1.ModelEnum.GPT_5_NANO,
+    'gpt-5-low': types_1.ModelEnum.GPT_5_LOW,
+    'gpt-5-high': types_1.ModelEnum.GPT_5_HIGH,
+    'gpt-5-codex': types_1.ModelEnum.GPT_5_CODEX,
+    // GPT 5.1 Codex variants
+    'gpt-5.1-codex-mini-low': types_1.ModelEnum.GPT_5_1_CODEX_MINI_LOW,
+    'gpt-5.1-codex-mini-medium': types_1.ModelEnum.GPT_5_1_CODEX_MINI_MEDIUM,
+    'gpt-5.1-codex-mini-high': types_1.ModelEnum.GPT_5_1_CODEX_MINI_HIGH,
+    'gpt-5.1-codex-mini': types_1.ModelEnum.GPT_5_1_CODEX_MINI_MEDIUM,
+    'gpt-5.1-codex-low': types_1.ModelEnum.GPT_5_1_CODEX_LOW,
+    'gpt-5.1-codex-medium': types_1.ModelEnum.GPT_5_1_CODEX_MEDIUM,
+    'gpt-5.1-codex-high': types_1.ModelEnum.GPT_5_1_CODEX_HIGH,
+    'gpt-5.1-codex': types_1.ModelEnum.GPT_5_1_CODEX_MEDIUM,
+    'gpt-5.1-codex-max-low': types_1.ModelEnum.GPT_5_1_CODEX_MAX_LOW,
+    'gpt-5.1-codex-max-medium': types_1.ModelEnum.GPT_5_1_CODEX_MAX_MEDIUM,
+    'gpt-5.1-codex-max-high': types_1.ModelEnum.GPT_5_1_CODEX_MAX_HIGH,
+    'gpt-5.1-codex-max': types_1.ModelEnum.GPT_5_1_CODEX_MAX_MEDIUM,
+    // GPT 5.2 variants
+    'gpt-5.2': types_1.ModelEnum.GPT_5_2_MEDIUM,
+    'gpt-5-2': types_1.ModelEnum.GPT_5_2_MEDIUM,
+    'gpt-5.2-low': types_1.ModelEnum.GPT_5_2_LOW,
+    'gpt-5-2-low': types_1.ModelEnum.GPT_5_2_LOW,
+    'gpt-5.2-high': types_1.ModelEnum.GPT_5_2_HIGH,
+    'gpt-5-2-high': types_1.ModelEnum.GPT_5_2_HIGH,
+    'gpt-5.2-xhigh': types_1.ModelEnum.GPT_5_2_XHIGH,
+    'gpt-5-2-xhigh': types_1.ModelEnum.GPT_5_2_XHIGH,
+    'gpt-5.2-priority': types_1.ModelEnum.GPT_5_2_MEDIUM_PRIORITY,
+    'gpt-5.2-low-priority': types_1.ModelEnum.GPT_5_2_LOW_PRIORITY,
+    'gpt-5.2-high-priority': types_1.ModelEnum.GPT_5_2_HIGH_PRIORITY,
+    'gpt-5.2-xhigh-priority': types_1.ModelEnum.GPT_5_2_XHIGH_PRIORITY,
+    // ============================================================================
+    // O-Series (OpenAI Reasoning)
+    // NOTE: o1, o1-mini, o1-preview are deprecated - use o3/o4 series instead
+    // ============================================================================
+    'o3': types_1.ModelEnum.O3,
+    'o3-mini': types_1.ModelEnum.O3_MINI,
+    'o3-low': types_1.ModelEnum.O3_LOW,
+    'o3-high': types_1.ModelEnum.O3_HIGH,
+    'o3-pro': types_1.ModelEnum.O3_PRO,
+    'o3-pro-low': types_1.ModelEnum.O3_PRO_LOW,
+    'o3-pro-high': types_1.ModelEnum.O3_PRO_HIGH,
+    'o4-mini': types_1.ModelEnum.O4_MINI,
+    'o4-mini-low': types_1.ModelEnum.O4_MINI_LOW,
+    'o4-mini-high': types_1.ModelEnum.O4_MINI_HIGH,
+    // ============================================================================
+    // Google Gemini
+    // NOTE: gemini-1.0-pro and gemini-1.5-pro are deprecated - use 2.x+ versions
+    // ============================================================================
+    'gemini-2.0-flash': types_1.ModelEnum.GEMINI_2_0_FLASH,
+    'gemini-2-0-flash': types_1.ModelEnum.GEMINI_2_0_FLASH,
+    'gemini-2.5-pro': types_1.ModelEnum.GEMINI_2_5_PRO,
+    'gemini-2-5-pro': types_1.ModelEnum.GEMINI_2_5_PRO,
+    'gemini-2.5-flash': types_1.ModelEnum.GEMINI_2_5_FLASH,
+    'gemini-2-5-flash': types_1.ModelEnum.GEMINI_2_5_FLASH,
+    'gemini-2.5-flash-thinking': types_1.ModelEnum.GEMINI_2_5_FLASH_THINKING,
+    'gemini-2-5-flash-thinking': types_1.ModelEnum.GEMINI_2_5_FLASH_THINKING,
+    'gemini-2.5-flash-lite': types_1.ModelEnum.GEMINI_2_5_FLASH_LITE,
+    'gemini-2-5-flash-lite': types_1.ModelEnum.GEMINI_2_5_FLASH_LITE,
+    'gemini-3.0-pro-low': types_1.ModelEnum.GEMINI_3_0_PRO_LOW,
+    'gemini-3-0-pro-low': types_1.ModelEnum.GEMINI_3_0_PRO_LOW,
+    'gemini-3.0-pro-high': types_1.ModelEnum.GEMINI_3_0_PRO_HIGH,
+    'gemini-3-0-pro-high': types_1.ModelEnum.GEMINI_3_0_PRO_HIGH,
+    'gemini-3.0-pro': types_1.ModelEnum.GEMINI_3_0_PRO_MEDIUM,
+    'gemini-3-0-pro': types_1.ModelEnum.GEMINI_3_0_PRO_MEDIUM,
+    'gemini-3.0-pro-minimal': types_1.ModelEnum.GEMINI_3_0_PRO_MINIMAL,
+    'gemini-3-0-pro-minimal': types_1.ModelEnum.GEMINI_3_0_PRO_MINIMAL,
+    'gemini-3.0-pro-medium': types_1.ModelEnum.GEMINI_3_0_PRO_MEDIUM,
+    'gemini-3-0-pro-medium': types_1.ModelEnum.GEMINI_3_0_PRO_MEDIUM,
+    'gemini-3.0-flash': types_1.ModelEnum.GEMINI_3_0_FLASH_MEDIUM,
+    'gemini-3-0-flash': types_1.ModelEnum.GEMINI_3_0_FLASH_MEDIUM,
+    'gemini-3.0-flash-minimal': types_1.ModelEnum.GEMINI_3_0_FLASH_MINIMAL,
+    'gemini-3-0-flash-minimal': types_1.ModelEnum.GEMINI_3_0_FLASH_MINIMAL,
+    'gemini-3.0-flash-low': types_1.ModelEnum.GEMINI_3_0_FLASH_LOW,
+    'gemini-3-0-flash-low': types_1.ModelEnum.GEMINI_3_0_FLASH_LOW,
+    'gemini-3.0-flash-medium': types_1.ModelEnum.GEMINI_3_0_FLASH_MEDIUM,
+    'gemini-3-0-flash-medium': types_1.ModelEnum.GEMINI_3_0_FLASH_MEDIUM,
+    'gemini-3.0-flash-high': types_1.ModelEnum.GEMINI_3_0_FLASH_HIGH,
+    'gemini-3-0-flash-high': types_1.ModelEnum.GEMINI_3_0_FLASH_HIGH,
+    // ============================================================================
+    // DeepSeek
+    // ============================================================================
+    'deepseek-v3': types_1.ModelEnum.DEEPSEEK_V3,
+    'deepseek-v3-2': types_1.ModelEnum.DEEPSEEK_V3_2,
+    'deepseek-r1': types_1.ModelEnum.DEEPSEEK_R1,
+    'deepseek-r1-fast': types_1.ModelEnum.DEEPSEEK_R1_FAST,
+    'deepseek-r1-slow': types_1.ModelEnum.DEEPSEEK_R1_SLOW,
+    // ============================================================================
+    // Llama
+    // ============================================================================
+    'llama-3.1-8b': types_1.ModelEnum.LLAMA_3_1_8B_INSTRUCT,
+    'llama-3-1-8b': types_1.ModelEnum.LLAMA_3_1_8B_INSTRUCT,
+    'llama-3.1-70b': types_1.ModelEnum.LLAMA_3_1_70B_INSTRUCT,
+    'llama-3-1-70b': types_1.ModelEnum.LLAMA_3_1_70B_INSTRUCT,
+    'llama-3.1-405b': types_1.ModelEnum.LLAMA_3_1_405B_INSTRUCT,
+    'llama-3-1-405b': types_1.ModelEnum.LLAMA_3_1_405B_INSTRUCT,
+    'llama-3.3-70b': types_1.ModelEnum.LLAMA_3_3_70B_INSTRUCT,
+    'llama-3-3-70b': types_1.ModelEnum.LLAMA_3_3_70B_INSTRUCT,
+    'llama-3.3-70b-r1': types_1.ModelEnum.LLAMA_3_3_70B_INSTRUCT_R1,
+    'llama-3-3-70b-r1': types_1.ModelEnum.LLAMA_3_3_70B_INSTRUCT_R1,
+    // ============================================================================
+    // Qwen
+    // ============================================================================
+    'qwen-2.5-7b': types_1.ModelEnum.QWEN_2_5_7B_INSTRUCT,
+    'qwen-2-5-7b': types_1.ModelEnum.QWEN_2_5_7B_INSTRUCT,
+    'qwen-2.5-32b': types_1.ModelEnum.QWEN_2_5_32B_INSTRUCT,
+    'qwen-2-5-32b': types_1.ModelEnum.QWEN_2_5_32B_INSTRUCT,
+    'qwen-2.5-72b': types_1.ModelEnum.QWEN_2_5_72B_INSTRUCT,
+    'qwen-2-5-72b': types_1.ModelEnum.QWEN_2_5_72B_INSTRUCT,
+    'qwen-3-235b': types_1.ModelEnum.QWEN_3_235B_INSTRUCT,
+    'qwen-3-coder-480b': types_1.ModelEnum.QWEN_3_CODER_480B_INSTRUCT,
+    'qwen-3-coder-480b-fast': types_1.ModelEnum.QWEN_3_CODER_480B_INSTRUCT_FAST,
+    'qwen-3-coder': types_1.ModelEnum.QWEN_3_CODER_480B_INSTRUCT,
+    'qwen-2.5-32b-r1': types_1.ModelEnum.QWEN_2_5_32B_INSTRUCT_R1,
+    'qwen-2-5-32b-r1': types_1.ModelEnum.QWEN_2_5_32B_INSTRUCT_R1,
+    // ============================================================================
+    // XAI Grok
+    // ============================================================================
+    'grok-2': types_1.ModelEnum.GROK_2,
+    'grok-3': types_1.ModelEnum.GROK_3,
+    'grok-3-mini': types_1.ModelEnum.GROK_3_MINI_REASONING,
+    'grok-code-fast': types_1.ModelEnum.GROK_CODE_FAST,
+    // ============================================================================
+    // Other Models
+    // ============================================================================
+    'mistral-7b': types_1.ModelEnum.MISTRAL_7B,
+    'kimi-k2': types_1.ModelEnum.KIMI_K2,
+    'kimi-k2-thinking': types_1.ModelEnum.KIMI_K2_THINKING,
+    'glm-4.5': types_1.ModelEnum.GLM_4_5,
+    'glm-4-5': types_1.ModelEnum.GLM_4_5,
+    'glm-4.5-fast': types_1.ModelEnum.GLM_4_5_FAST,
+    'glm-4-5-fast': types_1.ModelEnum.GLM_4_5_FAST,
+    'glm-4.6': types_1.ModelEnum.GLM_4_6,
+    'glm-4-6': types_1.ModelEnum.GLM_4_6,
+    'glm-4.6-fast': types_1.ModelEnum.GLM_4_6_FAST,
+    'glm-4-6-fast': types_1.ModelEnum.GLM_4_6_FAST,
+    'glm-4.7': types_1.ModelEnum.GLM_4_7,
+    'glm-4-7': types_1.ModelEnum.GLM_4_7,
+    'glm-4.7-fast': types_1.ModelEnum.GLM_4_7_FAST,
+    'glm-4-7-fast': types_1.ModelEnum.GLM_4_7_FAST,
+    'minimax-m2': types_1.ModelEnum.MINIMAX_M2,
+    'minimax-m2.1': types_1.ModelEnum.MINIMAX_M2_1,
+    'minimax-m2-1': types_1.ModelEnum.MINIMAX_M2_1,
+    'swe-1.5': types_1.ModelEnum.SWE_1_5,
+    'swe-1-5': types_1.ModelEnum.SWE_1_5,
+    'swe-1.5-thinking': types_1.ModelEnum.SWE_1_5_THINKING,
+    'swe-1-5-thinking': types_1.ModelEnum.SWE_1_5_THINKING,
+    'swe-1.5-slow': types_1.ModelEnum.SWE_1_5_SLOW,
+    'swe-1-5-slow': types_1.ModelEnum.SWE_1_5_SLOW,
+};
+/**
+ * Reverse mapping from enum values to canonical model names
+ */
+const ENUM_TO_MODEL_NAME = {
+    // Claude
+    [types_1.ModelEnum.CLAUDE_3_OPUS_20240229]: 'claude-3-opus',
+    [types_1.ModelEnum.CLAUDE_3_SONNET_20240229]: 'claude-3-sonnet',
+    [types_1.ModelEnum.CLAUDE_3_HAIKU_20240307]: 'claude-3-haiku',
+    [types_1.ModelEnum.CLAUDE_3_5_SONNET_20241022]: 'claude-3.5-sonnet',
+    [types_1.ModelEnum.CLAUDE_3_5_HAIKU_20241022]: 'claude-3.5-haiku',
+    [types_1.ModelEnum.CLAUDE_3_7_SONNET_20250219]: 'claude-3.7-sonnet',
+    [types_1.ModelEnum.CLAUDE_3_7_SONNET_20250219_THINKING]: 'claude-3.7-sonnet-thinking',
+    [types_1.ModelEnum.CLAUDE_4_OPUS]: 'claude-4-opus',
+    [types_1.ModelEnum.CLAUDE_4_OPUS_THINKING]: 'claude-4-opus-thinking',
+    [types_1.ModelEnum.CLAUDE_4_SONNET]: 'claude-4-sonnet',
+    [types_1.ModelEnum.CLAUDE_4_SONNET_THINKING]: 'claude-4-sonnet-thinking',
+    [types_1.ModelEnum.CLAUDE_4_1_OPUS]: 'claude-4.1-opus',
+    [types_1.ModelEnum.CLAUDE_4_1_OPUS_THINKING]: 'claude-4.1-opus-thinking',
+    [types_1.ModelEnum.CLAUDE_4_5_SONNET]: 'claude-4.5-sonnet',
+    [types_1.ModelEnum.CLAUDE_4_5_SONNET_THINKING]: 'claude-4.5-sonnet-thinking',
+    // NOTE: CLAUDE_4_5_SONNET_1M not available via API
+    [types_1.ModelEnum.CLAUDE_4_5_OPUS]: 'claude-4.5-opus',
+    [types_1.ModelEnum.CLAUDE_4_5_OPUS_THINKING]: 'claude-4.5-opus-thinking',
+    [types_1.ModelEnum.CLAUDE_CODE]: 'claude-code',
+    // GPT
+    [types_1.ModelEnum.GPT_4]: 'gpt-4',
+    [types_1.ModelEnum.GPT_4_1106_PREVIEW]: 'gpt-4-turbo',
+    [types_1.ModelEnum.GPT_4O_2024_08_06]: 'gpt-4o',
+    [types_1.ModelEnum.GPT_4O_MINI_2024_07_18]: 'gpt-4o-mini',
+    // NOTE: GPT_4_5 not available via API
+    [types_1.ModelEnum.GPT_4_1_2025_04_14]: 'gpt-4.1',
+    [types_1.ModelEnum.GPT_4_1_MINI_2025_04_14]: 'gpt-4.1-mini',
+    [types_1.ModelEnum.GPT_4_1_NANO_2025_04_14]: 'gpt-4.1-nano',
+    [types_1.ModelEnum.GPT_5]: 'gpt-5',
+    [types_1.ModelEnum.GPT_5_NANO]: 'gpt-5-nano',
+    [types_1.ModelEnum.GPT_5_LOW]: 'gpt-5-low',
+    [types_1.ModelEnum.GPT_5_HIGH]: 'gpt-5-high',
+    [types_1.ModelEnum.GPT_5_CODEX]: 'gpt-5-codex',
+    [types_1.ModelEnum.GPT_5_1_CODEX_MINI_MEDIUM]: 'gpt-5.1-codex-mini',
+    [types_1.ModelEnum.GPT_5_1_CODEX_MEDIUM]: 'gpt-5.1-codex',
+    [types_1.ModelEnum.GPT_5_1_CODEX_MAX_MEDIUM]: 'gpt-5.1-codex-max',
+    [types_1.ModelEnum.GPT_5_2_LOW]: 'gpt-5.2-low',
+    [types_1.ModelEnum.GPT_5_2_MEDIUM]: 'gpt-5.2',
+    [types_1.ModelEnum.GPT_5_2_HIGH]: 'gpt-5.2-high',
+    [types_1.ModelEnum.GPT_5_2_XHIGH]: 'gpt-5.2-xhigh',
+    [types_1.ModelEnum.GPT_5_2_MEDIUM_PRIORITY]: 'gpt-5.2-priority',
+    // O-Series (o1 series deprecated - use o3/o4)
+    [types_1.ModelEnum.O3]: 'o3',
+    [types_1.ModelEnum.O3_MINI]: 'o3-mini',
+    [types_1.ModelEnum.O3_LOW]: 'o3-low',
+    [types_1.ModelEnum.O3_HIGH]: 'o3-high',
+    [types_1.ModelEnum.O3_PRO]: 'o3-pro',
+    [types_1.ModelEnum.O3_PRO_LOW]: 'o3-pro-low',
+    [types_1.ModelEnum.O3_PRO_HIGH]: 'o3-pro-high',
+    [types_1.ModelEnum.O4_MINI]: 'o4-mini',
+    [types_1.ModelEnum.O4_MINI_LOW]: 'o4-mini-low',
+    [types_1.ModelEnum.O4_MINI_HIGH]: 'o4-mini-high',
+    // Gemini (1.x series deprecated - use 2.x+)
+    [types_1.ModelEnum.GEMINI_2_0_FLASH]: 'gemini-2.0-flash',
+    [types_1.ModelEnum.GEMINI_2_5_PRO]: 'gemini-2.5-pro',
+    [types_1.ModelEnum.GEMINI_2_5_FLASH]: 'gemini-2.5-flash',
+    [types_1.ModelEnum.GEMINI_2_5_FLASH_THINKING]: 'gemini-2.5-flash-thinking',
+    [types_1.ModelEnum.GEMINI_2_5_FLASH_LITE]: 'gemini-2.5-flash-lite',
+    [types_1.ModelEnum.GEMINI_3_0_PRO_LOW]: 'gemini-3.0-pro-low',
+    [types_1.ModelEnum.GEMINI_3_0_PRO_HIGH]: 'gemini-3.0-pro-high',
+    [types_1.ModelEnum.GEMINI_3_0_PRO_MEDIUM]: 'gemini-3.0-pro',
+    [types_1.ModelEnum.GEMINI_3_0_FLASH_MEDIUM]: 'gemini-3.0-flash',
+    [types_1.ModelEnum.GEMINI_3_0_FLASH_HIGH]: 'gemini-3.0-flash-high',
+    // DeepSeek
+    [types_1.ModelEnum.DEEPSEEK_V3]: 'deepseek-v3',
+    [types_1.ModelEnum.DEEPSEEK_V3_2]: 'deepseek-v3-2',
+    [types_1.ModelEnum.DEEPSEEK_R1]: 'deepseek-r1',
+    [types_1.ModelEnum.DEEPSEEK_R1_FAST]: 'deepseek-r1-fast',
+    [types_1.ModelEnum.DEEPSEEK_R1_SLOW]: 'deepseek-r1-slow',
+    // Llama
+    [types_1.ModelEnum.LLAMA_3_1_8B_INSTRUCT]: 'llama-3.1-8b',
+    [types_1.ModelEnum.LLAMA_3_1_70B_INSTRUCT]: 'llama-3.1-70b',
+    [types_1.ModelEnum.LLAMA_3_1_405B_INSTRUCT]: 'llama-3.1-405b',
+    [types_1.ModelEnum.LLAMA_3_3_70B_INSTRUCT]: 'llama-3.3-70b',
+    [types_1.ModelEnum.LLAMA_3_3_70B_INSTRUCT_R1]: 'llama-3.3-70b-r1',
+    // Qwen
+    [types_1.ModelEnum.QWEN_2_5_7B_INSTRUCT]: 'qwen-2.5-7b',
+    [types_1.ModelEnum.QWEN_2_5_32B_INSTRUCT]: 'qwen-2.5-32b',
+    [types_1.ModelEnum.QWEN_2_5_72B_INSTRUCT]: 'qwen-2.5-72b',
+    [types_1.ModelEnum.QWEN_2_5_32B_INSTRUCT_R1]: 'qwen-2.5-32b-r1',
+    [types_1.ModelEnum.QWEN_3_235B_INSTRUCT]: 'qwen-3-235b',
+    [types_1.ModelEnum.QWEN_3_CODER_480B_INSTRUCT]: 'qwen-3-coder-480b',
+    [types_1.ModelEnum.QWEN_3_CODER_480B_INSTRUCT_FAST]: 'qwen-3-coder-480b-fast',
+    // Grok
+    [types_1.ModelEnum.GROK_2]: 'grok-2',
+    [types_1.ModelEnum.GROK_3]: 'grok-3',
+    [types_1.ModelEnum.GROK_3_MINI_REASONING]: 'grok-3-mini',
+    [types_1.ModelEnum.GROK_CODE_FAST]: 'grok-code-fast',
+    // Other
+    [types_1.ModelEnum.MISTRAL_7B]: 'mistral-7b',
+    [types_1.ModelEnum.KIMI_K2]: 'kimi-k2',
+    [types_1.ModelEnum.KIMI_K2_THINKING]: 'kimi-k2-thinking',
+    [types_1.ModelEnum.GLM_4_5]: 'glm-4.5',
+    [types_1.ModelEnum.GLM_4_5_FAST]: 'glm-4.5-fast',
+    [types_1.ModelEnum.GLM_4_6]: 'glm-4.6',
+    [types_1.ModelEnum.GLM_4_6_FAST]: 'glm-4.6-fast',
+    [types_1.ModelEnum.GLM_4_7]: 'glm-4.7',
+    [types_1.ModelEnum.GLM_4_7_FAST]: 'glm-4.7-fast',
+    [types_1.ModelEnum.MINIMAX_M2]: 'minimax-m2',
+    [types_1.ModelEnum.MINIMAX_M2_1]: 'minimax-m2.1',
+    [types_1.ModelEnum.SWE_1_5]: 'swe-1.5',
+    [types_1.ModelEnum.SWE_1_5_THINKING]: 'swe-1.5-thinking',
+    [types_1.ModelEnum.SWE_1_5_SLOW]: 'swe-1.5-slow',
+};
+// ============================================================================
+// Public API
+// ============================================================================
+function resolveModel(modelName, variantOverride) {
+    const { base, variant } = splitModelAndVariant(modelName);
+    const baseId = ALIAS_TO_ID[base] || base;
+    const entry = VARIANT_CATALOG[baseId];
+    if (entry) {
+        const effectiveVariant = (variantOverride || variant || '').trim().toLowerCase();
+        if (effectiveVariant && entry.variants?.[effectiveVariant]) {
+            return {
+                enumValue: entry.variants[effectiveVariant].enumValue,
+                modelId: entry.id,
+                variant: effectiveVariant,
+            };
+        }
+        return { enumValue: entry.defaultEnum, modelId: entry.id };
+    }
+    // Fallback to legacy map
+    const normalized = normalizeModelId(modelName);
+    const enumValue = MODEL_NAME_TO_ENUM[normalized];
+    if (enumValue) {
+        return { enumValue, modelId: normalized };
+    }
+    return { enumValue: types_1.ModelEnum.CLAUDE_3_5_SONNET_20241022, modelId: 'claude-3.5-sonnet' };
+}
+/**
+ * Convert a model name string (optionally including variant) to enum
+ */
+function modelNameToEnum(modelName, variantOverride) {
+    return resolveModel(modelName, variantOverride).enumValue;
+}
+/**
+ * Convert a protobuf enum value to a canonical model name
+ * @param enumValue - The enum value
+ * @returns The canonical model name string
+ */
+function enumToModelName(enumValue) {
+    return ENUM_TO_MODEL_NAME[enumValue] ?? 'claude-3.5-sonnet';
+}
+/**
+ * Get all supported model names (includes legacy aliases)
+ */
+function getSupportedModels() {
+    const fromVariants = Object.keys(VARIANT_CATALOG);
+    const aliases = [];
+    for (const entry of Object.values(VARIANT_CATALOG)) {
+        if (entry.aliases)
+            aliases.push(...entry.aliases);
+        if (entry.variants) {
+            for (const variantKey of Object.keys(entry.variants)) {
+                aliases.push(`${entry.id}-${variantKey}`);
+                for (const alias of entry.aliases || []) {
+                    aliases.push(`${alias}-${variantKey}`);
+                }
+            }
+        }
+    }
+    return Array.from(new Set([...fromVariants, ...aliases, ...Object.keys(MODEL_NAME_TO_ENUM)]));
+}
+/**
+ * Check if a model name is supported (canonical or alias or variant)
+ */
+function isModelSupported(modelName) {
+    const normalized = normalizeModelId(modelName);
+    const { base, variant } = splitModelAndVariant(normalized);
+    const baseId = ALIAS_TO_ID[base] || base;
+    if (variant && VARIANT_CATALOG[baseId]?.variants?.[variant])
+        return true;
+    if (VARIANT_CATALOG[baseId])
+        return true;
+    return normalized in MODEL_NAME_TO_ENUM;
+}
+/** Default canonical model */
+function getDefaultModel() {
+    return 'claude-3.5-sonnet';
+}
+function getDefaultModelEnum() {
+    return types_1.ModelEnum.CLAUDE_3_5_SONNET_20241022;
+}
+/**
+ * Canonical models (no variants), aligned with OpenCode listing
+ */
+function getCanonicalModels() {
+    const bases = new Set(Object.keys(VARIANT_CATALOG));
+    // Add non-variant canonical names derived from enum mapping
+    for (const name of Object.values(ENUM_TO_MODEL_NAME)) {
+        if (!name)
+            continue;
+        if (VARIANT_NAME_SET.has(name))
+            continue; // skip variant entries
+        if (!bases.has(name))
+            bases.add(name);
+    }
+    return Array.from(bases).sort();
+}
+function getModelVariants(modelId) {
+    const baseId = ALIAS_TO_ID[normalizeModelId(modelId)] || normalizeModelId(modelId);
+    return VARIANT_CATALOG[baseId]?.variants;
+}
diff --git a/src/providers/windsurf/types.js b/src/providers/windsurf/types.js
new file mode 100644
index 0000000..21d852c
--- /dev/null
+++ b/src/providers/windsurf/types.js
@@ -0,0 +1,179 @@
+"use strict";
+/**
+ * TypeScript type definitions for the Windsurf plugin
+ */
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.ChatMessageSource = exports.ModelEnum = void 0;
+// ============================================================================
+// Model Enums (Protobuf values from Windsurf language server)
+// ============================================================================
+/**
+ * Numeric enum values for Windsurf models (used in protobuf encoding)
+ * These values are extracted from Windsurf's extension.js via reverse engineering.
+ *
+ * To discover these values yourself:
+ * 1. Find extension.js: /Applications/Windsurf.app/Contents/Resources/app/extensions/windsurf/dist/extension.js
+ * 2. Search for patterns like: grep -oE 'CLAUDE[A-Z0-9_]+\s*=\s*[0-9]+' extension.js
+ */
+exports.ModelEnum = {
+    MODEL_UNSPECIFIED: 0,
+    // ============================================================================
+    // Claude Models
+    // ============================================================================
+    CLAUDE_3_OPUS_20240229: 63,
+    CLAUDE_3_SONNET_20240229: 64,
+    CLAUDE_3_HAIKU_20240307: 172,
+    CLAUDE_3_5_SONNET_20240620: 80,
+    CLAUDE_3_5_SONNET_20241022: 166,
+    CLAUDE_3_5_HAIKU_20241022: 171,
+    CLAUDE_3_7_SONNET_20250219: 226,
+    CLAUDE_3_7_SONNET_20250219_THINKING: 227,
+    CLAUDE_4_OPUS: 290,
+    CLAUDE_4_OPUS_THINKING: 291,
+    CLAUDE_4_SONNET: 281,
+    CLAUDE_4_SONNET_THINKING: 282,
+    CLAUDE_4_1_OPUS: 328,
+    CLAUDE_4_1_OPUS_THINKING: 329,
+    CLAUDE_4_5_SONNET: 353,
+    CLAUDE_4_5_SONNET_THINKING: 354,
+    CLAUDE_4_5_SONNET_1M: 370,
+    CLAUDE_4_5_OPUS: 391,
+    CLAUDE_4_5_OPUS_THINKING: 392,
+    CLAUDE_CODE: 344,
+    // ============================================================================
+    // GPT Models
+    // ============================================================================
+    GPT_4: 30,
+    GPT_4_1106_PREVIEW: 37,
+    GPT_4O_2024_05_13: 71,
+    GPT_4O_2024_08_06: 109,
+    GPT_4O_MINI_2024_07_18: 113,
+    GPT_4_5: 228,
+    GPT_4_1_2025_04_14: 259,
+    GPT_4_1_MINI_2025_04_14: 260,
+    GPT_4_1_NANO_2025_04_14: 261,
+    GPT_5_NANO: 337,
+    GPT_5_MINIMAL: 338,
+    GPT_5_LOW: 339,
+    GPT_5: 340,
+    GPT_5_HIGH: 341,
+    GPT_5_CODEX: 346,
+    // GPT 5.1 Codex variants
+    GPT_5_1_CODEX_MINI_LOW: 385,
+    GPT_5_1_CODEX_MINI_MEDIUM: 386,
+    GPT_5_1_CODEX_MINI_HIGH: 387,
+    GPT_5_1_CODEX_LOW: 388,
+    GPT_5_1_CODEX_MEDIUM: 389,
+    GPT_5_1_CODEX_HIGH: 390,
+    GPT_5_1_CODEX_MAX_LOW: 395,
+    GPT_5_1_CODEX_MAX_MEDIUM: 396,
+    GPT_5_1_CODEX_MAX_HIGH: 397,
+    // GPT 5.2 variants
+    GPT_5_2_NONE: 399,
+    GPT_5_2_LOW: 400,
+    GPT_5_2_MEDIUM: 401,
+    GPT_5_2_HIGH: 402,
+    GPT_5_2_XHIGH: 403,
+    GPT_5_2_NONE_PRIORITY: 404,
+    GPT_5_2_LOW_PRIORITY: 405,
+    GPT_5_2_MEDIUM_PRIORITY: 406,
+    GPT_5_2_HIGH_PRIORITY: 407,
+    GPT_5_2_XHIGH_PRIORITY: 408,
+    // ============================================================================
+    // O-Series (OpenAI Reasoning)
+    // ============================================================================
+    O1_PREVIEW: 117,
+    O1_MINI: 118,
+    O1: 170,
+    O3_MINI: 207,
+    O3_MINI_LOW: 213,
+    O3_MINI_HIGH: 214,
+    O3: 218,
+    O3_LOW: 262,
+    O3_HIGH: 263,
+    O3_PRO: 294,
+    O3_PRO_LOW: 295,
+    O3_PRO_HIGH: 296,
+    O4_MINI: 264,
+    O4_MINI_LOW: 265,
+    O4_MINI_HIGH: 266,
+    // ============================================================================
+    // Google Gemini
+    // ============================================================================
+    GEMINI_1_0_PRO: 61,
+    GEMINI_1_5_PRO: 62,
+    GEMINI_2_0_FLASH: 184,
+    GEMINI_2_5_PRO: 246,
+    GEMINI_2_5_FLASH: 312,
+    GEMINI_2_5_FLASH_THINKING: 313,
+    GEMINI_2_5_FLASH_LITE: 343,
+    GEMINI_3_0_PRO_LOW: 378,
+    GEMINI_3_0_PRO_HIGH: 379,
+    GEMINI_3_0_PRO_MINIMAL: 411,
+    GEMINI_3_0_PRO_MEDIUM: 412,
+    GEMINI_3_0_FLASH_MINIMAL: 413,
+    GEMINI_3_0_FLASH_LOW: 414,
+    GEMINI_3_0_FLASH_MEDIUM: 415,
+    GEMINI_3_0_FLASH_HIGH: 416,
+    // ============================================================================
+    // DeepSeek
+    // ============================================================================
+    DEEPSEEK_V3: 205,
+    DEEPSEEK_R1: 206,
+    DEEPSEEK_R1_SLOW: 215,
+    DEEPSEEK_R1_FAST: 216,
+    DEEPSEEK_V3_2: 409,
+    // ============================================================================
+    // Llama
+    // ============================================================================
+    LLAMA_3_1_8B_INSTRUCT: 106,
+    LLAMA_3_1_70B_INSTRUCT: 107,
+    LLAMA_3_1_405B_INSTRUCT: 105,
+    LLAMA_3_3_70B_INSTRUCT: 208,
+    LLAMA_3_3_70B_INSTRUCT_R1: 209,
+    // ============================================================================
+    // Qwen
+    // ============================================================================
+    QWEN_2_5_7B_INSTRUCT: 178,
+    QWEN_2_5_32B_INSTRUCT: 179,
+    QWEN_2_5_72B_INSTRUCT: 180,
+    QWEN_2_5_32B_INSTRUCT_R1: 224,
+    QWEN_3_235B_INSTRUCT: 324,
+    QWEN_3_CODER_480B_INSTRUCT: 325,
+    QWEN_3_CODER_480B_INSTRUCT_FAST: 327,
+    // ============================================================================
+    // XAI Grok
+    // ============================================================================
+    GROK_2: 212,
+    GROK_3: 217,
+    GROK_3_MINI_REASONING: 234,
+    GROK_CODE_FAST: 345,
+    // ============================================================================
+    // Other Models
+    // ============================================================================
+    MISTRAL_7B: 77,
+    KIMI_K2: 323,
+    KIMI_K2_THINKING: 394,
+    GLM_4_5: 342,
+    GLM_4_5_FAST: 352,
+    GLM_4_6: 356,
+    GLM_4_6_FAST: 357,
+    GLM_4_7: 417,
+    GLM_4_7_FAST: 418,
+    MINIMAX_M2: 368,
+    MINIMAX_M2_1: 419,
+    SWE_1_5: 359,
+    SWE_1_5_THINKING: 369,
+    SWE_1_5_SLOW: 377,
+    CLAUDE_4_5_SONNET_THINKING_1M: 371,
+};
+/**
+ * Chat message source types for protobuf encoding
+ */
+exports.ChatMessageSource = {
+    UNSPECIFIED: 0,
+    USER: 1,
+    SYSTEM: 2,
+    ASSISTANT: 3,
+    TOOL: 4,
+};
diff --git a/src/providers/zhipu/index.js b/src/providers/zhipu/index.js
new file mode 100644
index 0000000..e89c6a6
--- /dev/null
+++ b/src/providers/zhipu/index.js
@@ -0,0 +1,27 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.ZhipuProvider = void 0;
+const types_1 = require("../../core/types");
+class ZhipuProvider {
+    static getHeaders(account) {
+        const headers = {
+            'content-type': 'application/json',
+        };
+        if (account.apiKey) {
+            headers['Authorization'] = `Bearer ${account.apiKey}`;
+        }
+        return headers;
+    }
+    static async login() {
+        // Simple prompt simulation, in real CLI this would be passed
+        const { Password } = require('enquirer');
+        const prompt = new Password({
+            name: 'apiKey',
+            message: 'Enter your Zhipu AI API Key'
+        });
+        const apiKey = await prompt.run();
+        return { apiKey };
+    }
+}
+exports.ZhipuProvider = ZhipuProvider;
+ZhipuProvider.provider = types_1.AuthProvider.Zhipu;
diff --git a/src/scripts/git-hook.ts b/src/scripts/git-hook.ts
deleted file mode 100644
index 9cf8d7e..0000000
--- a/src/scripts/git-hook.ts
+++ /dev/null
@@ -1,86 +0,0 @@
-import { createAuthMonster } from '../index';
-import { ConfigManager } from '../core/config';
-import { getProviderEndpoint } from '../core/endpoints';
-import { AuthProvider } from '../core/types';
-import { execSync } from 'child_process';
-import * as fs from 'fs';
-
-async function main() {
-  const commitMsgFile = process.argv[2];
-  const source = process.argv[3];
-
-  if (source === 'message' || source === 'merge' || source === 'squash') {
-    process.exit(0);
-  }
-
-  let diff = '';
-  try {
-    diff = execSync('git diff --cached').toString();
-  } catch (e) {
-    process.exit(0);
-  }
-
-  if (!diff.trim()) {
-    process.exit(0);
-  }
-
-  const configManager = new ConfigManager();
-  const config = configManager.loadConfig();
-  const monster = createAuthMonster({
-    config,
-    storagePath: configManager.getConfigDir()
-  });
-
-  await monster.init();
-
-  // Prefer a fast model, or fallback to config active
-  const model = 'gemini-3-flash-preview';
-  const details = await monster.getAuthDetails(model) || await monster.getAuthDetails(config.active);
-
-  if (!details) {
-      console.error('AuthMonster: No active account found for commit generation.');
-      process.exit(0);
-  }
-
-  const url = getProviderEndpoint(details.provider, details.account, details.modelInProvider);
-
-  const prompt = `Generate a concise and descriptive commit message for the following changes.
-  Follow the conventional commits specification (e.g. feat: ..., fix: ...).
-  Only output the commit message, no explanations.
-
-  Diff:
-  ${diff.substring(0, 8000)}`;
-
-  try {
-      console.log('AuthMonster: Generating commit message...');
-      const response = await monster.request(model, url, {
-          method: 'POST',
-          headers: { 'Content-Type': 'application/json' },
-          body: {
-              messages: [{ role: 'user', content: prompt }],
-              model: details.modelInProvider,
-              temperature: 0.3
-          }
-      });
-
-      const json = await response.json() as any;
-      let message = '';
-
-      if (details.provider === AuthProvider.Gemini) {
-          message = json.candidates?.[0]?.content?.parts?.[0]?.text || '';
-      } else if (details.provider === AuthProvider.Anthropic) {
-          message = json.content?.[0]?.text || '';
-      } else {
-          message = json.choices?.[0]?.message?.content || '';
-      }
-
-      if (message) {
-          const currentContent = fs.readFileSync(commitMsgFile, 'utf-8');
-          fs.writeFileSync(commitMsgFile, `${message.trim()}\n\n${currentContent}`);
-      }
-  } catch (e) {
-      console.error('AuthMonster: Failed to generate commit message.', e);
-  }
-}
-
-main().catch(() => process.exit(0));
diff --git a/src/scripts/model-manager.js b/src/scripts/model-manager.js
new file mode 100644
index 0000000..7e16e7a
--- /dev/null
+++ b/src/scripts/model-manager.js
@@ -0,0 +1,62 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.runModelManagerTUI = runModelManagerTUI;
+const config_1 = require("../core/config");
+const { Select, Form, List, Toggle } = require('enquirer');
+async function runModelManagerTUI() {
+    console.log("\n===  Auth Monster Model Manager ===\n");
+    const configManager = new config_1.ConfigManager();
+    const config = configManager.loadConfig();
+    // Menu Principal
+    const action = await new Select({
+        name: 'action',
+        message: 'What would you like to configure?',
+        choices: [
+            { name: 'personas', message: 'Manage Model Personas / Aliases' },
+            { name: 'fallbacks', message: 'Configure Fallback Chains' },
+            { name: 'exit', message: 'Exit' }
+        ]
+    }).run();
+    if (action === 'exit')
+        return;
+    if (action === 'personas') {
+        await managePersonas(config, configManager);
+    }
+    else if (action === 'fallbacks') {
+        await manageFallbacks(config, configManager);
+    }
+}
+async function managePersonas(config, manager) {
+    // Simples visualizao por enquanto, expansvel no futuro
+    console.log("\n--- Current Managed Models ---");
+    const models = Object.keys(config.modelPriorities || {});
+    if (models.length === 0) {
+        console.log("No custom model personas defined yet.");
+    }
+    else {
+        models.forEach(m => console.log(` ${m}`));
+    }
+    console.log("\n(Use 'fallback' option to define chains for these personas)");
+}
+async function manageFallbacks(config, manager) {
+    const modelName = await new Form({
+        name: 'model',
+        message: 'Define Fallback Chain',
+        choices: [
+            { name: 'alias', message: 'Model Alias (e.g. "sonnet")', initial: 'sonnet' },
+            { name: 'chain', message: 'Fallback Chain (comma separated)', initial: 'claude-4.5-sonnet, gemini-3-pro' }
+        ]
+    }).run();
+    if (modelName.alias && modelName.chain) {
+        if (!config.modelPriorities)
+            config.modelPriorities = {};
+        const chain = modelName.chain.split(',').map((s) => s.trim().toLowerCase());
+        config.modelPriorities[modelName.alias.toLowerCase()] = chain;
+        manager.saveConfig(config);
+        console.log(`\n Updated chain for [${modelName.alias}]: ${chain.join(' -> ')}`);
+    }
+}
+// Allow direct execution if run as script
+if (require.main === module) {
+    runModelManagerTUI().catch(console.error);
+}
diff --git a/src/server/index.ts b/src/server/index.ts
deleted file mode 100644
index 245541c..0000000
--- a/src/server/index.ts
+++ /dev/null
@@ -1,100 +0,0 @@
-import express from 'express';
-import { AuthMonster } from '../index';
-
-export function startServer(monster: AuthMonster, port: number = 3000) {
-  const app = express();
-
-  app.get('/', (req, res) => {
-    res.send(`
-<!DOCTYPE html>
-<html lang="en">
-<head>
-    <meta charset="UTF-8">
-    <meta name="viewport" content="width=device-width, initial-scale=1.0">
-    <title>Auth Monster Dashboard</title>
-    <style>
-        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #1e1e1e; color: #fff; margin: 0; padding: 20px; }
-        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
-        th, td { text-align: left; padding: 12px; border-bottom: 1px solid #333; }
-        th { background-color: #2d2d2d; }
-        tr:hover { background-color: #2d2d2d; }
-        .healthy { color: #4caf50; }
-        .unhealthy { color: #f44336; }
-        .card { background: #252526; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
-        h1 { margin-top: 0; }
-        .refresh-btn { float: right; padding: 8px 16px; background: #007acc; color: white; border: none; border-radius: 4px; cursor: pointer; }
-    </style>
-</head>
-<body>
-    <div class="card">
-        <button class="refresh-btn" onclick="fetchData()">Refresh</button>
-        <h1>Auth Monster Dashboard</h1>
-        <div id="status">Loading...</div>
-    </div>
-
-    <div class="card">
-        <h2>Accounts</h2>
-        <table id="accounts">
-            <thead>
-                <tr>
-                    <th>Provider</th>
-                    <th>Email</th>
-                    <th>Status</th>
-                    <th>Health Score</th>
-                    <th>Last Used</th>
-                </tr>
-            </thead>
-            <tbody></tbody>
-        </table>
-    </div>
-
-    <script>
-        async function fetchData() {
-            try {
-                const response = await fetch('/api/status');
-                const data = await response.json();
-
-                document.getElementById('status').innerText = \`Total Accounts: \${data.totalAccounts} | Healthy: \${data.healthyAccounts}\`;
-
-                const tbody = document.querySelector('#accounts tbody');
-                tbody.innerHTML = '';
-
-                data.accounts.forEach(acc => {
-                    const row = document.createElement('tr');
-                    row.innerHTML = \`
-                        <td>\${acc.provider}</td>
-                        <td>\${acc.email}</td>
-                        <td class="\${acc.isHealthy ? 'healthy' : 'unhealthy'}">\${acc.isHealthy ? 'Healthy' : 'Unhealthy'}</td>
-                        <td>\${acc.healthScore}</td>
-                        <td>\${acc.lastUsed ? new Date(acc.lastUsed).toLocaleString() : 'Never'}</td>
-                    \`;
-                    tbody.appendChild(row);
-                });
-            } catch (e) {
-                console.error(e);
-            }
-        }
-
-        fetchData();
-        setInterval(fetchData, 2000);
-    </script>
-</body>
-</html>
-    `);
-  });
-
-  app.get('/api/status', async (req, res) => {
-    // Reload accounts to get latest state from disk
-    await monster.init();
-    const accounts = monster.getAllAccountsStatus();
-    res.json({
-      totalAccounts: accounts.length,
-      healthyAccounts: accounts.filter(a => a.isHealthy).length,
-      accounts
-    });
-  });
-
-  app.listen(port, '127.0.0.1', () => {
-    console.log(`Web Admin Dashboard running at http://127.0.0.1:${port}`);
-  });
-}
diff --git a/src/test/basic.test.js b/src/test/basic.test.js
new file mode 100644
index 0000000..5c9ccc8
--- /dev/null
+++ b/src/test/basic.test.js
@@ -0,0 +1,50 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+const index_1 = require("../index");
+const types_1 = require("../core/types");
+const path_1 = __importDefault(require("path"));
+const fs_1 = __importDefault(require("fs"));
+async function test() {
+    const testStorage = path_1.default.join(__dirname, '../../test-storage');
+    if (fs_1.default.existsSync(testStorage)) {
+        fs_1.default.rmSync(testStorage, { recursive: true });
+    }
+    const monster = new index_1.AuthMonster({
+        config: {
+            active: types_1.AuthProvider.Gemini,
+            fallback: [],
+            method: 'sticky',
+            modelPriorities: {},
+            fallbackDirection: 'down',
+            providers: {}
+        },
+        storagePath: testStorage
+    });
+    await monster.init();
+    console.log('Initialized AuthMonster');
+    const testAccount = {
+        id: 'test-gemini',
+        email: 'test@example.com',
+        provider: types_1.AuthProvider.Gemini,
+        tokens: { accessToken: 'fake-token' },
+        apiKey: 'fake-api-key',
+        isHealthy: true
+    };
+    await monster.addAccount(testAccount);
+    console.log('Added test account');
+    const auth = await monster.getAuthDetails();
+    if (auth && auth.headers['x-goog-api-key'] === 'fake-api-key') {
+        console.log('SUCCESS: Gemini auth details retrieved correctly');
+    }
+    else {
+        console.log('FAILURE: Could not retrieve Gemini auth details', auth);
+        process.exit(1);
+    }
+}
+test().catch(err => {
+    console.error(err);
+    process.exit(1);
+});
diff --git a/src/test/fallback.test.js b/src/test/fallback.test.js
new file mode 100644
index 0000000..ad5539d
--- /dev/null
+++ b/src/test/fallback.test.js
@@ -0,0 +1,134 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+const index_1 = require("../index");
+const types_1 = require("../core/types");
+const path_1 = __importDefault(require("path"));
+const fs_1 = __importDefault(require("fs"));
+async function testFallback() {
+    const testStorage = path_1.default.join(__dirname, '../../test-fallback-storage');
+    if (fs_1.default.existsSync(testStorage)) {
+        fs_1.default.rmSync(testStorage, { recursive: true });
+    }
+    const monster = new index_1.AuthMonster({
+        config: {
+            active: types_1.AuthProvider.Gemini,
+            fallback: [],
+            method: 'sticky',
+            providers: {},
+            modelPriorities: {
+                'gemini-3-pro-preview': ['claude-4.5-opus-thinking', 'gpt-5.2-codex']
+            },
+            fallbackDirection: 'down'
+        },
+        storagePath: testStorage
+    });
+    await monster.init();
+    // Add accounts for different providers
+    const geminiAcc = {
+        id: 'gemini-acc',
+        email: 'gemini@example.com',
+        provider: types_1.AuthProvider.Gemini,
+        tokens: { accessToken: 'g-token' },
+        isHealthy: true,
+        healthScore: 100
+    };
+    const anthropicAcc = {
+        id: 'anthropic-acc',
+        email: 'anthropic@example.com',
+        provider: types_1.AuthProvider.Anthropic,
+        tokens: { accessToken: 'a-token' },
+        isHealthy: true,
+        healthScore: 100
+    };
+    await monster.addAccount(geminiAcc);
+    await monster.addAccount(anthropicAcc);
+    console.log('--- Testing resolveModelChain ---');
+    const chain = monster.hub.resolveModelChain('gemini-3-pro-preview', monster.config);
+    console.log('Chain:', chain);
+    if (chain.length === 3 && chain[1] === 'claude-4.5-opus-thinking') {
+        console.log('SUCCESS: resolveModelChain works');
+    }
+    else {
+        console.log('FAILURE: resolveModelChain failed', chain);
+        process.exit(1);
+    }
+    console.log('--- Testing getAuthDetails Fallback ---');
+    // First, it should pick Gemini
+    const details1 = await monster.getAuthDetails('gemini-3-pro-preview');
+    console.log('Details 1:', details1?.account.email, details1?.provider);
+    if (details1?.provider === types_1.AuthProvider.Gemini) {
+        console.log('SUCCESS: Picked Gemini first');
+    }
+    else {
+        console.log('FAILURE: Did not pick Gemini first');
+        process.exit(1);
+    }
+    // Now, report rate limit on Gemini
+    console.log('Reporting rate limit on Gemini account...');
+    await monster.reportRateLimit(geminiAcc.id, 60000, 'QUOTA_EXHAUSTED');
+    // Now it should pick Anthropic (claude-4.5-opus-thinking)
+    const details2 = await monster.getAuthDetails('gemini-3-pro-preview');
+    console.log('Details 2:', details2?.account.email, details2?.provider);
+    if (details2?.provider === types_1.AuthProvider.Anthropic) {
+        console.log('SUCCESS: Picked Anthropic as fallback');
+    }
+    else {
+        console.log('FAILURE: Did not pick Anthropic as fallback');
+        process.exit(1);
+    }
+    console.log('--- Testing request with Transparent Fallback ---');
+    // Reset health
+    monster.accounts.forEach((a) => {
+        a.isHealthy = true;
+        a.rateLimitResetTime = 0;
+    });
+    let callCount = 0;
+    let modelRequests = [];
+    // Mock global fetch
+    global.fetch = async (url, init) => {
+        // Ignore warmup calls for accounting
+        if (url.includes('messages') && init.body && JSON.parse(init.body).max_tokens === 1) {
+            return { ok: true, text: async () => 'warmup' };
+        }
+        callCount++;
+        const body = JSON.parse(init.body);
+        modelRequests.push(body.model);
+        if (body.model === 'gemini-3-pro') {
+            return {
+                status: 429,
+                ok: false,
+                clone: () => ({
+                    text: async () => 'Quota exceeded'
+                }),
+                text: async () => 'Quota exceeded'
+            };
+        }
+        return {
+            status: 200,
+            ok: true,
+            text: async () => 'Success from ' + body.model
+        };
+    };
+    const response = await monster.request('gemini-3-pro-preview', 'https://api.example.com', {
+        method: 'POST',
+        body: { prompt: 'Hello' }
+    });
+    const responseText = await response.text();
+    console.log('Response text:', responseText);
+    console.log('Model requests:', modelRequests);
+    if (modelRequests.length === 2 && modelRequests[0] === 'gemini-3-pro' && modelRequests[1] === 'claude-4.5-opus-thinking') {
+        console.log('SUCCESS: Transparent fallback works in request()');
+    }
+    else {
+        console.log('FAILURE: Transparent fallback failed in request()', modelRequests, responseText);
+        process.exit(1);
+    }
+    console.log('Fallback test completed successfully.');
+}
+testFallback().catch(err => {
+    console.error(err);
+    process.exit(1);
+});
diff --git a/src/test/stability.test.js b/src/test/stability.test.js
new file mode 100644
index 0000000..e5285f3
--- /dev/null
+++ b/src/test/stability.test.js
@@ -0,0 +1,73 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+const index_1 = require("../index");
+const types_1 = require("../core/types");
+const path_1 = __importDefault(require("path"));
+const fs_1 = __importDefault(require("fs"));
+async function testStability() {
+    const testStorage = path_1.default.join(__dirname, '../../test-stability-storage');
+    if (fs_1.default.existsSync(testStorage)) {
+        fs_1.default.rmSync(testStorage, { recursive: true });
+    }
+    const monster = new index_1.AuthMonster({
+        config: {
+            active: types_1.AuthProvider.Anthropic,
+            fallback: [],
+            method: 'round-robin',
+            modelPriorities: {},
+            fallbackDirection: 'down',
+            providers: {}
+        },
+        storagePath: testStorage
+    });
+    await monster.init();
+    const account1 = {
+        id: 'acc1',
+        email: 'acc1@example.com',
+        provider: types_1.AuthProvider.Anthropic,
+        tokens: { accessToken: 'token1' },
+        isHealthy: true,
+        healthScore: 100,
+        metadata: { model: 'claude-3-5-sonnet-20241022' }
+    };
+    const account2 = {
+        id: 'acc2',
+        email: 'acc2@example.com',
+        provider: types_1.AuthProvider.Anthropic,
+        tokens: { accessToken: 'token2' },
+        isHealthy: true,
+        healthScore: 100,
+        metadata: { model: 'claude-3-5-sonnet-20241022' }
+    };
+    await monster.addAccount(account1);
+    await monster.addAccount(account2);
+    console.log('--- Testing Rate Limit Deduplication ---');
+    // Report rate limit twice quickly
+    await monster.reportRateLimit('acc1', 10000, 'RATE_LIMIT_EXCEEDED');
+    const status1 = monster.getAllAccountsStatus().find(a => a.id === 'acc1');
+    console.log(`First report: score=${status1?.healthScore}, failures=${status1?.consecutiveFailures}`);
+    await monster.reportRateLimit('acc1', 10000, 'RATE_LIMIT_EXCEEDED');
+    const status2 = monster.getAllAccountsStatus().find(a => a.id === 'acc1');
+    console.log(`Second report (immediate): score=${status2?.healthScore}, failures=${status2?.consecutiveFailures}`);
+    if (status1?.consecutiveFailures === status2?.consecutiveFailures) {
+        console.log('SUCCESS: Rate limit deduplicated!');
+    }
+    else {
+        console.log('FAILURE: Rate limit NOT deduplicated!');
+        process.exit(1);
+    }
+    console.log('--- Testing Thinking Warmup Trigger ---');
+    // We can't easily test the actual fetch without mocking, but we can verify it doesn't crash
+    const details1 = await monster.getAuthDetails();
+    console.log(`Selected: ${details1?.account.email}`);
+    const details2 = await monster.getAuthDetails();
+    console.log(`Selected (round-robin): ${details2?.account.email}`);
+    console.log('Stability test completed successfully.');
+}
+testStability().catch(err => {
+    console.error(err);
+    process.exit(1);
+});
diff --git a/src/ui/dashboard.ts b/src/ui/dashboard.ts
deleted file mode 100644
index 8594a5f..0000000
--- a/src/ui/dashboard.ts
+++ /dev/null
@@ -1,82 +0,0 @@
-import blessed from 'blessed';
-const contrib = require('blessed-contrib');
-import { AuthMonster } from '../index';
-
-export function startDashboard(monster: AuthMonster) {
-  const screen = blessed.screen({
-    smartCSR: true,
-    title: 'Auth Monster Dashboard'
-  });
-
-  const grid = new contrib.grid({rows: 12, cols: 12, screen: screen});
-
-  // Health Gauge
-  const gauge = grid.set(0, 0, 4, 4, contrib.gauge, {
-    label: 'System Health',
-    percent: [0],
-    stroke: 'green',
-    fill: 'white'
-  });
-
-  // Status Log
-  const log = grid.set(0, 4, 4, 8, contrib.log, {
-    fg: 'green',
-    selectedFg: 'green',
-    label: 'Activity Log'
-  });
-
-  // Accounts Table
-  const table = grid.set(4, 0, 8, 12, contrib.table, {
-    keys: true,
-    fg: 'white',
-    selectedFg: 'white',
-    selectedBg: 'blue',
-    interactive: true,
-    label: 'Accounts',
-    width: '30%',
-    height: '30%',
-    border: {type: 'line', fg: 'cyan'},
-    columnSpacing: 10,
-    columnWidth: [15, 30, 10, 10, 20]
-  });
-
-  screen.key(['escape', 'q', 'C-c'], function(ch: any, key: any) {
-    return process.exit(0);
-  });
-
-  // Initial render
-  updateDashboard();
-
-  // Periodic update
-  setInterval(updateDashboard, 1000);
-
-  async function updateDashboard() {
-    await monster.init();
-    const accounts = monster.getAllAccountsStatus();
-
-    // Update Gauge
-    const total = accounts.length;
-    const healthy = accounts.filter(a => a.isHealthy).length;
-    const healthPercent = total > 0 ? Math.round((healthy / total) * 100) : 0;
-    gauge.setPercent(healthPercent);
-
-    // Update Table
-    const tableData = accounts.map(a => [
-        a.provider,
-        a.email,
-        a.isHealthy ? 'Healthy' : 'Unhealthy',
-        a.healthScore.toString(),
-        a.lastUsed ? new Date(a.lastUsed).toLocaleTimeString() : 'Never'
-    ]);
-
-    table.setData({
-        headers: ['Provider', 'Email', 'Status', 'Score', 'Last Used'],
-        data: tableData
-    });
-
-    screen.render();
-  }
-
-  log.log('Dashboard started...');
-  log.log(`Monitoring ${monster.getAccounts().length} accounts.`);
-}
diff --git a/src/utils/extractor.js b/src/utils/extractor.js
new file mode 100644
index 0000000..e66b4ba
--- /dev/null
+++ b/src/utils/extractor.js
@@ -0,0 +1,325 @@
+"use strict";
+var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    var desc = Object.getOwnPropertyDescriptor(m, k);
+    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
+      desc = { enumerable: true, get: function() { return m[k]; } };
+    }
+    Object.defineProperty(o, k2, desc);
+}) : (function(o, m, k, k2) {
+    if (k2 === undefined) k2 = k;
+    o[k2] = m[k];
+}));
+var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
+    Object.defineProperty(o, "default", { enumerable: true, value: v });
+}) : function(o, v) {
+    o["default"] = v;
+});
+var __importStar = (this && this.__importStar) || (function () {
+    var ownKeys = function(o) {
+        ownKeys = Object.getOwnPropertyNames || function (o) {
+            var ar = [];
+            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
+            return ar;
+        };
+        return ownKeys(o);
+    };
+    return function (mod) {
+        if (mod && mod.__esModule) return mod;
+        var result = {};
+        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
+        __setModuleDefault(result, mod);
+        return result;
+    };
+})();
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.autoDiscoverAccounts = exports.TokenExtractor = void 0;
+const child_process_1 = require("child_process");
+const path = __importStar(require("path"));
+const os = __importStar(require("os"));
+const fs = __importStar(require("fs"));
+const crypto = __importStar(require("crypto"));
+const types_1 = require("../core/types");
+class TokenExtractor {
+    /**
+     * Auto-discover accounts from local environment (Cursor, Windsurf, Env Vars).
+     */
+    static async discoverAll() {
+        const accounts = [];
+        // 1. Cursor (Keychain)
+        try {
+            const cursorToken = this.getCursorToken();
+            if (cursorToken) {
+                accounts.push({
+                    id: 'cursor-local',
+                    email: 'local-cursor@device',
+                    provider: types_1.AuthProvider.Cursor,
+                    tokens: { accessToken: cursorToken },
+                    isHealthy: true,
+                    healthScore: 100,
+                    metadata: { source: 'keychain' }
+                });
+            }
+        }
+        catch (e) {
+            // Ignore missing cursor
+        }
+        // 2. Windsurf (SQLite)
+        try {
+            const windsurfAuth = this.getWindsurfAuth();
+            if (windsurfAuth) {
+                accounts.push({
+                    id: 'windsurf-local',
+                    email: 'local-windsurf@device',
+                    provider: types_1.AuthProvider.Windsurf,
+                    tokens: { accessToken: windsurfAuth },
+                    isHealthy: true,
+                    healthScore: 100,
+                    metadata: { source: 'sqlite' }
+                });
+            }
+        }
+        catch (e) {
+            // Ignore missing windsurf
+        }
+        // 3. Qwen (File)
+        try {
+            const qwenToken = this.getQwenToken();
+            if (qwenToken) {
+                accounts.push({
+                    id: 'qwen-local',
+                    email: 'local-qwen@device',
+                    provider: types_1.AuthProvider.Qwen,
+                    tokens: { accessToken: qwenToken },
+                    isHealthy: true,
+                    healthScore: 100,
+                    metadata: { source: 'file' }
+                });
+            }
+        }
+        catch (e) {
+            // Ignore missing qwen
+        }
+        // 4. Kiro/AWS SSO (File)
+        try {
+            const kiroToken = await this.extractKiroFromSSOCache();
+            if (kiroToken) {
+                accounts.push({
+                    id: 'kiro-local',
+                    email: kiroToken.email || 'local-kiro@aws',
+                    provider: types_1.AuthProvider.Kiro,
+                    tokens: { accessToken: kiroToken.token },
+                    isHealthy: true,
+                    healthScore: 100,
+                    metadata: { source: 'aws-sso' }
+                });
+            }
+        }
+        catch (e) {
+            // Ignore missing kiro
+        }
+        // 5. Claude (Keychain)
+        try {
+            const claudeToken = this.extractClaudeFromKeychain();
+            if (claudeToken) {
+                accounts.push({
+                    id: 'claude-local',
+                    email: 'local-claude@device',
+                    provider: types_1.AuthProvider.Anthropic,
+                    tokens: { accessToken: claudeToken },
+                    isHealthy: true,
+                    healthScore: 100,
+                    metadata: { source: 'keychain', model: 'claude-3-opus-20240229' }
+                });
+            }
+        }
+        catch (e) {
+            // Ignore missing claude
+        }
+        return accounts;
+    }
+    static async extractKiroFromSSOCache() {
+        const home = os.homedir();
+        const ssoCachePath = path.join(home, '.aws', 'sso', 'cache');
+        if (!fs.existsSync(ssoCachePath))
+            return null;
+        try {
+            const files = fs.readdirSync(ssoCachePath);
+            for (const file of files) {
+                if (!file.endsWith('.json'))
+                    continue;
+                try {
+                    const content = fs.readFileSync(path.join(ssoCachePath, file), 'utf8');
+                    const json = JSON.parse(content);
+                    // Look for standard AWS SSO token format
+                    if (json.accessToken && json.expiresAt) {
+                        // Check expiry
+                        const expiresAt = new Date(json.expiresAt).getTime();
+                        if (expiresAt > Date.now()) {
+                            // Found valid token
+                            return {
+                                provider: types_1.AuthProvider.Kiro,
+                                token: json.accessToken,
+                                email: json.email // Sometimes present?
+                            };
+                        }
+                    }
+                }
+                catch (e) {
+                    continue;
+                }
+            }
+        }
+        catch (e) {
+            return null;
+        }
+        return null;
+    }
+    static extractCursorFromKeychain() {
+        return this.getCursorToken();
+    }
+    static extractClaudeFromKeychain() {
+        if (process.platform !== 'darwin')
+            return null;
+        // Logic from CodMate:
+        // Service Name: "Claude Code-credentials-<hash>"
+        // Hash is first 8 chars of SHA256 of expanded path "~/.claude"
+        const home = os.homedir();
+        const configPath = path.join(home, '.claude');
+        // Hash path
+        const hash = crypto.createHash('sha256').update(configPath).digest('hex').substring(0, 8);
+        const serviceName = `Claude Code-credentials-${hash}`;
+        try {
+            // We use 'security find-generic-password' with service name
+            // The account name is usually the OS username, but 'security' can find by service alone if unique enough
+            // or we can iterate.
+            const result = (0, child_process_1.execSync)(`security find-generic-password -s "${serviceName}" -w`, {
+                encoding: 'utf8',
+                stdio: ['pipe', 'pipe', 'pipe']
+            }).trim();
+            // Result is likely a JSON envelope
+            if (result) {
+                try {
+                    // Sometimes it returns the raw password (token) if -w is used,
+                    // but CodMate implies it stores a JSON "CredentialEnvelope".
+                    // However, `security -w` returns the password item.
+                    // If CodMate stores the JSON *as* the password, this works.
+                    // If it stores it as attribute, we might need different flags.
+                    // Assuming it stores the JSON string as the keychain item 'password' (data).
+                    // Let's try to parse as JSON
+                    const json = JSON.parse(result);
+                    if (json.claudeAiOauth && json.claudeAiOauth.accessToken) {
+                        return json.claudeAiOauth.accessToken;
+                    }
+                }
+                catch (e) {
+                    // If not JSON, maybe it's the token directly?
+                    if (result.startsWith('sk-'))
+                        return result;
+                }
+            }
+        }
+        catch (e) {
+            // Try fallback service name without hash or "Claude Code"
+        }
+        return null;
+    }
+    static extractCursorFromSQLite() {
+        const home = os.homedir();
+        let dbPath = '';
+        switch (process.platform) {
+            case 'darwin':
+                dbPath = path.join(home, 'Library/Application Support/Cursor/User/globalStorage/state.vscdb');
+                break;
+            case 'win32':
+                dbPath = path.join(process.env.APPDATA || path.join(home, 'AppData', 'Roaming'), 'Cursor/User/globalStorage/state.vscdb');
+                break;
+            case 'linux':
+                dbPath = path.join(home, '.config/Cursor/User/globalStorage/state.vscdb');
+                break;
+            default:
+                return null;
+        }
+        if (!fs.existsSync(dbPath))
+            return null;
+        try {
+            const query = "SELECT value FROM ItemTable WHERE key = 'cursorAuth/accessToken';";
+            const result = (0, child_process_1.execSync)(`sqlite3 "${dbPath}" "${query}"`, {
+                encoding: 'utf8',
+                stdio: ['pipe', 'pipe', 'pipe']
+            }).trim();
+            if (!result)
+                return null;
+            return result;
+        }
+        catch (e) {
+            return null;
+        }
+    }
+    static extractWindsurfFromSQLite() {
+        return this.getWindsurfAuth();
+    }
+    /**
+     * Extract Cursor token from macOS Keychain.
+     */
+    static getCursorToken() {
+        if (process.platform !== 'darwin')
+            return null;
+        try {
+            return (0, child_process_1.execSync)('security find-generic-password -s "cursor-access-token" -w', {
+                encoding: 'utf8',
+                stdio: ['pipe', 'pipe', 'pipe'],
+            }).trim();
+        }
+        catch (e) {
+            return null;
+        }
+    }
+    /**
+     * Extract Windsurf auth status from SQLite DB.
+     */
+    static getWindsurfAuth() {
+        const home = os.homedir();
+        // Common path on macOS/Linux
+        const dbPath = path.join(home, 'Library/Application Support/Windsurf/User/globalStorage/state.vscdb');
+        if (!fs.existsSync(dbPath))
+            return null;
+        try {
+            // Query SQLite directly
+            const query = "SELECT value FROM ItemTable WHERE key = 'windsurfAuthStatus';";
+            const result = (0, child_process_1.execSync)(`sqlite3 "${dbPath}" "${query}"`, {
+                encoding: 'utf8',
+                stdio: ['pipe', 'pipe', 'pipe']
+            }).trim();
+            if (!result)
+                return null;
+            // Parse JSON result to get access token
+            const json = JSON.parse(result);
+            return json.accessToken || null;
+        }
+        catch (e) {
+            return null;
+        }
+    }
+    /**
+     * Extract Qwen token from local creds file.
+     */
+    static getQwenToken() {
+        const home = os.homedir();
+        const credsPath = path.join(home, '.qwen/oauth_creds.json');
+        if (!fs.existsSync(credsPath))
+            return null;
+        try {
+            const data = fs.readFileSync(credsPath, 'utf8');
+            const json = JSON.parse(data);
+            return json.access_token || null;
+        }
+        catch (e) {
+            return null;
+        }
+    }
+}
+exports.TokenExtractor = TokenExtractor;
+// Export for direct usage
+const autoDiscoverAccounts = () => TokenExtractor.discoverAll();
+exports.autoDiscoverAccounts = autoDiscoverAccounts;
diff --git a/src/utils/github-sync.js b/src/utils/github-sync.js
new file mode 100644
index 0000000..8109f60
--- /dev/null
+++ b/src/utils/github-sync.js
@@ -0,0 +1,50 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.syncToGitHub = syncToGitHub;
+const child_process_1 = require("child_process");
+/**
+ * Syncs accounts to GitHub secrets for a target repository.
+ * Standardizes the secret name as OPENCODE_MONSTER_ACCOUNTS.
+ *
+ * @param repo Repository in 'owner/repo' format.
+ * @param accounts List of managed accounts to sync.
+ */
+async function syncToGitHub(repo, accounts) {
+    try {
+        // Check if gh CLI is installed
+        try {
+            (0, child_process_1.execSync)('gh --version', { stdio: 'ignore' });
+        }
+        catch (e) {
+            throw new Error('GitHub CLI (gh) is not installed or not in PATH. Please install it from https://cli.github.com/');
+        }
+        const secretName = 'OPENCODE_MONSTER_ACCOUNTS';
+        // Clean accounts for storage: remove transient health/rotation fields to keep it clean
+        const accountsToSync = accounts.map(acc => ({
+            id: acc.id,
+            email: acc.email,
+            provider: acc.provider,
+            tokens: acc.tokens,
+            apiKey: acc.apiKey,
+            metadata: acc.metadata,
+            isHealthy: true, // Reset health on sync
+            healthScore: 100
+        }));
+        const jsonData = JSON.stringify(accountsToSync, null, 2);
+        // Use gh secret set with stdin to handle potentially large data safely
+        const command = `gh secret set ${secretName} --repo ${repo}`;
+        console.log(`Syncing ${accounts.length} accounts to GitHub secret ${secretName} in ${repo}...`);
+        (0, child_process_1.execSync)(command, {
+            input: jsonData,
+            stdio: ['pipe', 'inherit', 'inherit'],
+            encoding: 'utf8'
+        });
+        console.log(`Successfully synced!`);
+    }
+    catch (error) {
+        if (error.message.includes('gh --version')) {
+            // Handled above but just in case
+        }
+        throw error;
+    }
+}
diff --git a/src/utils/oauth-server.js b/src/utils/oauth-server.js
new file mode 100644
index 0000000..60b4482
--- /dev/null
+++ b/src/utils/oauth-server.js
@@ -0,0 +1,122 @@
+"use strict";
+var __importDefault = (this && this.__importDefault) || function (mod) {
+    return (mod && mod.__esModule) ? mod : { "default": mod };
+};
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.OAUTH_CALLBACK_PORT = void 0;
+exports.generatePKCE = generatePKCE;
+exports.listenForCode = listenForCode;
+const http_1 = __importDefault(require("http"));
+const url_1 = require("url");
+const crypto_1 = __importDefault(require("crypto"));
+/**
+ * Standard port for local OAuth callback server.
+ */
+exports.OAUTH_CALLBACK_PORT = 1455;
+/**
+ * Encodes a buffer to base64url format.
+ */
+function base64UrlEncode(buffer) {
+    return buffer.toString('base64')
+        .replace(/\+/g, '-')
+        .replace(/\//g, '_')
+        .replace(/=/g, '');
+}
+/**
+ * Generates PKCE verifier and challenge.
+ */
+async function generatePKCE() {
+    const verifier = base64UrlEncode(crypto_1.default.randomBytes(32));
+    const challenge = base64UrlEncode(crypto_1.default.createHash('sha256').update(verifier).digest());
+    return { verifier, challenge };
+}
+/**
+ * Listens for an OAuth callback code or token on the specified port.
+ * Returns a promise that resolves with the captured code/token.
+ */
+async function listenForCode(port = exports.OAUTH_CALLBACK_PORT) {
+    return new Promise((resolve, reject) => {
+        const server = http_1.default.createServer((req, res) => {
+            const url = new url_1.URL(req.url || '', `http://${req.headers.host}`);
+            // Handle favicon or other noise
+            if (url.pathname !== '/callback' && url.pathname !== '/oauth2callback') {
+                res.writeHead(404);
+                res.end();
+                return;
+            }
+            // Capture 'code' (OAuth2 code) or 'token' (implicit/custom)
+            // Also capture 'state' if needed by the caller, but here we return the code.
+            const code = url.searchParams.get('code') || url.searchParams.get('token');
+            const state = url.searchParams.get('state');
+            if (code) {
+                res.writeHead(200, { 'Content-Type': 'text/html' });
+                res.end(`
+          <html>
+            <head>
+              <title>Authentication Successful</title>
+              <style>
+                body {
+                  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
+                  display: flex;
+                  align-items: center;
+                  justify-content: center;
+                  height: 100vh;
+                  margin: 0;
+                  background: #f7fafc;
+                }
+                .card {
+                  background: white;
+                  padding: 2.5rem;
+                  border-radius: 12px;
+                  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
+                  text-align: center;
+                  max-width: 400px;
+                }
+                h1 {
+                  color: #2d3748;
+                  margin-top: 0;
+                  font-size: 1.5rem;
+                }
+                p {
+                  color: #4a5568;
+                  line-height: 1.5;
+                }
+                .icon {
+                  color: #48bb78;
+                  font-size: 3rem;
+                  margin-bottom: 1rem;
+                }
+              </style>
+            </head>
+            <body>
+              <div class="card">
+                <div class="icon"></div>
+                <h1>Authentication Successful!</h1>
+                <p>OpenCode Auth Monster has captured your credentials.</p>
+                <p>You can now close this window and return to your terminal.</p>
+              </div>
+            </body>
+          </html>
+        `);
+                // Use a small delay before closing to ensure the response is sent
+                setTimeout(() => {
+                    server.close();
+                    // If we have state, we might want to return both, but for simplicity
+                    // let's just return the code. If the caller needs state, they can parse it.
+                    // Actually, return code + (state ? '#' + state : '') for compatibility with some references
+                    resolve(state ? `${code}#${state}` : code);
+                }, 100);
+            }
+            else {
+                res.writeHead(400, { 'Content-Type': 'text/plain' });
+                res.end('Missing code or token in query parameters.');
+            }
+        });
+        server.on('error', (err) => {
+            reject(err);
+        });
+        server.listen(port, () => {
+            // Server started
+        });
+    });
+}
diff --git a/src/utils/sanitizer.js b/src/utils/sanitizer.js
new file mode 100644
index 0000000..01f436e
--- /dev/null
+++ b/src/utils/sanitizer.js
@@ -0,0 +1,107 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.sanitizeCrossModelRequest = sanitizeCrossModelRequest;
+exports.applyHeaderSpoofing = applyHeaderSpoofing;
+/**
+ * Sanitizes the request body to remove model-specific fields that might cause
+ * conflicts when rotating between different model families.
+ *
+ * This prevents 'Invalid signature' errors when rotating from Gemini (which adds signatures)
+ * to Anthropic/OpenAI (which don't expect them).
+ */
+function sanitizeCrossModelRequest(body) {
+    if (typeof body !== 'object' || body === null) {
+        return body;
+    }
+    // Create a shallow copy if it's an object
+    const sanitized = Array.isArray(body) ? [...body] : { ...body };
+    // Fields to strip from the top-level
+    const fieldsToStrip = [
+        'thoughtSignature',
+        'thinkingMetadata',
+        'signature',
+        'thought_signature',
+        'thoughtSignatureJson'
+    ];
+    if (!Array.isArray(sanitized)) {
+        for (const field of fieldsToStrip) {
+            if (field in sanitized) {
+                delete sanitized[field];
+            }
+        }
+    }
+    // Recursively sanitize messages if present
+    if (sanitized.messages && Array.isArray(sanitized.messages)) {
+        sanitized.messages = sanitized.messages.map((msg) => {
+            if (typeof msg === 'object' && msg !== null) {
+                const newMsg = { ...msg };
+                for (const field of fieldsToStrip) {
+                    if (field in newMsg) {
+                        delete newMsg[field];
+                    }
+                }
+                // Also check inside content if it's an array (Anthropic style)
+                if (Array.isArray(newMsg.content)) {
+                    newMsg.content = newMsg.content.map((block) => {
+                        if (typeof block === 'object' && block !== null) {
+                            const newBlock = { ...block };
+                            for (const field of fieldsToStrip) {
+                                if (field in newBlock) {
+                                    delete newBlock[field];
+                                }
+                            }
+                            return newBlock;
+                        }
+                        return block;
+                    });
+                }
+                return newMsg;
+            }
+            return msg;
+        });
+    }
+    return sanitized;
+}
+/**
+ * Applies strict header spoofing to bypass WAFs and identify as an official client.
+ *
+ * @param headers Original headers
+ * @param accountId Account ID (for Openai-Account-Id)
+ * @param provider Provider type (affects spoofing strategy)
+ */
+function applyHeaderSpoofing(headers, accountId, provider) {
+    const spoofed = { ...headers };
+    // 1. Remove dangerous headers that leak identity
+    const forbiddenHeaders = [
+        'x-stainless-lang',
+        'x-stainless-package-version',
+        'x-stainless-os',
+        'x-stainless-arch',
+        'x-stainless-runtime',
+        'x-stainless-runtime-version',
+        'user-agent' // We will replace it
+    ];
+    for (const h of forbiddenHeaders) {
+        // Case-insensitive deletion
+        Object.keys(spoofed).forEach(k => {
+            if (k.toLowerCase() === h)
+                delete spoofed[k];
+        });
+    }
+    // 2. Inject Official Client Fingerprints
+    spoofed['User-Agent'] = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36';
+    if (provider === 'gemini') {
+        spoofed['X-Goog-Api-Client'] = 'gl-node/1.0.0 gdcl/25.0.0';
+    }
+    else if (provider === 'anthropic') {
+        spoofed['Anthropic-Client'] = 'claude-web-client';
+    }
+    else {
+        // Default OpenAI-like spoofing
+        spoofed['Openai-Account-Id'] = accountId;
+        spoofed['Openai-Intent'] = 'conversation-edits';
+        spoofed['Openai-Internal-Beta'] = 'responses-v1';
+        spoofed['X-Openai-Originator'] = 'codex';
+    }
+    return spoofed;
+}
diff --git a/src/utils/wizard.js b/src/utils/wizard.js
new file mode 100644
index 0000000..2813072
--- /dev/null
+++ b/src/utils/wizard.js
@@ -0,0 +1,228 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+exports.runOnboardingWizard = runOnboardingWizard;
+const types_1 = require("../core/types");
+const config_1 = require("../core/config");
+const anthropic_1 = require("../providers/anthropic");
+const gemini_1 = require("../providers/gemini");
+const windsurf_1 = require("../providers/windsurf");
+const cursor_1 = require("../providers/cursor");
+const qwen_1 = require("../providers/qwen");
+const iflow_1 = require("../providers/iflow");
+const kiro_1 = require("../providers/kiro");
+const zhipu_1 = require("../providers/zhipu");
+const minimax_1 = require("../providers/minimax");
+const extractor_1 = require("./extractor");
+// enquirer types are sometimes missing or incompatible with ESM/TS named imports
+const { MultiSelect, Confirm, Input } = require('enquirer');
+async function runOnboardingWizard(monster) {
+    const configManager = new config_1.ConfigManager();
+    console.log("\n=== OpenCode Auth Monster Onboarding ===\n");
+    const autoDetect = await new Confirm({
+        message: 'Would you like to auto-detect local accounts (Cursor, Windsurf)?',
+        initial: true
+    }).run();
+    if (autoDetect) {
+        const discovered = await (0, extractor_1.autoDiscoverAccounts)();
+        if (discovered.length > 0) {
+            for (const account of discovered) {
+                await monster.addAccount(account);
+                console.log(`[Auto-detect] Added local ${account.provider} account.`);
+            }
+        }
+        else {
+            console.log("No local accounts detected.");
+        }
+    }
+    const providersResponse = await new MultiSelect({
+        name: 'providers',
+        message: 'Which providers do you have accounts for?',
+        choices: [
+            { name: types_1.AuthProvider.Gemini, message: 'Gemini' },
+            { name: types_1.AuthProvider.Anthropic, message: 'Anthropic' },
+            { name: types_1.AuthProvider.Cursor, message: 'Cursor' },
+            { name: types_1.AuthProvider.Windsurf, message: 'Windsurf' },
+            { name: types_1.AuthProvider.OpenAI, message: 'OpenAI' },
+            { name: types_1.AuthProvider.Qwen, message: 'Qwen' },
+            { name: types_1.AuthProvider.IFlow, message: 'iFlow' },
+            { name: types_1.AuthProvider.Kiro, message: 'Kiro (AWS)' },
+            { name: types_1.AuthProvider.Zhipu, message: 'Zhipu AI' },
+            { name: types_1.AuthProvider.Minimax, message: 'MiniMax' },
+        ]
+    }).run();
+    if (providersResponse.length === 0) {
+        console.log("No providers selected. Setup skipped.");
+        return;
+    }
+    for (const provider of providersResponse) {
+        let addAnother = true;
+        while (addAnother) {
+            const confirmAdd = await new Confirm({
+                message: `Add account for ${provider}?`,
+                initial: true
+            }).run();
+            if (confirmAdd) {
+                try {
+                    if (provider === types_1.AuthProvider.Anthropic) {
+                        const tokens = await anthropic_1.AnthropicProvider.login();
+                        await monster.addAccount({
+                            id: Math.random().toString(36).substring(2, 11),
+                            email: 'interactive@anthropic.com',
+                            provider: types_1.AuthProvider.Anthropic,
+                            tokens,
+                            isHealthy: true,
+                            healthScore: 100
+                        });
+                    }
+                    else if (provider === types_1.AuthProvider.Gemini) {
+                        const result = await gemini_1.GeminiProvider.login();
+                        await monster.addAccount({
+                            id: Math.random().toString(36).substring(2, 11),
+                            email: result.email,
+                            provider: types_1.AuthProvider.Gemini,
+                            tokens: {
+                                accessToken: result.accessToken,
+                                refreshToken: result.refreshToken,
+                                expiryDate: result.expiryDate,
+                                tokenType: result.tokenType
+                            },
+                            metadata: result.metadata,
+                            isHealthy: true,
+                            healthScore: 100
+                        });
+                    }
+                    else if (provider === types_1.AuthProvider.Windsurf) {
+                        const account = await windsurf_1.WindsurfProvider.discoverAccount();
+                        await monster.addAccount(account);
+                        console.log(`Discovered local Windsurf account: ${account.email}`);
+                    }
+                    else if (provider === types_1.AuthProvider.Cursor) {
+                        const account = await cursor_1.cursorProvider.discover();
+                        if (account) {
+                            await monster.addAccount(account);
+                            console.log(`Discovered local Cursor account.`);
+                        }
+                        else {
+                            console.log("Could not discover local Cursor account. Please ensure you are logged in to Cursor.");
+                        }
+                    }
+                    else if (provider === types_1.AuthProvider.Qwen) {
+                        const tokens = await qwen_1.QwenProvider.login();
+                        await monster.addAccount({
+                            id: Math.random().toString(36).substring(2, 11),
+                            email: 'interactive@qwen.ai',
+                            provider: types_1.AuthProvider.Qwen,
+                            tokens,
+                            isHealthy: true,
+                            healthScore: 100
+                        });
+                    }
+                    else if (provider === types_1.AuthProvider.IFlow) {
+                        const result = await iflow_1.IFlowProvider.login();
+                        await monster.addAccount({
+                            id: Math.random().toString(36).substring(2, 11),
+                            email: result.email || 'interactive@iflow.cn',
+                            provider: types_1.AuthProvider.IFlow,
+                            tokens: {
+                                accessToken: result.accessToken,
+                                refreshToken: result.refreshToken,
+                                expiryDate: result.expiryDate,
+                                tokenType: result.tokenType
+                            },
+                            apiKey: result.apiKey,
+                            isHealthy: true,
+                            healthScore: 100
+                        });
+                    }
+                    else if (provider === types_1.AuthProvider.Kiro) {
+                        const account = await kiro_1.KiroProvider.discoverAccount();
+                        if (account) {
+                            await monster.addAccount(account);
+                            console.log(`Discovered local Kiro/AWS account: ${account.email}`);
+                        }
+                        else {
+                            console.log("Could not discover local Kiro/AWS account in ~/.aws/sso/cache.");
+                        }
+                    }
+                    else if (provider === types_1.AuthProvider.Zhipu) {
+                        const { apiKey } = await zhipu_1.ZhipuProvider.login();
+                        await monster.addAccount({
+                            id: Math.random().toString(36).substring(2, 11),
+                            email: 'user@zhipu',
+                            provider: types_1.AuthProvider.Zhipu,
+                            tokens: { accessToken: '' }, // API Key only
+                            apiKey,
+                            isHealthy: true,
+                            healthScore: 100
+                        });
+                    }
+                    else if (provider === types_1.AuthProvider.Minimax) {
+                        const { apiKey } = await minimax_1.MinimaxProvider.login();
+                        await monster.addAccount({
+                            id: Math.random().toString(36).substring(2, 11),
+                            email: 'user@minimax',
+                            provider: types_1.AuthProvider.Minimax,
+                            tokens: { accessToken: '' },
+                            apiKey,
+                            isHealthy: true,
+                            healthScore: 100
+                        });
+                    }
+                    else {
+                        console.log(`Interactive login not yet implemented for ${provider}. Please use 'add' command manually.`);
+                        break;
+                    }
+                    console.log(`Successfully added ${provider} account.`);
+                }
+                catch (error) {
+                    console.error(`Failed to add ${provider} account: ${error.message}`);
+                }
+                addAnother = await new Confirm({
+                    message: `Would you like to add another account for ${provider}?`,
+                    initial: false
+                }).run();
+            }
+            else {
+                addAnother = false;
+            }
+        }
+    }
+    await monster.init(); // Reload accounts to be sure
+    // --- Model Priority Configuration ---
+    const configureFallbacks = await new Confirm({
+        message: 'Would you like to configure model fallback priorities?',
+        initial: false
+    }).run();
+    if (configureFallbacks) {
+        let continueConfig = true;
+        while (continueConfig) {
+            const primaryModel = await new Input({
+                message: 'Enter primary model name (e.g., claude-3-7-sonnet):',
+                initial: 'claude-3-7-sonnet-20250219'
+            }).run();
+            const fallbackInput = await new Input({
+                message: 'Enter fallback models (comma-separated, e.g., claude-3-5-sonnet, gemini-2.5-pro):'
+            }).run();
+            const fallbacks = fallbackInput.split(',').map((s) => s.trim()).filter((s) => s.length > 0);
+            if (fallbacks.length > 0) {
+                const config = configManager.loadConfig();
+                if (!config.modelPriorities)
+                    config.modelPriorities = {};
+                config.modelPriorities[primaryModel.toLowerCase()] = fallbacks.map((f) => f.toLowerCase());
+                configManager.saveConfig(config);
+                console.log(`Fallback chain saved for ${primaryModel}.`);
+            }
+            else {
+                console.log("No fallbacks provided. Skipping.");
+            }
+            continueConfig = await new Confirm({
+                message: 'Configure another model?',
+                initial: false
+            }).run();
+        }
+    }
+    const accountsStatus = monster.getAllAccountsStatus();
+    const healthyCount = accountsStatus.filter(a => a.isHealthy).length;
+    const score = accountsStatus.length > 0 ? Math.round((healthyCount / accountsStatus.length) * 100) : 0;
+    console.log(`\nAll accounts added! System health is ${score}. Configuration saved.`);
+}
diff --git a/test/core.test.js b/test/core.test.js
deleted file mode 100644
index eae242a..0000000
--- a/test/core.test.js
+++ /dev/null
@@ -1,113 +0,0 @@
-const { expect } = require('chai');
-const { AccountRotator } = require('../src/core/rotation');
-const { UnifiedModelHub } = require('../src/core/hub');
-const { AuthProvider } = require('../src/core/types');
-const { isOnCooldown, applyCooldown, preflightCheck } = require('../src/core/quota-manager');
-
-describe('Core Components', () => {
-
-    describe('AccountRotator', () => {
-        let rotator;
-        let accounts;
-
-        beforeEach(() => {
-            rotator = new AccountRotator();
-            accounts = [
-                { id: '1', provider: AuthProvider.Gemini, email: '1@test.com', tokens: {}, isHealthy: true, healthScore: 100 },
-                { id: '2', provider: AuthProvider.Gemini, email: '2@test.com', tokens: {}, isHealthy: true, healthScore: 90 },
-                { id: '3', provider: AuthProvider.Gemini, email: '3@test.com', tokens: {}, isHealthy: true, healthScore: 80 }
-            ];
-        });
-
-        it('should select account using round-robin', () => {
-            const first = rotator.selectAccount(accounts, 'round-robin');
-            const second = rotator.selectAccount(accounts, 'round-robin');
-            const third = rotator.selectAccount(accounts, 'round-robin');
-
-            expect(first).to.not.be.null;
-            expect(second).to.not.be.null;
-            expect(third).to.not.be.null;
-
-            const selectedIds = new Set([first.id, second.id, third.id]);
-            expect(selectedIds.size).to.equal(3);
-        });
-
-        it('should skip unhealthy accounts', () => {
-            accounts[1].isHealthy = false;
-
-            const selected = [];
-            for(let i=0; i<5; i++) {
-                selected.push(rotator.selectAccount(accounts, 'round-robin'));
-            }
-
-            const selectedIds = selected.map(a => a.id);
-            expect(selectedIds).to.not.include('2');
-        });
-    });
-
-    describe('UnifiedModelHub', () => {
-        let hub;
-        let accounts;
-
-        beforeEach(() => {
-            hub = new UnifiedModelHub();
-            accounts = [
-                { id: '1', provider: AuthProvider.Gemini, email: 'gemini@test.com', tokens: {}, isHealthy: true, healthScore: 100 },
-                { id: '2', provider: AuthProvider.Anthropic, email: 'claude@test.com', tokens: {}, isHealthy: true, healthScore: 100 },
-                { id: '3', provider: AuthProvider.Windsurf, email: 'windsurf@test.com', tokens: {}, isHealthy: true, healthScore: 100 }
-            ];
-        });
-
-        it('should resolve gemini-3-flash-preview to Gemini or Windsurf', () => {
-            const selection = hub.selectModelAccount('gemini-3-flash-preview', accounts);
-            expect(selection).to.not.be.null;
-            expect([AuthProvider.Gemini, AuthProvider.Windsurf]).to.include(selection.provider);
-            expect(selection.modelInProvider).to.equal('gemini-3-flash');
-        });
-
-        it('should fallback if primary provider is missing', () => {
-            const onlyWindsurf = accounts.filter(a => a.provider === AuthProvider.Windsurf);
-            const selection = hub.selectModelAccount('gemini-3-flash-preview', onlyWindsurf);
-            expect(selection).to.not.be.null;
-            expect(selection.provider).to.equal(AuthProvider.Windsurf);
-        });
-
-        it('should return null for unknown model', () => {
-            const selection = hub.selectModelAccount('unknown-model', accounts);
-            expect(selection).to.be.null;
-        });
-    });
-
-    describe('QuotaManager', () => {
-        it('should track cooldowns', () => {
-            const accountId = 'test-id';
-            const provider = AuthProvider.Gemini;
-
-            expect(isOnCooldown(provider, accountId)).to.be.false;
-
-            applyCooldown(provider, accountId, 1); // 1 minute
-
-            expect(isOnCooldown(provider, accountId)).to.be.true;
-        });
-
-        it('should preflight check allow valid account', () => {
-            const currentAccount = { id: '1', provider: AuthProvider.Gemini, email: '1@test.com', tokens: {}, isHealthy: true, healthScore: 100, quota: { remaining: 100 } };
-            const allAccounts = [currentAccount];
-
-            const result = preflightCheck(AuthProvider.Gemini, currentAccount, allAccounts);
-            expect(result.proceed).to.be.true;
-            expect(result.accountId).to.equal('1');
-        });
-
-        it('should preflight check switch if account has no quota', () => {
-            const currentAccount = { id: '1', provider: AuthProvider.Gemini, email: '1@test.com', tokens: {}, isHealthy: true, healthScore: 100, quota: { remaining: 0 } };
-            const healthyAccount = { id: '2', provider: AuthProvider.Gemini, email: '2@test.com', tokens: {}, isHealthy: true, healthScore: 100, quota: { remaining: 100 } };
-            const allAccounts = [currentAccount, healthyAccount];
-
-            const result = preflightCheck(AuthProvider.Gemini, currentAccount, allAccounts);
-            expect(result.proceed).to.be.true;
-            expect(result.accountId).to.equal('2');
-            expect(result.switchedFrom).to.equal('1');
-        });
-    });
-});
diff --git a/test/integration.test.ts b/test/integration.test.ts
deleted file mode 100644
index 4111a0d..0000000
--- a/test/integration.test.ts
+++ /dev/null
@@ -1,65 +0,0 @@
-const { expect } = require('chai');
-const { UnifiedModelHub } = require('../src/core/hub');
-const { AuthProvider } = require('../src/core/types');
-const { SecretStorage } = require('../src/core/secret-storage');
-const { CostEstimator } = require('../src/core/cost-estimator');
-const { AuthMonster } = require('../src/index');
-const path = require('path');
-const fs = require('fs');
-const os = require('os');
-
-describe('Integration Phases', () => {
-    let tempDir: any;
-
-    before(() => {
-        tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'auth-monster-test-'));
-    });
-
-    after(() => {
-        fs.rmSync(tempDir, { recursive: true, force: true });
-    });
-
-    describe('Phase 1: Secure Storage', () => {
-        it('should instantiate SecretStorage', () => {
-            const secretStorage = new SecretStorage(tempDir);
-            expect(secretStorage).to.be.instanceOf(SecretStorage);
-        });
-
-        it('should save and retrieve secret (fallback mode)', async () => {
-            const secretStorage = new SecretStorage(tempDir);
-            await secretStorage.saveSecret('testService', 'testAccount', 'secretValue');
-            const retrieved = await secretStorage.getSecret('testService', 'testAccount');
-            expect(retrieved).to.equal('secretValue');
-        });
-    });
-
-    describe('Phase 2: Providers', () => {
-        it('should have new providers in AuthProvider enum', () => {
-            expect(AuthProvider.Azure).to.equal('azure');
-            expect(AuthProvider.Grok).to.equal('grok');
-            expect(AuthProvider.DeepSeek).to.equal('deepseek');
-        });
-
-        it('should instantiate UnifiedModelHub with new mappings', () => {
-            const hub = new UnifiedModelHub();
-            expect(hub).to.be.instanceOf(UnifiedModelHub);
-        });
-    });
-
-    describe('Phase 3: Traffic & Cost', () => {
-        it('should calculate cost', () => {
-            const cost = CostEstimator.calculateCost('gpt-4o', 1000000, 1000000);
-            expect(cost).to.be.greaterThan(0);
-        });
-    });
-
-    describe('Phase 4 & 5: UI & Workflows', () => {
-        it('should instantiate AuthMonster', () => {
-            const monster = new AuthMonster({
-                config: { active: AuthProvider.Gemini },
-                storagePath: tempDir
-            });
-            expect(monster).to.be.instanceOf(AuthMonster);
-        });
-    });
-});
diff --git a/tsconfig.json b/tsconfig.json
index 6405e8b..26afe5a 100644
--- a/tsconfig.json
+++ b/tsconfig.json
@@ -1,14 +1,105 @@
 {
   "compilerOptions": {
-    "target": "es2020",
-    "module": "commonjs",
-    "moduleResolution": "node",
-    "outDir": "./dist",
-    "esModuleInterop": true,
-    "forceConsistentCasingInFileNames": true,
-    "strict": true,
-    "skipLibCheck": true
+    /* Visit https://aka.ms/tsconfig to read more about this file */
+
+    /* Projects */
+    // "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */
+    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
+    // "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */
+    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */
+    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
+    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */
+
+    /* Language and Environment */
+    "target": "es2020",                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
+    // "lib": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */
+    // "jsx": "preserve",                                /* Specify what JSX code is generated. */
+    // "experimentalDecorators": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */
+    // "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
+    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */
+    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
+    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */
+    // "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */
+    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
+    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */
+    // "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */
+
+    /* Modules */
+    "module": "commonjs",                                /* Specify what module code is generated. */
+    // "rootDir": "./",                                  /* Specify the root folder within your source files. */
+    // "moduleResolution": "node",                       /* Specify how TypeScript looks up a file from a given module specifier. */
+    // "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
+    // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
+    // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
+    // "typeRoots": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */
+    // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
+    // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
+    // "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */
+    // "resolveJsonModule": true,                        /* Enable importing .json files. */
+    // "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */
+
+    /* JavaScript Support */
+    // "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */
+    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
+    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */
+
+    /* Emit */
+    // "declaration": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
+    // "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
+    // "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
+    // "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
+    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
+    // "outDir": "./",                                   /* Specify an output folder for all emitted files. */
+    // "removeComments": true,                           /* Disable emitting comments. */
+    // "noEmit": true,                                   /* Disable emitting files from a compilation. */
+    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
+    // "importsNotUsedAsValues": "remove",               /* Specify emit/checking behavior for imports that are only used for types. */
+    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
+    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
+    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
+    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
+    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
+    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
+    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
+    // "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */
+    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */
+    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
+    // "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */
+    // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */
+    // "preserveValueImports": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */
+
+    /* Interop Constraints */
+    // "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
+    // "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
+    "esModuleInterop": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */
+    // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
+    "forceConsistentCasingInFileNames": true,            /* Ensure that casing is correct in imports. */
+
+    /* Type Checking */
+    "strict": true,                                      /* Enable all strict type-checking options. */
+    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */
+    // "strictNullChecks": true,                         /* When type checking, take into account 'null' and 'undefined'. */
+    // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
+    // "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */
+    // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
+    // "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */
+    // "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */
+    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
+    // "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */
+    // "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */
+    // "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
+    // "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
+    // "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
+    // "noUncheckedIndexedAccess": true,                 /* Add 'undefined' to a type when accessed using an index. */
+    // "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
+    // "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */
+    // "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
+    // "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */
+
+    /* Completeness */
+    // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
+    "skipLibCheck": true                                 /* Skip type checking all .d.ts files. */
   },
-  "include": ["src/**/*", "test/**/*"],
+  "include": ["src/**/*"],
   "exclude": ["node_modules", "references"]
 }
